# ===----------------------------------------------------------------------=== #
# Copyright (c) 2025, Modular Inc. All rights reserved.
#
# Licensed under the Apache License v2.0 with LLVM Exceptions:
# https://llvm.org/LICENSE.txt
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ===----------------------------------------------------------------------=== #
#

from complex import ComplexFloat32, ComplexFloat64
from gpu.host._amdgpu_hip import hipStream_t

from .types import (
    Algorithm,
    DataType,
    Diagonal,
    Fill,
    GEAMExOp,
    Handle,
    MallocBase,
    Operation,
    Side,
    Status,
)
from .utils import _get_dylib_function


fn rocblas_create_handle(handle: UnsafePointer[Handle]) -> Status:
    return _get_dylib_function[
        "rocblas_create_handle",
        fn (UnsafePointer[Handle]) -> Status,
    ]()(handle)


fn rocblas_destroy_handle(handle: Handle) -> Status:
    return _get_dylib_function[
        "rocblas_destroy_handle",
        fn (Handle) -> Status,
    ]()(handle)


fn rocblas_ctpsv_64(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int64,
    _ap: UnsafePointer[ComplexFloat32],
    x: UnsafePointer[ComplexFloat32],
    incx: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_ctpsv_64",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int64,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int64,
        ) -> Status,
    ]()(handle, uplo, trans_a, diag, n, _ap, x, incx)


fn rocblas_ctbsv_strided_batched(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int32,
    k: Int32,
    _a: UnsafePointer[ComplexFloat32],
    lda: Int32,
    stride__a: Int64,
    x: UnsafePointer[ComplexFloat32],
    incx: Int32,
    stride_x: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_ctbsv_strided_batched",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        uplo,
        trans_a,
        diag,
        n,
        k,
        _a,
        lda,
        stride__a,
        x,
        incx,
        stride_x,
        batch_count,
    )


fn rocblas_sdgmm_strided_batched(
    handle: Handle,
    side: Side,
    m: Int32,
    n: Int32,
    _a: UnsafePointer[Float32],
    lda: Int32,
    stride__a: Int64,
    x: UnsafePointer[Float32],
    incx: Int32,
    stride_x: Int64,
    _c: UnsafePointer[Float32],
    ldc: Int32,
    stride__c: Int64,
    batch_count: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 3 API </b>.

    \\details
    dgmm_strided_batched performs one of the batched matrix-matrix operations:

        C_i = A_i * diag(x_i)   if side == rocblas_side_right   for i = 0, 1, ... batch_count-1
        C_i = diag(x_i) * A_i   if side == rocblas_side_left    for i = 0, 1, ... batch_count-1,

        where C_i and A_i are m by n dimensional matrices. diag(x_i) is a diagonal matrix
        and x_i is vector of dimension n if side == rocblas_side_right and dimension m
        if side == rocblas_side_left.

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    side      [rocblas_side]
              specifies the side of diag(x).
    @param[in]
    m         [rocblas_int]
              matrix dimension m.
    @param[in]
    n         [rocblas_int]
              matrix dimension n.
    @param[in]
    A         device pointer to the first matrix A_0 on the GPU.
              Each A_i is of dimension ( lda, n ).
    @param[in]
    lda       [rocblas_int]
              specifies the leading dimension of A.
    @param[in]
    stride_A  [rocblas_stride]
              stride from the start of one matrix (A_i) and the next one (A_i+1).
    @param[in]
    x         pointer to the first vector x_0 on the GPU.
              Each x_i is of dimension n if side == rocblas_side_right and dimension
              m if side == rocblas_side_left.
    @param[in]
    incx      [rocblas_int]
              specifies the increment between values of x.
    @param[in]
    stride_x  [rocblas_stride]
              stride from the start of one vector(x_i) and the next one (x_i+1).
    @param[in, out]
    C         device pointer to the first matrix C_0 on the GPU.
              Each C_i is of dimension ( ldc, n ).
    @param[in]
    ldc       [rocblas_int]
              specifies the leading dimension of C.
    @param[in]
    stride_C  [rocblas_stride]
              stride from the start of one matrix (C_i) and the next one (C_i+1).
    @param[in]
    batch_count [rocblas_int]
                number of instances i in the batch.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_sdgmm_strided_batched",
        fn (
            Handle,
            Side,
            Int32,
            Int32,
            UnsafePointer[Float32],
            Int32,
            Int64,
            UnsafePointer[Float32],
            Int32,
            Int64,
            UnsafePointer[Float32],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        side,
        m,
        n,
        _a,
        lda,
        stride__a,
        x,
        incx,
        stride_x,
        _c,
        ldc,
        stride__c,
        batch_count,
    )


fn rocblas_dtbsv_strided_batched(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int32,
    k: Int32,
    _a: UnsafePointer[Float64],
    lda: Int32,
    stride__a: Int64,
    x: UnsafePointer[Float64],
    incx: Int32,
    stride_x: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_dtbsv_strided_batched",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int32,
            Int32,
            UnsafePointer[Float64],
            Int32,
            Int64,
            UnsafePointer[Float64],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        uplo,
        trans_a,
        diag,
        n,
        k,
        _a,
        lda,
        stride__a,
        x,
        incx,
        stride_x,
        batch_count,
    )


fn rocblas_chbmv(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    k: Int32,
    alpha: UnsafePointer[ComplexFloat32],
    _a: UnsafePointer[ComplexFloat32],
    lda: Int32,
    x: UnsafePointer[ComplexFloat32],
    incx: Int32,
    beta: UnsafePointer[ComplexFloat32],
    y: UnsafePointer[ComplexFloat32],
    incy: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 2 API </b>.

    \\details
    hbmv performs the matrix-vector operations:

        y := alpha*A*x + beta*y
        where alpha and beta are scalars, x and y are n element vectors and A is an
        n by n Hermitian band matrix, with k super-diagonals.

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    uplo      [rocblas_fill]
            - rocblas_fill_upper: The upper triangular part of A is being supplied.
            - rocblas_fill_lower: The lower triangular part of A is being supplied.
    @param[in]
    n         [rocblas_int]
              the order of the matrix A.
    @param[in]
    k         [rocblas_int]
              the number of super-diagonals of the matrix A. Must be >= 0.
    @param[in]
    alpha     device pointer or host pointer to scalar alpha.
    @param[in]
    A         device pointer storing matrix A. Of dimension (lda, n).

            if uplo == rocblas_fill_upper:
                The leading (k + 1) by n part of A must contain the upper
                triangular band part of the Hermitian matrix, with the leading
                diagonal in row (k + 1), the first super-diagonal on the RHS
                of row k, etc.
                The top left k by x triangle of A will not be referenced.
                    Ex (upper, lda = n = 4, k = 1):
                    A                             Represented matrix
                    (0,0) (5,9) (6,8) (7,7)       (1, 0) (5, 9) (0, 0) (0, 0)
                    (1,0) (2,0) (3,0) (4,0)       (5,-9) (2, 0) (6, 8) (0, 0)
                    (0,0) (0,0) (0,0) (0,0)       (0, 0) (6,-8) (3, 0) (7, 7)
                    (0,0) (0,0) (0,0) (0,0)       (0, 0) (0, 0) (7,-7) (4, 0)

            if uplo == rocblas_fill_lower:
                The leading (k + 1) by n part of A must contain the lower
                triangular band part of the Hermitian matrix, with the leading
                diagonal in row (1), the first sub-diagonal on the LHS of
                row 2, etc.
                The bottom right k by k triangle of A will not be referenced.
                    Ex (lower, lda = 2, n = 4, k = 1):
                    A                               Represented matrix
                    (1,0) (2,0) (3,0) (4,0)         (1, 0) (5,-9) (0, 0) (0, 0)
                    (5,9) (6,8) (7,7) (0,0)         (5, 9) (2, 0) (6,-8) (0, 0)
                                                    (0, 0) (6, 8) (3, 0) (7,-7)
                                                    (0, 0) (0, 0) (7, 7) (4, 0)

              As a Hermitian matrix, the imaginary part of the main diagonal
              of A will not be referenced and is assumed to be == 0.
    @param[in]
    lda       [rocblas_int]
              specifies the leading dimension of A. must be >= k + 1.
    @param[in]
    x         device pointer storing vector x.
    @param[in]
    incx      [rocblas_int]
              specifies the increment for the elements of x.
    @param[in]
    beta      device pointer or host pointer to scalar beta.
    @param[in, out]
    y         device pointer storing vector y.
    @param[in]
    incy      [rocblas_int]
              specifies the increment for the elements of y.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_chbmv",
        fn (
            Handle,
            Fill,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int32,
            UnsafePointer[ComplexFloat32],
            Int32,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int32,
        ) -> Status,
    ]()(handle, uplo, n, k, alpha, _a, lda, x, incx, beta, y, incy)


fn rocblas_ctpmv_batched(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int32,
    _a: UnsafePointer[UnsafePointer[ComplexFloat32]],
    x: UnsafePointer[UnsafePointer[ComplexFloat32]],
    incx: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_ctpmv_batched",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int32,
            UnsafePointer[UnsafePointer[ComplexFloat32]],
            UnsafePointer[UnsafePointer[ComplexFloat32]],
            Int32,
            Int32,
        ) -> Status,
    ]()(handle, uplo, trans_a, diag, n, _a, x, incx, batch_count)


fn rocblas_ctrtri_strided_batched(
    handle: Handle,
    uplo: Fill,
    diag: Diagonal,
    n: Int32,
    _a: UnsafePointer[ComplexFloat32],
    lda: Int32,
    stride_a: Int64,
    inv_a: UnsafePointer[ComplexFloat32],
    ldinv_a: Int32,
    stride_inv_a: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_ctrtri_strided_batched",
        fn (
            Handle,
            Fill,
            Diagonal,
            Int32,
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        uplo,
        diag,
        n,
        _a,
        lda,
        stride_a,
        inv_a,
        ldinv_a,
        stride_inv_a,
        batch_count,
    )


fn rocblas_cher_batched(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    alpha: UnsafePointer[Float32],
    x: OpaquePointer,
    incx: Int32,
    _a: OpaquePointer,
    lda: Int32,
    batch_count: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 2 API </b>.

    \\details
    her_batched performs the matrix-vector operations:

        A_i := A_i + alpha*x_i*x_i**H
        where alpha is a real scalar, x_i is a vector, and A_i is an
        n by n symmetric matrix, for i = 1, ..., batch_count.

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    uplo      [rocblas_fill]
            specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
            - rocblas_fill_upper: The upper triangular part of each A_i is supplied in A.
            - rocblas_fill_lower: The lower triangular part of each A_i is supplied in A.
    @param[in]
    n         [rocblas_int]
              the number of rows and columns of each matrix A_i. Must be at least 0.
    @param[in]
    alpha
              device pointer or host pointer to scalar alpha.
    @param[in]
    x         device array of device pointers storing each vector x_i.
    @param[in]
    incx      [rocblas_int]
              specifies the increment for the elements of each x_i.
    @param[in, out]
    A         device array of device pointers storing the specified triangular portion of
    each Hermitian matrix A_i of at least size ((n * (n + 1)) / 2). Array is of at least size batch_count.

                if uplo == rocblas_fill_upper:
                    The upper triangular portion of each Hermitian matrix A_i is supplied.
                    The lower triangular portion of each A_i will not be touched.
                if uplo == rocblas_fill_lower:
                    The lower triangular portion of each Hermitian matrix A_i is supplied.
                    The upper triangular portion of each A_i will not be touched.
                Note that the imaginary part of the diagonal elements are not accessed
                and are assumed to be 0.

    @param[in]
    lda       [rocblas_int]
              specifies the leading dimension of each A_i. Must be at least max(1, n).
    @param[in]
    batch_count [rocblas_int]
                number of instances in the batch.
    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_cher_batched",
        fn (
            Handle,
            Fill,
            Int32,
            UnsafePointer[Float32],
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(handle, uplo, n, alpha, x, incx, _a, lda, batch_count)


fn rocblas_bfdot_64(
    handle: Handle,
    n: Int64,
    x: UnsafePointer[BFloat16],
    incx: Int64,
    y: UnsafePointer[BFloat16],
    incy: Int64,
    result: UnsafePointer[BFloat16],
) -> Status:
    return _get_dylib_function[
        "rocblas_bfdot_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[BFloat16],
            Int64,
            UnsafePointer[BFloat16],
            Int64,
            UnsafePointer[BFloat16],
        ) -> Status,
    ]()(handle, n, x, incx, y, incy, result)


fn rocblas_tstgemv_batched(
    handle: Handle,
    trans: Operation,
    m: Int32,
    n: Int32,
    alpha: UnsafePointer[Float32],
    _a: OpaquePointer,
    lda: Int32,
    x: OpaquePointer,
    incx: Int32,
    beta: UnsafePointer[Float32],
    y: OpaquePointer,
    incy: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_tstgemv_batched",
        fn (
            Handle,
            Operation,
            Int32,
            Int32,
            UnsafePointer[Float32],
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            UnsafePointer[Float32],
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(
        handle, trans, m, n, alpha, _a, lda, x, incx, beta, y, incy, batch_count
    )


fn rocblas_sdot(
    handle: Handle,
    n: Int32,
    x: UnsafePointer[Float32],
    incx: Int32,
    y: UnsafePointer[Float32],
    incy: Int32,
    result: UnsafePointer[Float32],
) -> Status:
    """
    \\brief <b> BLAS Level 1 API </b>.

    \\details
    dot(u)  performs the dot product of vectors x and y:

        result = x * y;

    dotc  performs the dot product of the conjugate of complex vector x and complex vector y.

        result = conjugate (x) * y;

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    n         [rocblas_int]
              the number of elements in x and y.
    @param[in]
    x         device pointer storing vector x.
    @param[in]
    incx      [rocblas_int]
              specifies the increment for the elements of y.
    @param[in]
    y         device pointer storing vector y.
    @param[in]
    incy      [rocblas_int]
              specifies the increment for the elements of y.
    @param[in, out]
    result
              device pointer or host pointer to store the dot product.
              return is 0.0 if n <= 0.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_sdot",
        fn (
            Handle,
            Int32,
            UnsafePointer[Float32],
            Int32,
            UnsafePointer[Float32],
            Int32,
            UnsafePointer[Float32],
        ) -> Status,
    ]()(handle, n, x, incx, y, incy, result)


fn rocblas_zgbmv_64(
    handle: Handle,
    trans: Operation,
    m: Int64,
    n: Int64,
    kl: Int64,
    ku: Int64,
    alpha: UnsafePointer[ComplexFloat64],
    _a: UnsafePointer[ComplexFloat64],
    lda: Int64,
    x: UnsafePointer[ComplexFloat64],
    incx: Int64,
    beta: UnsafePointer[ComplexFloat64],
    y: UnsafePointer[ComplexFloat64],
    incy: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_zgbmv_64",
        fn (
            Handle,
            Operation,
            Int64,
            Int64,
            Int64,
            Int64,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int64,
            UnsafePointer[ComplexFloat64],
            Int64,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int64,
        ) -> Status,
    ]()(handle, trans, m, n, kl, ku, alpha, _a, lda, x, incx, beta, y, incy)


fn rocblas_sscal_strided_batched(
    handle: Handle,
    n: Int32,
    alpha: UnsafePointer[Float32],
    x: UnsafePointer[Float32],
    incx: Int32,
    stride_x: Int64,
    batch_count: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 1 API </b>.

    \\details
    scal_strided_batched  scales each element of vector x_i with scalar alpha, for i = 1, ... , batch_count:

        x_i := alpha * x_i,
        where (x_i) is the i-th instance of the batch.

     @param[in]
    handle      [rocblas_handle]
                handle to the rocblas library context queue.
    @param[in]
    n           [rocblas_int]
                the number of elements in each x_i.
    @param[in]
    alpha       host pointer or device pointer for the scalar alpha.
    @param[in, out]
    x           device pointer to the first vector (x_1) in the batch.
    @param[in]
    incx        [rocblas_int]
                specifies the increment for the elements of x.
    @param[in]
    stride_x    [rocblas_stride]
                stride from the start of one vector (x_i) and the next one (x_i+1).
                There are no restrictions placed on stride_x. However, ensure that stride_x is of appropriate size, for a typical
                case this means stride_x >= n * incx.
    @param[in]
    batch_count [rocblas_int]
                specifies the number of batches in x.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_sscal_strided_batched",
        fn (
            Handle,
            Int32,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(handle, n, alpha, x, incx, stride_x, batch_count)


fn rocblas_srotm_strided_batched(
    handle: Handle,
    n: Int32,
    x: UnsafePointer[Float32],
    incx: Int32,
    stride_x: Int64,
    y: UnsafePointer[Float32],
    incy: Int32,
    stride_y: Int64,
    param: UnsafePointer[Float32],
    stride_param: Int64,
    batch_count: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 1 API </b>.

    \\details
    rotm_strided_batched applies the modified Givens rotation matrix defined by param_i to strided batched vectors x_i and y_i, for i = 1, ..., batch_count

    @param[in]
    handle  [rocblas_handle]
            handle to the rocblas library context queue.
    @param[in]
    n       [rocblas_int]
            number of elements in the x and y vectors.
    @param[in, out]
    x       device pointer pointing to first strided batched vector x_1.
    @param[in]
    incx    [rocblas_int]
            specifies the increment between elements of each x_i.
    @param[in]
    stride_x [rocblas_stride]
             specifies the increment between the beginning of x_i and x_(i + 1)
    @param[in, out]
    y       device pointer pointing to first strided batched vector y_1.
    @param[in]
    incy    [rocblas_int]
            specifies the increment between elements of each y_i.
    @param[in]
    stride_y [rocblas_stride]
             specifies the increment between the beginning of y_i and y_(i + 1).
    @param[in]
    param   device pointer pointing to first array of 5 elements defining the rotation (param_1).

        param[0] = flag
        param[1] = H11
        param[2] = H21
        param[3] = H12
        param[4] = H22

        The flag parameter defines the form of H:

        flag = -1 => H = ( H11 H12 H21 H22 )
        flag =  0 => H = ( 1.0 H12 H21 1.0 )
        flag =  1 => H = ( H11 1.0 -1.0 H22 )
        flag = -2 => H = ( 1.0 0.0 0.0 1.0 )

        param may ONLY be stored on the device for the strided_batched
        version of this function.

    @param[in]
    stride_param [rocblas_stride]
                 specifies the increment between the beginning of param_i and param_(i + 1).
    @param[in]
    batch_count [rocblas_int]
                the number of x and y arrays, i.e. the number of batches.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_srotm_strided_batched",
        fn (
            Handle,
            Int32,
            UnsafePointer[Float32],
            Int32,
            Int64,
            UnsafePointer[Float32],
            Int32,
            Int64,
            UnsafePointer[Float32],
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        n,
        x,
        incx,
        stride_x,
        y,
        incy,
        stride_y,
        param,
        stride_param,
        batch_count,
    )


fn rocblas_csyr2k_batched(
    handle: Handle,
    uplo: Fill,
    trans: Operation,
    n: Int32,
    k: Int32,
    alpha: UnsafePointer[ComplexFloat32],
    _a: OpaquePointer,
    lda: Int32,
    _b: OpaquePointer,
    ldb: Int32,
    beta: UnsafePointer[ComplexFloat32],
    _c: OpaquePointer,
    ldc: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_csyr2k_batched",
        fn (
            Handle,
            Fill,
            Operation,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat32],
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            UnsafePointer[ComplexFloat32],
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(
        handle,
        uplo,
        trans,
        n,
        k,
        alpha,
        _a,
        lda,
        _b,
        ldb,
        beta,
        _c,
        ldc,
        batch_count,
    )


fn rocblas_scopy_batched_64(
    handle: Handle,
    n: Int64,
    x: OpaquePointer,
    incx: Int64,
    y: OpaquePointer,
    incy: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_scopy_batched_64",
        fn (
            Handle,
            Int64,
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, n, x, incx, y, incy, batch_count)


fn rocblas_dsyr_batched_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    alpha: UnsafePointer[Float64],
    x: OpaquePointer,
    incx: Int64,
    _a: OpaquePointer,
    lda: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_dsyr_batched_64",
        fn (
            Handle,
            Fill,
            Int64,
            UnsafePointer[Float64],
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, uplo, n, alpha, x, incx, _a, lda, batch_count)


fn rocblas_stbmv_strided_batched_64(
    handle: Handle,
    uplo: Fill,
    trans: Operation,
    diag: Diagonal,
    n: Int64,
    k: Int64,
    _a: UnsafePointer[Float32],
    lda: Int64,
    stride__a: Int64,
    x: UnsafePointer[Float32],
    incx: Int64,
    stride_x: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_stbmv_strided_batched_64",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int64,
            Int64,
            UnsafePointer[Float32],
            Int64,
            Int64,
            UnsafePointer[Float32],
            Int64,
            Int64,
            Int64,
        ) -> Status,
    ]()(
        handle,
        uplo,
        trans,
        diag,
        n,
        k,
        _a,
        lda,
        stride__a,
        x,
        incx,
        stride_x,
        batch_count,
    )


fn rocblas_dsyr2_strided_batched_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    alpha: UnsafePointer[Float64],
    x: UnsafePointer[Float64],
    incx: Int64,
    stridex: Int64,
    y: UnsafePointer[Float64],
    incy: Int64,
    stridey: Int64,
    _a: UnsafePointer[Float64],
    lda: Int64,
    stride_a: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_dsyr2_strided_batched_64",
        fn (
            Handle,
            Fill,
            Int64,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int64,
            Int64,
            UnsafePointer[Float64],
            Int64,
            Int64,
            UnsafePointer[Float64],
            Int64,
            Int64,
            Int64,
        ) -> Status,
    ]()(
        handle,
        uplo,
        n,
        alpha,
        x,
        incx,
        stridex,
        y,
        incy,
        stridey,
        _a,
        lda,
        stride_a,
        batch_count,
    )


fn rocblas_ssyr_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    alpha: UnsafePointer[Float32],
    x: UnsafePointer[Float32],
    incx: Int64,
    _a: UnsafePointer[Float32],
    lda: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_ssyr_64",
        fn (
            Handle,
            Fill,
            Int64,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int64,
            UnsafePointer[Float32],
            Int64,
        ) -> Status,
    ]()(handle, uplo, n, alpha, x, incx, _a, lda)


fn rocblas_zdotu(
    handle: Handle,
    n: Int32,
    x: UnsafePointer[ComplexFloat64],
    incx: Int32,
    y: UnsafePointer[ComplexFloat64],
    incy: Int32,
    result: UnsafePointer[ComplexFloat64],
) -> Status:
    return _get_dylib_function[
        "rocblas_zdotu",
        fn (
            Handle,
            Int32,
            UnsafePointer[ComplexFloat64],
            Int32,
            UnsafePointer[ComplexFloat64],
            Int32,
            UnsafePointer[ComplexFloat64],
        ) -> Status,
    ]()(handle, n, x, incx, y, incy, result)


fn rocblas_nrm2_batched_ex(
    handle: Handle,
    n: Int32,
    x: OpaquePointer,
    x_type: DataType,
    incx: Int32,
    batch_count: Int32,
    results: OpaquePointer,
    result_type: DataType,
    execution_type: DataType,
) -> Status:
    """
    \\brief BLAS_EX API.

    \\details
    nrm2_batched_ex computes the euclidean norm over a batch of real or complex vectors.

              result := sqrt( x_i'*x_i ) for real vectors x, for i = 1, ..., batch_count
              result := sqrt( x_i**H*x_i ) for complex vectors x, for i = 1, ..., batch_count

    Currently supported datatypes are as follows:

    -------------------------------------
    |  x_type | result | execution_type |
    |---------|--------|----------------|
    |  bf16_r |  bf16_r|     f32_r      |
    |  f16_r  |  f16_r |     f32_r      |
    |  f32_r  |  f32_r |     f32_r      |
    |  f64_r  |  f64_r |     f64_r      |
    |  f32_c  |  f32_r |     f32_r      |
    |  f64_c  |  f64_r |     f64_r      |
    -------------------------------------

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    n         [rocblas_int]
              number of elements in each x_i.
    @param[in]
    x         device array of device pointers storing each vector x_i.
    @param[in]
    x_type [rocblas_datatype]
           specifies the datatype of each vector x_i.
    @param[in]
    incx      [rocblas_int]
              specifies the increment for the elements of each x_i. incx must be > 0.
    @param[in]
    batch_count [rocblas_int]
              number of instances in the batch.
    @param[out]
    results
              device pointer or host pointer to array of batch_count size for nrm2 results.
              return is 0.0 for each element if n <= 0, incx<=0.
    @param[in]
    result_type [rocblas_datatype]
                specifies the datatype of the result.
    @param[in]
    execution_type [rocblas_datatype]
                  specifies the datatype of computation.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_nrm2_batched_ex",
        fn (
            Handle,
            Int32,
            OpaquePointer,
            DataType,
            Int32,
            Int32,
            OpaquePointer,
            DataType,
            DataType,
        ) -> Status,
    ]()(
        handle,
        n,
        x,
        x_type,
        incx,
        batch_count,
        results,
        result_type,
        execution_type,
    )


fn rocblas_cdgmm_batched(
    handle: Handle,
    side: Side,
    m: Int32,
    n: Int32,
    _a: OpaquePointer,
    lda: Int32,
    x: OpaquePointer,
    incx: Int32,
    _c: OpaquePointer,
    ldc: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_cdgmm_batched",
        fn (
            Handle,
            Side,
            Int32,
            Int32,
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(handle, side, m, n, _a, lda, x, incx, _c, ldc, batch_count)


fn rocblas_dotc_ex(
    handle: Handle,
    n: Int32,
    x: OpaquePointer,
    x_type: DataType,
    incx: Int32,
    y: OpaquePointer,
    y_type: DataType,
    incy: Int32,
    result: OpaquePointer,
    result_type: DataType,
    execution_type: DataType,
) -> Status:
    return _get_dylib_function[
        "rocblas_dotc_ex",
        fn (
            Handle,
            Int32,
            OpaquePointer,
            DataType,
            Int32,
            OpaquePointer,
            DataType,
            Int32,
            OpaquePointer,
            DataType,
            DataType,
        ) -> Status,
    ]()(
        handle,
        n,
        x,
        x_type,
        incx,
        y,
        y_type,
        incy,
        result,
        result_type,
        execution_type,
    )


fn rocblas_csyr2k_strided_batched(
    handle: Handle,
    uplo: Fill,
    trans: Operation,
    n: Int32,
    k: Int32,
    alpha: UnsafePointer[ComplexFloat32],
    _a: UnsafePointer[ComplexFloat32],
    lda: Int32,
    stride__a: Int64,
    _b: UnsafePointer[ComplexFloat32],
    ldb: Int32,
    stride__b: Int64,
    beta: UnsafePointer[ComplexFloat32],
    _c: UnsafePointer[ComplexFloat32],
    ldc: Int32,
    stride__c: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_csyr2k_strided_batched",
        fn (
            Handle,
            Fill,
            Operation,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        uplo,
        trans,
        n,
        k,
        alpha,
        _a,
        lda,
        stride__a,
        _b,
        ldb,
        stride__b,
        beta,
        _c,
        ldc,
        stride__c,
        batch_count,
    )


fn rocblas_hdot_strided_batched_64(
    handle: Handle,
    n: Int64,
    x: UnsafePointer[Float16],
    incx: Int64,
    stridex: Int64,
    y: UnsafePointer[Float16],
    incy: Int64,
    stridey: Int64,
    batch_count: Int64,
    result: UnsafePointer[Float16],
) -> Status:
    return _get_dylib_function[
        "rocblas_hdot_strided_batched_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[Float16],
            Int64,
            Int64,
            UnsafePointer[Float16],
            Int64,
            Int64,
            Int64,
            UnsafePointer[Float16],
        ) -> Status,
    ]()(handle, n, x, incx, stridex, y, incy, stridey, batch_count, result)


fn rocblas_zrot_batched_64(
    handle: Handle,
    n: Int64,
    x: OpaquePointer,
    incx: Int64,
    y: OpaquePointer,
    incy: Int64,
    c: UnsafePointer[Float64],
    s: UnsafePointer[ComplexFloat64],
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_zrot_batched_64",
        fn (
            Handle,
            Int64,
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            UnsafePointer[Float64],
            UnsafePointer[ComplexFloat64],
            Int64,
        ) -> Status,
    ]()(handle, n, x, incx, y, incy, c, s, batch_count)


fn rocblas_srotmg_batched_64(
    handle: Handle,
    d1: OpaquePointer,
    d2: OpaquePointer,
    x1: OpaquePointer,
    y1: OpaquePointer,
    param: OpaquePointer,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_srotmg_batched_64",
        fn (
            Handle,
            OpaquePointer,
            OpaquePointer,
            OpaquePointer,
            OpaquePointer,
            OpaquePointer,
            Int64,
        ) -> Status,
    ]()(handle, d1, d2, x1, y1, param, batch_count)


fn rocblas_strsm_64(
    handle: Handle,
    side: Side,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    m: Int64,
    n: Int64,
    alpha: UnsafePointer[Float32],
    _a: UnsafePointer[Float32],
    lda: Int64,
    _b: UnsafePointer[Float32],
    ldb: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_strsm_64",
        fn (
            Handle,
            Side,
            Fill,
            Operation,
            Diagonal,
            Int64,
            Int64,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int64,
            UnsafePointer[Float32],
            Int64,
        ) -> Status,
    ]()(handle, side, uplo, trans_a, diag, m, n, alpha, _a, lda, _b, ldb)


fn rocblas_dzasum_batched_64(
    handle: Handle,
    n: Int64,
    x: OpaquePointer,
    incx: Int64,
    batch_count: Int64,
    results: UnsafePointer[Float64],
) -> Status:
    return _get_dylib_function[
        "rocblas_dzasum_batched_64",
        fn (
            Handle,
            Int64,
            OpaquePointer,
            Int64,
            Int64,
            UnsafePointer[Float64],
        ) -> Status,
    ]()(handle, n, x, incx, batch_count, results)


fn rocblas_snrm2(
    handle: Handle,
    n: Int32,
    x: UnsafePointer[Float32],
    incx: Int32,
    result: UnsafePointer[Float32],
) -> Status:
    """
    \\brief <b> BLAS Level 1 API </b>.

    \\details
    nrm2 computes the euclidean norm of a real or complex vector:

        result := sqrt( x'*x ) for real vectors
        result := sqrt( x**H*x ) for complex vectors

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    n         [rocblas_int]
              the number of elements in x.
    @param[in]
    x         device pointer storing vector x.
    @param[in]
    incx      [rocblas_int]
              specifies the increment for the elements of y.
    @param[in, out]
    result
              device pointer or host pointer to store the nrm2 product.
              return is 0.0 if n, incx<=0.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_snrm2",
        fn (
            Handle, Int32, UnsafePointer[Float32], Int32, UnsafePointer[Float32]
        ) -> Status,
    ]()(handle, n, x, incx, result)


fn rocblas_dsyrk_strided_batched(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    n: Int32,
    k: Int32,
    alpha: UnsafePointer[Float64],
    _a: UnsafePointer[Float64],
    lda: Int32,
    stride__a: Int64,
    beta: UnsafePointer[Float64],
    _c: UnsafePointer[Float64],
    ldc: Int32,
    stride__c: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_dsyrk_strided_batched",
        fn (
            Handle,
            Fill,
            Operation,
            Int32,
            Int32,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int32,
            Int64,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        uplo,
        trans_a,
        n,
        k,
        alpha,
        _a,
        lda,
        stride__a,
        beta,
        _c,
        ldc,
        stride__c,
        batch_count,
    )


fn rocblas_dtrsm_batched_64(
    handle: Handle,
    side: Side,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    m: Int64,
    n: Int64,
    alpha: UnsafePointer[Float64],
    _a: OpaquePointer,
    lda: Int64,
    _b: OpaquePointer,
    ldb: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_dtrsm_batched_64",
        fn (
            Handle,
            Side,
            Fill,
            Operation,
            Diagonal,
            Int64,
            Int64,
            UnsafePointer[Float64],
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            Int64,
        ) -> Status,
    ]()(
        handle,
        side,
        uplo,
        trans_a,
        diag,
        m,
        n,
        alpha,
        _a,
        lda,
        _b,
        ldb,
        batch_count,
    )


fn rocblas_zscal_strided_batched_64(
    handle: Handle,
    n: Int64,
    alpha: UnsafePointer[ComplexFloat64],
    x: UnsafePointer[ComplexFloat64],
    incx: Int64,
    stride_x: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_zscal_strided_batched_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int64,
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, n, alpha, x, incx, stride_x, batch_count)


fn rocblas_cher_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    alpha: UnsafePointer[Float32],
    x: UnsafePointer[ComplexFloat32],
    incx: Int64,
    _a: UnsafePointer[ComplexFloat32],
    lda: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_cher_64",
        fn (
            Handle,
            Fill,
            Int64,
            UnsafePointer[Float32],
            UnsafePointer[ComplexFloat32],
            Int64,
            UnsafePointer[ComplexFloat32],
            Int64,
        ) -> Status,
    ]()(handle, uplo, n, alpha, x, incx, _a, lda)


fn rocblas_cdotu(
    handle: Handle,
    n: Int32,
    x: UnsafePointer[ComplexFloat32],
    incx: Int32,
    y: UnsafePointer[ComplexFloat32],
    incy: Int32,
    result: UnsafePointer[ComplexFloat32],
) -> Status:
    return _get_dylib_function[
        "rocblas_cdotu",
        fn (
            Handle,
            Int32,
            UnsafePointer[ComplexFloat32],
            Int32,
            UnsafePointer[ComplexFloat32],
            Int32,
            UnsafePointer[ComplexFloat32],
        ) -> Status,
    ]()(handle, n, x, incx, y, incy, result)


fn rocblas_sasum_batched(
    handle: Handle,
    n: Int32,
    x: OpaquePointer,
    incx: Int32,
    batch_count: Int32,
    results: UnsafePointer[Float32],
) -> Status:
    """
    \\brief <b> BLAS Level 1 API </b>.

    \\details
    asum_batched computes the sum of the magnitudes of the elements in a batch of real vectors x_i,
    or the sum of magnitudes of the real and imaginary parts of elements if x_i is a complex
    vector, for i = 1, ..., batch_count.

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    n         [rocblas_int]
              number of elements in each vector x_i.
    @param[in]
    x         device array of device pointers storing each vector x_i.
    @param[in]
    incx      [rocblas_int]
              specifies the increment for the elements of each x_i. incx must be > 0.
    @param[in]
    batch_count [rocblas_int]
              number of instances in the batch.
    @param[out]
    results
              device array or host array of batch_count size for results.
              return is 0.0 if n, incx<=0.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_sasum_batched",
        fn (
            Handle,
            Int32,
            OpaquePointer,
            Int32,
            Int32,
            UnsafePointer[Float32],
        ) -> Status,
    ]()(handle, n, x, incx, batch_count, results)


fn rocblas_dtpmv_batched_64(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int64,
    _a: UnsafePointer[UnsafePointer[Float64]],
    x: UnsafePointer[UnsafePointer[Float64]],
    incx: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_dtpmv_batched_64",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int64,
            UnsafePointer[UnsafePointer[Float64]],
            UnsafePointer[UnsafePointer[Float64]],
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, uplo, trans_a, diag, n, _a, x, incx, batch_count)


fn rocblas_dtbmv_strided_batched(
    handle: Handle,
    uplo: Fill,
    trans: Operation,
    diag: Diagonal,
    n: Int32,
    k: Int32,
    _a: UnsafePointer[Float64],
    lda: Int32,
    stride__a: Int64,
    x: UnsafePointer[Float64],
    incx: Int32,
    stride_x: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_dtbmv_strided_batched",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int32,
            Int32,
            UnsafePointer[Float64],
            Int32,
            Int64,
            UnsafePointer[Float64],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        uplo,
        trans,
        diag,
        n,
        k,
        _a,
        lda,
        stride__a,
        x,
        incx,
        stride_x,
        batch_count,
    )


fn rocblas_sspr_batched(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    alpha: UnsafePointer[Float32],
    x: OpaquePointer,
    incx: Int32,
    _ap: OpaquePointer,
    batch_count: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 2 API </b>.

    \\details
    spr_batched performs the matrix-vector operations:

        A_i := A_i + alpha*x_i*x_i**T
        where alpha is a scalar, x_i is a vector, and A_i is an
        n by n symmetric matrix, supplied in packed form, for i = 1, ..., batch_count.

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    uplo      [rocblas_fill]
            specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
            - rocblas_fill_upper: The upper triangular part of each A_i is supplied in AP.
            - rocblas_fill_lower: The lower triangular part of each A_i is supplied in AP.
    @param[in]
    n         [rocblas_int]
            the number of rows and columns of each matrix A_i. Must be at least 0.
    @param[in]
    alpha
              device pointer or host pointer to scalar alpha.
    @param[in]
    x         device array of device pointers storing each vector x_i.
    @param[in]
    incx      [rocblas_int]
              specifies the increment for the elements of each x_i.
    @param[in, out]
    AP        device array of device pointers storing the packed version of the specified triangular portion of
              each symmetric matrix A_i of at least size ((n * (n + 1)) / 2). Array is of at least size batch_count.

                    if uplo == rocblas_fill_upper:
                        The upper triangular portion of each symmetric matrix A_i is supplied.
                        The matrix is compacted so that AP contains the triangular portion
                        column-by-column
                        so that:
                        AP(0) = A(0,0)
                        AP(1) = A(0,1)
                        AP(2) = A(1,1), etc.
                            Ex: (rocblas_fill_upper; n = 4)
                                1 2 4 7
                                2 3 5 8   -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
                                4 5 6 9
                                7 8 9 0

                    if uplo == rocblas_fill_lower:
                        The lower triangular portion of each symmetric matrix A_i is supplied.
                        The matrix is compacted so that AP contains the triangular portion
                        column-by-column
                        so that:
                        AP(0) = A(0,0)
                        AP(1) = A(1,0)
                        AP(2) = A(2,1), etc.
                            Ex: (rocblas_fill_lower; n = 4)
                                1 2 3 4
                                2 5 6 7    -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
                                3 6 8 9
                                4 7 9 0
    @param[in]
    batch_count [rocblas_int]
                number of instances in the batch.
    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_sspr_batched",
        fn (
            Handle,
            Fill,
            Int32,
            UnsafePointer[Float32],
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
        ) -> Status,
    ]()(handle, uplo, n, alpha, x, incx, _ap, batch_count)


fn rocblas_ztbsv_strided_batched_64(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int64,
    k: Int64,
    _a: UnsafePointer[ComplexFloat64],
    lda: Int64,
    stride__a: Int64,
    x: UnsafePointer[ComplexFloat64],
    incx: Int64,
    stride_x: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_ztbsv_strided_batched_64",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int64,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int64,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int64,
            Int64,
            Int64,
        ) -> Status,
    ]()(
        handle,
        uplo,
        trans_a,
        diag,
        n,
        k,
        _a,
        lda,
        stride__a,
        x,
        incx,
        stride_x,
        batch_count,
    )


fn rocblas_cher2_strided_batched(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat32],
    x: UnsafePointer[ComplexFloat32],
    incx: Int32,
    stride_x: Int64,
    y: UnsafePointer[ComplexFloat32],
    incy: Int32,
    stride_y: Int64,
    _a: UnsafePointer[ComplexFloat32],
    lda: Int32,
    stride__a: Int64,
    batch_count: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 2 API </b>.

    \\details
    her2_strided_batched performs the matrix-vector operations:

        A_i := A_i + alpha*x_i*y_i**H + conj(alpha)*y_i*x_i**H
        where alpha is a complex scalar, x_i and y_i are vectors, and A_i is an
        n by n Hermitian matrix for each batch in i = [1, batch_count].

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    uplo      [rocblas_fill]
            specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
            - rocblas_fill_upper: The upper triangular part of each A_i is supplied.
            - rocblas_fill_lower: The lower triangular part of each A_i is supplied.
    @param[in]
    n         [rocblas_int]
              the number of rows and columns of each matrix A_i. Must be at least 0.
    @param[in]
    alpha
              device pointer or host pointer to scalar alpha.
    @param[in]
    x         device pointer pointing to the first vector x_1.
    @param[in]
    incx      [rocblas_int]
              specifies the increment for the elements of each x_i.
    @param[in]
    stride_x  [rocblas_stride]
              specifies the stride between the beginning of one vector (x_i) and the next (x_i+1).
    @param[in]
    y         device pointer pointing to the first vector y_i.
    @param[in]
    incy      [rocblas_int]
              specifies the increment for the elements of each y_i.
    @param[in]
    stride_y  [rocblas_stride]
              specifies the stride between the beginning of one vector (y_i) and the next (y_i+1).
    @param[in, out]
    A         device pointer pointing to the first matrix (A_1). Stores the specified triangular portion of
              each Hermitian matrix A_i.

                    if uplo == rocblas_fill_upper:
                        The upper triangular portion of each Hermitian matrix A_i is supplied.
                        The lower triangular portion of each A_i will not be touched.

                    if uplo == rocblas_fill_lower:
                        The lower triangular portion of each Hermitian matrix A_i is supplied.
                        The upper triangular portion of each A_i will not be touched.
                Note that the imaginary part of the diagonal elements are not accessed
                and are assumed to be 0.
    @param[in]
    lda       [rocblas_int]
              specifies the leading dimension of each A_i. Must be at least max(lda, 1).
    @param[in]
    stride_A  [rocblas_stride]
              specifies the stride between the beginning of one matrix (A_i) and the next (A_i+1).
    @param[in]
    batch_count [rocblas_int]
                number of instances in the batch.
    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_cher2_strided_batched",
        fn (
            Handle,
            Fill,
            Int32,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        uplo,
        n,
        alpha,
        x,
        incx,
        stride_x,
        y,
        incy,
        stride_y,
        _a,
        lda,
        stride__a,
        batch_count,
    )


fn rocblas_srot_strided_batched_64(
    handle: Handle,
    n: Int64,
    x: UnsafePointer[Float32],
    incx: Int64,
    stride_x: Int64,
    y: UnsafePointer[Float32],
    incy: Int64,
    stride_y: Int64,
    c: UnsafePointer[Float32],
    s: UnsafePointer[Float32],
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_srot_strided_batched_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[Float32],
            Int64,
            Int64,
            UnsafePointer[Float32],
            Int64,
            Int64,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int64,
        ) -> Status,
    ]()(handle, n, x, incx, stride_x, y, incy, stride_y, c, s, batch_count)


fn rocblas_ctrsm_batched(
    handle: Handle,
    side: Side,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    m: Int32,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat32],
    _a: OpaquePointer,
    lda: Int32,
    _b: OpaquePointer,
    ldb: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_ctrsm_batched",
        fn (
            Handle,
            Side,
            Fill,
            Operation,
            Diagonal,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat32],
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(
        handle,
        side,
        uplo,
        trans_a,
        diag,
        m,
        n,
        alpha,
        _a,
        lda,
        _b,
        ldb,
        batch_count,
    )


fn rocblas_sscal(
    handle: Handle,
    n: Int32,
    alpha: UnsafePointer[Float32],
    x: UnsafePointer[Float32],
    incx: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 1 API </b>.

    \\details
    scal  scales each element of vector x with scalar alpha:

        x := alpha * x

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    n         [rocblas_int]
              the number of elements in x.
    @param[in]
    alpha     device pointer or host pointer for the scalar alpha.
    @param[in, out]
    x         device pointer storing vector x.
    @param[in]
    incx      [rocblas_int]
              specifies the increment for the elements of x.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_sscal",
        fn (
            Handle, Int32, UnsafePointer[Float32], UnsafePointer[Float32], Int32
        ) -> Status,
    ]()(handle, n, alpha, x, incx)


fn rocblas_ztbmv_strided_batched(
    handle: Handle,
    uplo: Fill,
    trans: Operation,
    diag: Diagonal,
    n: Int32,
    k: Int32,
    _a: UnsafePointer[ComplexFloat64],
    lda: Int32,
    stride__a: Int64,
    x: UnsafePointer[ComplexFloat64],
    incx: Int32,
    stride_x: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_ztbmv_strided_batched",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        uplo,
        trans,
        diag,
        n,
        k,
        _a,
        lda,
        stride__a,
        x,
        incx,
        stride_x,
        batch_count,
    )


fn rocblas_dswap_strided_batched(
    handle: Handle,
    n: Int32,
    x: UnsafePointer[Float64],
    incx: Int32,
    stridex: Int64,
    y: UnsafePointer[Float64],
    incy: Int32,
    stridey: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_dswap_strided_batched",
        fn (
            Handle,
            Int32,
            UnsafePointer[Float64],
            Int32,
            Int64,
            UnsafePointer[Float64],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(handle, n, x, incx, stridex, y, incy, stridey, batch_count)


fn rocblas_dsymv(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    alpha: UnsafePointer[Float64],
    _a: UnsafePointer[Float64],
    lda: Int32,
    x: UnsafePointer[Float64],
    incx: Int32,
    beta: UnsafePointer[Float64],
    y: UnsafePointer[Float64],
    incy: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_dsymv",
        fn (
            Handle,
            Fill,
            Int32,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int32,
            UnsafePointer[Float64],
            Int32,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int32,
        ) -> Status,
    ]()(handle, uplo, n, alpha, _a, lda, x, incx, beta, y, incy)


fn rocblas_dnrm2_64(
    handle: Handle,
    n: Int64,
    x: UnsafePointer[Float64],
    incx: Int64,
    result: UnsafePointer[Float64],
) -> Status:
    return _get_dylib_function[
        "rocblas_dnrm2_64",
        fn (
            Handle, Int64, UnsafePointer[Float64], Int64, UnsafePointer[Float64]
        ) -> Status,
    ]()(handle, n, x, incx, result)


fn rocblas_ssyrk(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    n: Int32,
    k: Int32,
    alpha: UnsafePointer[Float32],
    _a: UnsafePointer[Float32],
    lda: Int32,
    beta: UnsafePointer[Float32],
    _c: UnsafePointer[Float32],
    ldc: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 3 API </b>.

    \\details
    syrk performs one of the matrix-matrix operations for a symmetric rank-k update:

        C := alpha*op( A )*op( A )^T + beta*C,

        where  alpha and beta are scalars, op(A) is an n by k matrix, and
        C is a symmetric n x n matrix stored as either upper or lower.

        op( A ) = A, and A is n by k if transA == rocblas_operation_none
        op( A ) = A^T and A is k by n if transA == rocblas_operation_transpose

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.

    @param[in]
    uplo    [rocblas_fill]
            - rocblas_fill_upper:  C is an upper triangular matrix
            - rocblas_fill_lower:  C is a  lower triangular matrix

    @param[in]
    transA  [rocblas_operation]
            - rocblas_operation_transpose:           op(A) = A^T
            - rocblas_operation_none:                op(A) = A
            - rocblas_operation_conjugate_transpose: op(A) = A^T

            rocblas_operation_conjugate_transpose is not supported for complex types. See cherk
            and zherk.

    @param[in]
    n       [rocblas_int]
            n specifies the number of rows and columns of C. n >= 0.

    @param[in]
    k       [rocblas_int]
            k specifies the number of columns of op(A). k >= 0.

    @param[in]
    alpha
            alpha specifies the scalar alpha. When alpha is
            zero then A is not referenced and A need not be set before
            entry.

    @param[in]
    A       pointer storing matrix A on the GPU.
            Matrix dimension is ( lda, k ) when if transA = rocblas_operation_none, otherwise (lda, n)

    @param[in]
    lda     [rocblas_int]
            lda specifies the first dimension of A.

            if transA = rocblas_operation_none,  lda >= max( 1, n ),
            otherwise lda >= max( 1, k ).

    @param[in]
    beta
            beta specifies the scalar beta. When beta is
            zero then C need not be set before entry.

    @param[in]
    C       pointer storing matrix C on the GPU.
            only the upper/lower triangular part is accessed.

    @param[in]
    ldc    [rocblas_int]
           ldc specifies the first dimension of C. ldc >= max( 1, n ).

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_ssyrk",
        fn (
            Handle,
            Fill,
            Operation,
            Int32,
            Int32,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int32,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int32,
        ) -> Status,
    ]()(handle, uplo, trans_a, n, k, alpha, _a, lda, beta, _c, ldc)


fn rocblas_strtri_strided_batched(
    handle: Handle,
    uplo: Fill,
    diag: Diagonal,
    n: Int32,
    _a: UnsafePointer[Float32],
    lda: Int32,
    stride_a: Int64,
    inv_a: UnsafePointer[Float32],
    ldinv_a: Int32,
    stride_inv_a: Int64,
    batch_count: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 3 API </b>.

    \\details
    trtri_strided_batched compute the inverse of A_i and write into invA_i where
                   A_i and invA_i are the i-th matrices in the batch,
                   for i = 1, ..., batch_count.

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    uplo      [rocblas_fill]
              specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
    @param[in]
    diag      [rocblas_diagonal]
              - 'rocblas_diagonal_non_unit', A is non-unit triangular;
              - 'rocblas_diagonal_unit', A is unit triangular;
    @param[in]
    n         [rocblas_int]
    @param[in]
    A         device pointer pointing to address of first matrix A_1.
    @param[in]
    lda       [rocblas_int]
              specifies the leading dimension of each A.
    @param[in]
    stride_a  [rocblas_stride]
             "batch stride a": stride from the start of one A_i matrix to the next A_(i + 1).
    @param[out]
    invA      device pointer storing the inverses of each matrix A_i.
              Partial inplace operation is supported. See below:

                - If UPLO = 'U', the leading N-by-N upper triangular part of the invA will store
                the inverse of the upper triangular matrix, and the strictly lower
                triangular part of invA may be cleared.

                - If UPLO = 'L', the leading N-by-N lower triangular part of the invA will store
                the inverse of the lower triangular matrix, and the strictly upper
                triangular part of invA may be cleared.
    @param[in]
    ldinvA    [rocblas_int]
              specifies the leading dimension of each invA_i.
    @param[in]
    stride_invA  [rocblas_stride]
                 "batch stride invA": stride from the start of one invA_i matrix to the next invA_(i + 1).
    @param[in]
    batch_count  [rocblas_int]
                 numbers of matrices in the batch.
    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_strtri_strided_batched",
        fn (
            Handle,
            Fill,
            Diagonal,
            Int32,
            UnsafePointer[Float32],
            Int32,
            Int64,
            UnsafePointer[Float32],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        uplo,
        diag,
        n,
        _a,
        lda,
        stride_a,
        inv_a,
        ldinv_a,
        stride_inv_a,
        batch_count,
    )


fn rocblas_chpr_strided_batched_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    alpha: UnsafePointer[Float32],
    x: UnsafePointer[ComplexFloat32],
    incx: Int64,
    stride_x: Int64,
    _ap: UnsafePointer[ComplexFloat32],
    stride__a: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_chpr_strided_batched_64",
        fn (
            Handle,
            Fill,
            Int64,
            UnsafePointer[Float32],
            UnsafePointer[ComplexFloat32],
            Int64,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, uplo, n, alpha, x, incx, stride_x, _ap, stride__a, batch_count)


fn rocblas_izamax_strided_batched(
    handle: Handle,
    n: Int32,
    x: UnsafePointer[ComplexFloat64],
    incx: Int32,
    stridex: Int64,
    batch_count: Int32,
    result: UnsafePointer[Int32],
) -> Status:
    return _get_dylib_function[
        "rocblas_izamax_strided_batched",
        fn (
            Handle,
            Int32,
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            Int32,
            UnsafePointer[Int32],
        ) -> Status,
    ]()(handle, n, x, incx, stridex, batch_count, result)


fn rocblas_ztpsv_batched_64(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int64,
    _ap: OpaquePointer,
    x: OpaquePointer,
    incx: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_ztpsv_batched_64",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int64,
            OpaquePointer,
            OpaquePointer,
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, uplo, trans_a, diag, n, _ap, x, incx, batch_count)


fn rocblas_zhbmv_strided_batched(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    k: Int32,
    alpha: UnsafePointer[ComplexFloat64],
    _a: UnsafePointer[ComplexFloat64],
    lda: Int32,
    stride__a: Int64,
    x: UnsafePointer[ComplexFloat64],
    incx: Int32,
    stride_x: Int64,
    beta: UnsafePointer[ComplexFloat64],
    y: UnsafePointer[ComplexFloat64],
    incy: Int32,
    stride_y: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_zhbmv_strided_batched",
        fn (
            Handle,
            Fill,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        uplo,
        n,
        k,
        alpha,
        _a,
        lda,
        stride__a,
        x,
        incx,
        stride_x,
        beta,
        y,
        incy,
        stride_y,
        batch_count,
    )


fn rocblas_dspr(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    alpha: UnsafePointer[Float64],
    x: UnsafePointer[Float64],
    incx: Int32,
    _ap: UnsafePointer[Float64],
) -> Status:
    return _get_dylib_function[
        "rocblas_dspr",
        fn (
            Handle,
            Fill,
            Int32,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int32,
            UnsafePointer[Float64],
        ) -> Status,
    ]()(handle, uplo, n, alpha, x, incx, _ap)


fn rocblas_zspr_batched_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    alpha: UnsafePointer[ComplexFloat64],
    x: OpaquePointer,
    incx: Int64,
    _ap: OpaquePointer,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_zspr_batched_64",
        fn (
            Handle,
            Fill,
            Int64,
            UnsafePointer[ComplexFloat64],
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
        ) -> Status,
    ]()(handle, uplo, n, alpha, x, incx, _ap, batch_count)


fn rocblas_ssyrk_batched(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    n: Int32,
    k: Int32,
    alpha: UnsafePointer[Float32],
    _a: OpaquePointer,
    lda: Int32,
    beta: UnsafePointer[Float32],
    _c: OpaquePointer,
    ldc: Int32,
    batch_count: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 3 API </b>.

    \\details
    syrk_batched performs a batch of the matrix-matrix operations for a symmetric rank-k update:

        C_i := alpha*op( A_i )*op( A_i )^T + beta*C_i,

        where  alpha and beta are scalars, op(A_i) is an n by k matrix, and
        C_i is a symmetric n x n matrix stored as either upper or lower.

        op( A_i ) = A_i, and A_i is n by k if transA == rocblas_operation_none
        op( A_i ) = A_i^T and A_i is k by n if transA == rocblas_operation_transpose

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.

    @param[in]
    uplo    [rocblas_fill]
            - rocblas_fill_upper:  C_i is an upper triangular matrix
            - rocblas_fill_lower:  C_i is a  lower triangular matrix

    @param[in]
    transA  [rocblas_operation]
            - rocblas_operation_transpose:           op(A) = A^T
            - rocblas_operation_none:                op(A) = A
            - rocblas_operation_conjugate_transpose: op(A) = A^T

            rocblas_operation_conjugate_transpose is not supported for complex types. See cherk
            and zherk.

    @param[in]
    n       [rocblas_int]
            n specifies the number of rows and columns of C_i. n >= 0.

    @param[in]
    k       [rocblas_int]
            k specifies the number of columns of op(A). k >= 0.

    @param[in]
    alpha
            alpha specifies the scalar alpha. When alpha is
            zero then A is not referenced and A need not be set before
            entry.

    @param[in]
    A       device array of device pointers storing each matrix_i A of dimension (lda, k)
            when transA is rocblas_operation_none, otherwise of dimension (lda, n).

    @param[in]
    lda     [rocblas_int]
            lda specifies the first dimension of A_i.

                if transA = rocblas_operation_none,  lda >= max( 1, n ),
                otherwise lda >= max( 1, k ).

    @param[in]
    beta
            beta specifies the scalar beta. When beta is
            zero then C need not be set before entry.

    @param[in]
    C       device array of device pointers storing each matrix C_i on the GPU.
            only the upper/lower triangular part of each C_i is accessed.

    @param[in]
    ldc    [rocblas_int]
           ldc specifies the first dimension of C. ldc >= max( 1, n ).
    @param[in]
    batch_count [rocblas_int]
                number of instances in the batch.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_ssyrk_batched",
        fn (
            Handle,
            Fill,
            Operation,
            Int32,
            Int32,
            UnsafePointer[Float32],
            OpaquePointer,
            Int32,
            UnsafePointer[Float32],
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(handle, uplo, trans_a, n, k, alpha, _a, lda, beta, _c, ldc, batch_count)


fn rocblas_zherk_batched(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    n: Int32,
    k: Int32,
    alpha: UnsafePointer[Float64],
    _a: OpaquePointer,
    lda: Int32,
    beta: UnsafePointer[Float64],
    _c: OpaquePointer,
    ldc: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_zherk_batched",
        fn (
            Handle,
            Fill,
            Operation,
            Int32,
            Int32,
            UnsafePointer[Float64],
            OpaquePointer,
            Int32,
            UnsafePointer[Float64],
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(handle, uplo, trans_a, n, k, alpha, _a, lda, beta, _c, ldc, batch_count)


fn rocblas_dspr_batched(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    alpha: UnsafePointer[Float64],
    x: OpaquePointer,
    incx: Int32,
    _ap: OpaquePointer,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_dspr_batched",
        fn (
            Handle,
            Fill,
            Int32,
            UnsafePointer[Float64],
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
        ) -> Status,
    ]()(handle, uplo, n, alpha, x, incx, _ap, batch_count)


fn rocblas_dtbmv_batched_64(
    handle: Handle,
    uplo: Fill,
    trans: Operation,
    diag: Diagonal,
    n: Int64,
    k: Int64,
    _a: OpaquePointer,
    lda: Int64,
    x: OpaquePointer,
    incx: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_dtbmv_batched_64",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int64,
            Int64,
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, uplo, trans, diag, n, k, _a, lda, x, incx, batch_count)


fn rocblas_dzasum(
    handle: Handle,
    n: Int32,
    x: UnsafePointer[ComplexFloat64],
    incx: Int32,
    result: UnsafePointer[Float64],
) -> Status:
    return _get_dylib_function[
        "rocblas_dzasum",
        fn (
            Handle,
            Int32,
            UnsafePointer[ComplexFloat64],
            Int32,
            UnsafePointer[Float64],
        ) -> Status,
    ]()(handle, n, x, incx, result)


fn rocblas_crotg_batched_64(
    handle: Handle,
    a: OpaquePointer,
    b: OpaquePointer,
    c: OpaquePointer,
    s: OpaquePointer,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_crotg_batched_64",
        fn (
            Handle,
            OpaquePointer,
            OpaquePointer,
            OpaquePointer,
            OpaquePointer,
            Int64,
        ) -> Status,
    ]()(handle, a, b, c, s, batch_count)


fn rocblas_cgemm_batched(
    handle: Handle,
    trans_a: Operation,
    trans_b: Operation,
    m: Int32,
    n: Int32,
    k: Int32,
    alpha: UnsafePointer[ComplexFloat32],
    _a: OpaquePointer,
    lda: Int32,
    _b: OpaquePointer,
    ldb: Int32,
    beta: UnsafePointer[ComplexFloat32],
    _c: OpaquePointer,
    ldc: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_cgemm_batched",
        fn (
            Handle,
            Operation,
            Operation,
            Int32,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat32],
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            UnsafePointer[ComplexFloat32],
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(
        handle,
        trans_a,
        trans_b,
        m,
        n,
        k,
        alpha,
        _a,
        lda,
        _b,
        ldb,
        beta,
        _c,
        ldc,
        batch_count,
    )


fn rocblas_ztbmv_batched(
    handle: Handle,
    uplo: Fill,
    trans: Operation,
    diag: Diagonal,
    n: Int32,
    k: Int32,
    _a: OpaquePointer,
    lda: Int32,
    x: OpaquePointer,
    incx: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_ztbmv_batched",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int32,
            Int32,
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(handle, uplo, trans, diag, n, k, _a, lda, x, incx, batch_count)


fn rocblas_srotmg_strided_batched(
    handle: Handle,
    d1: UnsafePointer[Float32],
    stride_d1: Int64,
    d2: UnsafePointer[Float32],
    stride_d2: Int64,
    x1: UnsafePointer[Float32],
    stride_x1: Int64,
    y1: UnsafePointer[Float32],
    stride_y1: Int64,
    param: UnsafePointer[Float32],
    stride_param: Int64,
    batch_count: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 1 API </b>.

    \\details
    rotmg_strided_batched creates the modified Givens rotation matrix for the strided batched vectors (d1_i * x1_i, d2_i * y1_i), for i = 1, ..., batch_count.
          Parameters may be stored in either host or device memory. Location is specified by calling rocblas_set_pointer_mode:

    - If the pointer mode is set to rocblas_pointer_mode_host, then this function blocks the CPU until the GPU has finished and the results are available in host memory.
    - If the pointer mode is set to rocblas_pointer_mode_device, then this function returns immediately and synchronization is required to read the results.

    @param[in]
    handle  [rocblas_handle]
            handle to the rocblas library context queue.
    @param[in, out]
    d1      device strided_batched array or host strided_batched array of input scalars that is overwritten.
    @param[in]
    stride_d1 [rocblas_stride]
              specifies the increment between the beginning of d1_i and d1_(i+1).
    @param[in, out]
    d2      device strided_batched array or host strided_batched array of input scalars that is overwritten.
    @param[in]
    stride_d2 [rocblas_stride]
              specifies the increment between the beginning of d2_i and d2_(i+1).
    @param[in, out]
    x1      device strided_batched array or host strided_batched array of input scalars that is overwritten.
    @param[in]
    stride_x1 [rocblas_stride]
              specifies the increment between the beginning of x1_i and x1_(i+1).
    @param[in]
    y1      device strided_batched array or host strided_batched array of input scalars.
    @param[in]
    stride_y1 [rocblas_stride]
              specifies the increment between the beginning of y1_i and y1_(i+1).
    @param[out]
    param   device strided_batched array or host strided_batched array of vectors of 5 elements defining the rotation.

        param[0] = flag
        param[1] = H11
        param[2] = H21
        param[3] = H12
        param[4] = H22
        The flag parameter defines the form of H:

        flag = -1 => H = ( H11 H12 H21 H22 )
        flag =  0 => H = ( 1.0 H12 H21 1.0 )
        flag =  1 => H = ( H11 1.0 -1.0 H22 )
        flag = -2 => H = ( 1.0 0.0 0.0 1.0 )

        param may be stored in either host or device memory.
        Location is specified by calling rocblas_set_pointer_mode.

    @param[in]
    stride_param [rocblas_stride]
                 specifies the increment between the beginning of param_i and param_(i + 1).
    @param[in]
    batch_count [rocblas_int]
                the number of instances in the batch.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_srotmg_strided_batched",
        fn (
            Handle,
            UnsafePointer[Float32],
            Int64,
            UnsafePointer[Float32],
            Int64,
            UnsafePointer[Float32],
            Int64,
            UnsafePointer[Float32],
            Int64,
            UnsafePointer[Float32],
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        d1,
        stride_d1,
        d2,
        stride_d2,
        x1,
        stride_x1,
        y1,
        stride_y1,
        param,
        stride_param,
        batch_count,
    )


fn rocblas_zaxpy_64(
    handle: Handle,
    n: Int64,
    alpha: UnsafePointer[ComplexFloat64],
    x: UnsafePointer[ComplexFloat64],
    incx: Int64,
    y: UnsafePointer[ComplexFloat64],
    incy: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_zaxpy_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int64,
            UnsafePointer[ComplexFloat64],
            Int64,
        ) -> Status,
    ]()(handle, n, alpha, x, incx, y, incy)


fn rocblas_ctrmv_batched_64(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int64,
    _a: UnsafePointer[UnsafePointer[ComplexFloat32]],
    lda: Int64,
    x: UnsafePointer[UnsafePointer[ComplexFloat32]],
    incx: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_ctrmv_batched_64",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int64,
            UnsafePointer[UnsafePointer[ComplexFloat32]],
            Int64,
            UnsafePointer[UnsafePointer[ComplexFloat32]],
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, uplo, trans_a, diag, n, _a, lda, x, incx, batch_count)


fn rocblas_zgeru_strided_batched_64(
    handle: Handle,
    m: Int64,
    n: Int64,
    alpha: UnsafePointer[ComplexFloat64],
    x: UnsafePointer[ComplexFloat64],
    incx: Int64,
    stridex: Int64,
    y: UnsafePointer[ComplexFloat64],
    incy: Int64,
    stridey: Int64,
    _a: UnsafePointer[ComplexFloat64],
    lda: Int64,
    stride_a: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_zgeru_strided_batched_64",
        fn (
            Handle,
            Int64,
            Int64,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int64,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int64,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int64,
            Int64,
            Int64,
        ) -> Status,
    ]()(
        handle,
        m,
        n,
        alpha,
        x,
        incx,
        stridex,
        y,
        incy,
        stridey,
        _a,
        lda,
        stride_a,
        batch_count,
    )


fn rocblas_rot_batched_ex_64(
    handle: Handle,
    n: Int64,
    x: OpaquePointer,
    x_type: DataType,
    incx: Int64,
    y: OpaquePointer,
    y_type: DataType,
    incy: Int64,
    c: OpaquePointer,
    s: OpaquePointer,
    cs_type: DataType,
    batch_count: Int64,
    execution_type: DataType,
) -> Status:
    return _get_dylib_function[
        "rocblas_rot_batched_ex_64",
        fn (
            Handle,
            Int64,
            OpaquePointer,
            DataType,
            Int64,
            OpaquePointer,
            DataType,
            Int64,
            OpaquePointer,
            OpaquePointer,
            DataType,
            Int64,
            DataType,
        ) -> Status,
    ]()(
        handle,
        n,
        x,
        x_type,
        incx,
        y,
        y_type,
        incy,
        c,
        s,
        cs_type,
        batch_count,
        execution_type,
    )


fn rocblas_zsyrk_strided_batched(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    n: Int32,
    k: Int32,
    alpha: UnsafePointer[ComplexFloat64],
    _a: UnsafePointer[ComplexFloat64],
    lda: Int32,
    stride__a: Int64,
    beta: UnsafePointer[ComplexFloat64],
    _c: UnsafePointer[ComplexFloat64],
    ldc: Int32,
    stride__c: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_zsyrk_strided_batched",
        fn (
            Handle,
            Fill,
            Operation,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        uplo,
        trans_a,
        n,
        k,
        alpha,
        _a,
        lda,
        stride__a,
        beta,
        _c,
        ldc,
        stride__c,
        batch_count,
    )


fn rocblas_sdgmm_batched(
    handle: Handle,
    side: Side,
    m: Int32,
    n: Int32,
    _a: OpaquePointer,
    lda: Int32,
    x: OpaquePointer,
    incx: Int32,
    _c: OpaquePointer,
    ldc: Int32,
    batch_count: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 3 API </b>.

    \\details
    dgmm_batched performs one of the batched matrix-matrix operations:

        C_i = A_i * diag(x_i) for i = 0, 1, ... batch_count-1 if side == rocblas_side_right
        C_i = diag(x_i) * A_i for i = 0, 1, ... batch_count-1 if side == rocblas_side_left,

        where C_i and A_i are m by n dimensional matrices. diag(x_i) is a diagonal matrix
        and x_i is vector of dimension n if side == rocblas_side_right and dimension m
        if side == rocblas_side_left.

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    side      [rocblas_side]
              specifies the side of diag(x).
    @param[in]
    m         [rocblas_int]
              matrix dimension m.
    @param[in]
    n         [rocblas_int]
              matrix dimension n.
    @param[in]
    A         device array of device pointers storing each matrix A_i on the GPU.
              Each A_i is of dimension ( lda, n ).
    @param[in]
    lda       [rocblas_int]
              specifies the leading dimension of A_i.
    @param[in]
    x         device array of device pointers storing each vector x_i on the GPU.
              Each x_i is of dimension n if side == rocblas_side_right and dimension
              m if side == rocblas_side_left.
    @param[in]
    incx      [rocblas_int]
              specifies the increment between values of x_i.
    @param[in, out]
    C         device array of device pointers storing each matrix C_i on the GPU.
              Each C_i is of dimension ( ldc, n ).
    @param[in]
    ldc       [rocblas_int]
              specifies the leading dimension of C_i.
    @param[in]
    batch_count [rocblas_int]
                number of instances in the batch.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_sdgmm_batched",
        fn (
            Handle,
            Side,
            Int32,
            Int32,
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(handle, side, m, n, _a, lda, x, incx, _c, ldc, batch_count)


fn rocblas_chemv_batched(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat32],
    _a: OpaquePointer,
    lda: Int32,
    x: OpaquePointer,
    incx: Int32,
    beta: UnsafePointer[ComplexFloat32],
    y: OpaquePointer,
    incy: Int32,
    batch_count: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 2 API </b>.

    \\details
    hemv_batched performs one of the matrix-vector operations:

        y_i := alpha*A_i*x_i + beta*y_i
        where alpha and beta are scalars, x_i and y_i are n element vectors and A_i is an
        n by n Hermitian matrix, for each batch in i = [1, batch_count].

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    uplo      [rocblas_fill]
            - rocblas_fill_upper: the upper triangular part of the Hermitian matrix A is supplied.
            - rocblas_fill_lower: the lower triangular part of the Hermitian matrix A is supplied.
    @param[in]
    n         [rocblas_int]
              the order of each matrix A_i.
    @param[in]
    alpha     device pointer or host pointer to scalar alpha.
    @param[in]
    A         device array of device pointers storing each matrix A_i of dimension (lda, n).

        if uplo == rocblas_fill_upper:
            The upper triangular part of each A_i must contain
            the upper triangular part of a Hermitian matrix. The lower
            triangular part of each A_i will not be referenced.

        if uplo == rocblas_fill_lower:
            The lower triangular part of each A_i must contain
            the lower triangular part of a Hermitian matrix. The upper
            triangular part of each A_i will not be referenced.
            As a Hermitian matrix, the imaginary part of the main diagonal
            of each A_i will not be referenced and is assumed to be == 0.
    @param[in]
    lda       [rocblas_int]
              specifies the leading dimension of each A_i. must be >= max(1, n).
    @param[in]
    x         device array of device pointers storing each vector x_i.
    @param[in]
    incx      [rocblas_int]
              specifies the increment for the elements of each x_i.
    @param[in]
    beta      device pointer or host pointer to scalar beta.
    @param[in, out]
    y         device array of device pointers storing each vector y_i.
    @param[in]
    incy      [rocblas_int]
              specifies the increment for the elements of y.
    @param[in]
    batch_count [rocblas_int]
                number of instances in the batch.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_chemv_batched",
        fn (
            Handle,
            Fill,
            Int32,
            UnsafePointer[ComplexFloat32],
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            UnsafePointer[ComplexFloat32],
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(handle, uplo, n, alpha, _a, lda, x, incx, beta, y, incy, batch_count)


fn rocblas_ztbmv(
    handle: Handle,
    uplo: Fill,
    trans: Operation,
    diag: Diagonal,
    n: Int32,
    k: Int32,
    _a: UnsafePointer[ComplexFloat64],
    lda: Int32,
    x: UnsafePointer[ComplexFloat64],
    incx: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_ztbmv",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat64],
            Int32,
            UnsafePointer[ComplexFloat64],
            Int32,
        ) -> Status,
    ]()(handle, uplo, trans, diag, n, k, _a, lda, x, incx)


fn rocblas_ztrsv(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int32,
    _a: UnsafePointer[ComplexFloat64],
    lda: Int32,
    x: UnsafePointer[ComplexFloat64],
    incx: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_ztrsv",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int32,
            UnsafePointer[ComplexFloat64],
            Int32,
            UnsafePointer[ComplexFloat64],
            Int32,
        ) -> Status,
    ]()(handle, uplo, trans_a, diag, n, _a, lda, x, incx)


fn rocblas_zsymv_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    alpha: UnsafePointer[ComplexFloat64],
    _a: UnsafePointer[ComplexFloat64],
    lda: Int64,
    x: UnsafePointer[ComplexFloat64],
    incx: Int64,
    beta: UnsafePointer[ComplexFloat64],
    y: UnsafePointer[ComplexFloat64],
    incy: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_zsymv_64",
        fn (
            Handle,
            Fill,
            Int64,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int64,
            UnsafePointer[ComplexFloat64],
            Int64,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int64,
        ) -> Status,
    ]()(handle, uplo, n, alpha, _a, lda, x, incx, beta, y, incy)


fn rocblas_dtrsv(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int32,
    _a: UnsafePointer[Float64],
    lda: Int32,
    x: UnsafePointer[Float64],
    incx: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_dtrsv",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int32,
            UnsafePointer[Float64],
            Int32,
            UnsafePointer[Float64],
            Int32,
        ) -> Status,
    ]()(handle, uplo, trans_a, diag, n, _a, lda, x, incx)


fn rocblas_zdgmm_batched(
    handle: Handle,
    side: Side,
    m: Int32,
    n: Int32,
    _a: OpaquePointer,
    lda: Int32,
    x: OpaquePointer,
    incx: Int32,
    _c: OpaquePointer,
    ldc: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_zdgmm_batched",
        fn (
            Handle,
            Side,
            Int32,
            Int32,
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(handle, side, m, n, _a, lda, x, incx, _c, ldc, batch_count)


fn rocblas_stpmv_batched(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int32,
    _a: UnsafePointer[UnsafePointer[Float32]],
    x: UnsafePointer[UnsafePointer[Float32]],
    incx: Int32,
    batch_count: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 2 API </b>.

    \\details
    tpmv_batched performs one of the matrix-vector operations:

        x_i = A_i*x_i or
        x_i = A_i**T*x_i or
        x_i = A_i**H*x_i, 0 < i < batch_count
        where x_i is an n element vector and A_i is an n by n (unit, or non-unit, upper or lower triangular matrix)
        The vectors x_i are overwritten.

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.

    @param[in]
    uplo    [rocblas_fill]
            - rocblas_fill_upper:  A_i is an upper triangular matrix.
            - rocblas_fill_lower:  A_i is a  lower triangular matrix.

    @param[in]
    transA     [rocblas_operation]
            - rocblas_operation_none:    op(A) = A.
            - rocblas_operation_transpose:   op(A) = A^T
            - rocblas_operation_conjugate_transpose:  op(A) = A^H

    @param[in]
    diag    [rocblas_diagonal]
            - rocblas_diagonal_unit:     A_i is assumed to be unit triangular.
            - rocblas_diagonal_non_unit:  A_i is not assumed to be unit triangular.

    @param[in]
    n         [rocblas_int]
              n specifies the number of rows of matrices A_i. n >= 0.

    @param[in]
    A         device pointer to an array of device pointers to the A_i matrices, of dimension ( lda, n ). If uplo == rocblas_fill_upper, the upper triangular part of the leading n-by-n array contains the matrix A_i, otherwise the lower triangular part of the leading n-by-n array contains the matrix A_i.

    @param[in, out]
    x         device pointer to an array of device pointers to the x_i vectors. On exit, each x_i is overwritten with the transformed vector x_i.

    @param[in]
    incx      [rocblas_int]
              specifies the increment for the elements of vectors x_i.

    @param[in]
    batch_count [rocblas_int]
              The number of batched matrices/vectors.


    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_stpmv_batched",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int32,
            UnsafePointer[UnsafePointer[Float32]],
            UnsafePointer[UnsafePointer[Float32]],
            Int32,
            Int32,
        ) -> Status,
    ]()(handle, uplo, trans_a, diag, n, _a, x, incx, batch_count)


fn rocblas_icamax_strided_batched_64(
    handle: Handle,
    n: Int64,
    x: UnsafePointer[ComplexFloat32],
    incx: Int64,
    stridex: Int64,
    batch_count: Int64,
    result: UnsafePointer[Int64],
) -> Status:
    return _get_dylib_function[
        "rocblas_icamax_strided_batched_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int64,
            Int64,
            Int64,
            UnsafePointer[Int64],
        ) -> Status,
    ]()(handle, n, x, incx, stridex, batch_count, result)


fn rocblas_dgeam_batched(
    handle: Handle,
    trans_a: Operation,
    trans_b: Operation,
    m: Int32,
    n: Int32,
    alpha: UnsafePointer[Float64],
    _a: OpaquePointer,
    lda: Int32,
    beta: UnsafePointer[Float64],
    _b: OpaquePointer,
    ldb: Int32,
    _c: OpaquePointer,
    ldc: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_dgeam_batched",
        fn (
            Handle,
            Operation,
            Operation,
            Int32,
            Int32,
            UnsafePointer[Float64],
            OpaquePointer,
            Int32,
            UnsafePointer[Float64],
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(
        handle,
        trans_a,
        trans_b,
        m,
        n,
        alpha,
        _a,
        lda,
        beta,
        _b,
        ldb,
        _c,
        ldc,
        batch_count,
    )


fn rocblas_zsyr(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat64],
    x: UnsafePointer[ComplexFloat64],
    incx: Int32,
    _a: UnsafePointer[ComplexFloat64],
    lda: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_zsyr",
        fn (
            Handle,
            Fill,
            Int32,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int32,
            UnsafePointer[ComplexFloat64],
            Int32,
        ) -> Status,
    ]()(handle, uplo, n, alpha, x, incx, _a, lda)


fn rocblas_cdotc_strided_batched(
    handle: Handle,
    n: Int32,
    x: UnsafePointer[ComplexFloat32],
    incx: Int32,
    stridex: Int64,
    y: UnsafePointer[ComplexFloat32],
    incy: Int32,
    stridey: Int64,
    batch_count: Int32,
    result: UnsafePointer[ComplexFloat32],
) -> Status:
    return _get_dylib_function[
        "rocblas_cdotc_strided_batched",
        fn (
            Handle,
            Int32,
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            Int32,
            UnsafePointer[ComplexFloat32],
        ) -> Status,
    ]()(handle, n, x, incx, stridex, y, incy, stridey, batch_count, result)


fn rocblas_dzasum_strided_batched_64(
    handle: Handle,
    n: Int64,
    x: UnsafePointer[ComplexFloat64],
    incx: Int64,
    stridex: Int64,
    batch_count: Int64,
    results: UnsafePointer[Float64],
) -> Status:
    return _get_dylib_function[
        "rocblas_dzasum_strided_batched_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int64,
            Int64,
            Int64,
            UnsafePointer[Float64],
        ) -> Status,
    ]()(handle, n, x, incx, stridex, batch_count, results)


fn rocblas_cher_strided_batched_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    alpha: UnsafePointer[Float32],
    x: UnsafePointer[ComplexFloat32],
    incx: Int64,
    stride_x: Int64,
    _a: UnsafePointer[ComplexFloat32],
    lda: Int64,
    stride__a: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_cher_strided_batched_64",
        fn (
            Handle,
            Fill,
            Int64,
            UnsafePointer[Float32],
            UnsafePointer[ComplexFloat32],
            Int64,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int64,
            Int64,
            Int64,
        ) -> Status,
    ]()(
        handle,
        uplo,
        n,
        alpha,
        x,
        incx,
        stride_x,
        _a,
        lda,
        stride__a,
        batch_count,
    )


fn rocblas_zhpmv_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    alpha: UnsafePointer[ComplexFloat64],
    _ap: UnsafePointer[ComplexFloat64],
    x: UnsafePointer[ComplexFloat64],
    incx: Int64,
    beta: UnsafePointer[ComplexFloat64],
    y: UnsafePointer[ComplexFloat64],
    incy: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_zhpmv_64",
        fn (
            Handle,
            Fill,
            Int64,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int64,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int64,
        ) -> Status,
    ]()(handle, uplo, n, alpha, _ap, x, incx, beta, y, incy)


fn rocblas_zhbmv_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    k: Int64,
    alpha: UnsafePointer[ComplexFloat64],
    _a: UnsafePointer[ComplexFloat64],
    lda: Int64,
    x: UnsafePointer[ComplexFloat64],
    incx: Int64,
    beta: UnsafePointer[ComplexFloat64],
    y: UnsafePointer[ComplexFloat64],
    incy: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_zhbmv_64",
        fn (
            Handle,
            Fill,
            Int64,
            Int64,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int64,
            UnsafePointer[ComplexFloat64],
            Int64,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int64,
        ) -> Status,
    ]()(handle, uplo, n, k, alpha, _a, lda, x, incx, beta, y, incy)


fn rocblas_rot_ex(
    handle: Handle,
    n: Int32,
    x: OpaquePointer,
    x_type: DataType,
    incx: Int32,
    y: OpaquePointer,
    y_type: DataType,
    incy: Int32,
    c: OpaquePointer,
    s: OpaquePointer,
    cs_type: DataType,
    execution_type: DataType,
) -> Status:
    """
    \\brief <b> BLAS EX API </b>.

    \\details
    rot_ex applies the Givens rotation matrix defined by c=cos(alpha) and s=sin(alpha) to vectors x and y.
        Scalars c and s may be stored in either host or device memory. Location is specified by calling rocblas_set_pointer_mode.

    In the case where cs_type is real:

        x := c * x + s * y
        y := c * y - s * x

    In the case where cs_type is complex, the imaginary part of c is ignored:

        x := real(c) * x + s * y
        y := real(c) * y - conj(s) * x

    Currently supported datatypes are as follows:

    ------------------------------------------------
    |  x_type | y_type  | cs_type | execution_type |
    |---------|---------|---------|----------------|
    |  bf16_r |  bf16_r | bf16_r  |  f32_r         |
    |  f16_r  |  f16_r  | f16_r   |  f32_r         |
    |  f32_r  |  f32_r  | f32_r   |  f32_r         |
    |  f64_r  |  f64_r  | f64_r   |  f64_r         |
    |  f32_c  |  f32_c  | f32_c   |  f32_c         |
    |  f32_c  |  f32_c  | f32_r   |  f32_c         |
    |  f64_c  |  f64_c  | f64_c   |  f64_c         |
    |  f64_c  |  f64_c  | f64_r   |  f64_c         |
    ------------------------------------------------

    @param[in]
    handle  [rocblas_handle]
            handle to the rocblas library context queue.
    @param[in]
    n       [rocblas_int]
            number of elements in the x and y vectors.
    @param[in, out]
    x       device pointer storing vector x.
    @param[in]
    x_type [rocblas_datatype]
           specifies the datatype of vector x.
    @param[in]
    incx    [rocblas_int]
            specifies the increment between elements of x.
    @param[in, out]
    y       device pointer storing vector y.
    @param[in]
    y_type [rocblas_datatype]
           specifies the datatype of vector y.
    @param[in]
    incy    [rocblas_int]
            specifies the increment between elements of y.
    @param[in]
    c       device pointer or host pointer storing scalar cosine component of the rotation matrix.
    @param[in]
    s       device pointer or host pointer storing scalar sine component of the rotation matrix.
    @param[in]
    cs_type [rocblas_datatype]
            specifies the datatype of c and s.
    @param[in]
    execution_type [rocblas_datatype]
                   specifies the datatype of computation.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_rot_ex",
        fn (
            Handle,
            Int32,
            OpaquePointer,
            DataType,
            Int32,
            OpaquePointer,
            DataType,
            Int32,
            OpaquePointer,
            OpaquePointer,
            DataType,
            DataType,
        ) -> Status,
    ]()(
        handle,
        n,
        x,
        x_type,
        incx,
        y,
        y_type,
        incy,
        c,
        s,
        cs_type,
        execution_type,
    )


fn rocblas_zgemm_batched(
    handle: Handle,
    trans_a: Operation,
    trans_b: Operation,
    m: Int32,
    n: Int32,
    k: Int32,
    alpha: UnsafePointer[ComplexFloat64],
    _a: OpaquePointer,
    lda: Int32,
    _b: OpaquePointer,
    ldb: Int32,
    beta: UnsafePointer[ComplexFloat64],
    _c: OpaquePointer,
    ldc: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_zgemm_batched",
        fn (
            Handle,
            Operation,
            Operation,
            Int32,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat64],
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            UnsafePointer[ComplexFloat64],
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(
        handle,
        trans_a,
        trans_b,
        m,
        n,
        k,
        alpha,
        _a,
        lda,
        _b,
        ldb,
        beta,
        _c,
        ldc,
        batch_count,
    )


fn rocblas_ctbsv_batched(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int32,
    k: Int32,
    _a: OpaquePointer,
    lda: Int32,
    x: OpaquePointer,
    incx: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_ctbsv_batched",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int32,
            Int32,
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(handle, uplo, trans_a, diag, n, k, _a, lda, x, incx, batch_count)


fn rocblas_cher2k_strided_batched(
    handle: Handle,
    uplo: Fill,
    trans: Operation,
    n: Int32,
    k: Int32,
    alpha: UnsafePointer[ComplexFloat32],
    _a: UnsafePointer[ComplexFloat32],
    lda: Int32,
    stride__a: Int64,
    _b: UnsafePointer[ComplexFloat32],
    ldb: Int32,
    stride__b: Int64,
    beta: UnsafePointer[Float32],
    _c: UnsafePointer[ComplexFloat32],
    ldc: Int32,
    stride__c: Int64,
    batch_count: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 3 API </b>.

    \\details
    her2k_strided_batched performs a batch of the matrix-matrix operations for a Hermitian rank-2k update:

        C_i := alpha*op( A_i )*op( B_i )^H + conj(alpha)*op( B_i )*op( A_i )^H + beta*C_i,

        where  alpha and beta are scalars, op(A_i) and op(B_i) are n by k matrices, and
        C_i is a n x n Hermitian matrix stored as either upper or lower.

        op( A_i ) = A_i, op( B_i ) = B_i, and A_i and B_i are n by k if trans == rocblas_operation_none
        op( A_i ) = A_i^H, op( B_i ) = B_i^H,  and A_i and B_i are k by n if trans == rocblas_operation_conjugate_transpose

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.

    @param[in]
    uplo    [rocblas_fill]
            - rocblas_fill_upper:  C_i is an upper triangular matrix
            - rocblas_fill_lower:  C_i is a  lower triangular matrix

    @param[in]
    trans  [rocblas_operation]
            - rocblas_operation_conjugate_transpose: op( A_i ) = A_i^H, op( B_i ) = B_i^H
            - rocblas_operation_none:                op( A_i ) = A_i, op( B_i ) = B_i

    @param[in]
    n       [rocblas_int]
            n specifies the number of rows and columns of C_i. n >= 0.

    @param[in]
    k       [rocblas_int]
            k specifies the number of columns of op(A). k >= 0.

    @param[in]
    alpha
            alpha specifies the scalar alpha. When alpha is
            zero then A is not referenced and A need not be set before
            entry.

    @param[in]
    A       Device pointer to the first matrix A_1 on the GPU of dimension (lda, k)
            when trans is rocblas_operation_none, otherwise of dimension (lda, n).

    @param[in]
    lda     [rocblas_int]
            lda specifies the first dimension of A_i.

                if trans = rocblas_operation_none,  lda >= max( 1, n ),
                otherwise lda >= max( 1, k ).

    @param[in]
    stride_A  [rocblas_stride]
              stride from the start of one matrix (A_i) and the next one (A_i+1).

    @param[in]
    B       Device pointer to the first matrix B_1 on the GPU of dimension (ldb, k)
            when trans is rocblas_operation_none, otherwise of dimension (ldb, n).

    @param[in]
    ldb     [rocblas_int]
            ldb specifies the first dimension of B_i.

                if trans = rocblas_operation_none,  ldb >= max( 1, n ),
                otherwise ldb >= max( 1, k ).

    @param[in]
    stride_B  [rocblas_stride]
              stride from the start of one matrix (B_i) and the next one (B_i+1).

    @param[in]
    beta
            beta specifies the scalar beta. When beta is
            zero then C need not be set before entry.

    @param[in]
    C       Device pointer to the first matrix C_1 on the GPU.
            The imaginary component of the diagonal elements are not used but are set to zero unless quick return.
            only the upper/lower triangular part of each C_i is accessed.

    @param[in]
    ldc    [rocblas_int]
           ldc specifies the first dimension of C. ldc >= max( 1, n ).

    @param[in, out]
    stride_C  [rocblas_stride]
              stride from the start of one matrix (C_i) and the next one (C_i+1).

    @param[in]
    batch_count [rocblas_int]
                number of instances in the batch.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_cher2k_strided_batched",
        fn (
            Handle,
            Fill,
            Operation,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            UnsafePointer[Float32],
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        uplo,
        trans,
        n,
        k,
        alpha,
        _a,
        lda,
        stride__a,
        _b,
        ldb,
        stride__b,
        beta,
        _c,
        ldc,
        stride__c,
        batch_count,
    )


fn rocblas_sscal_strided_batched_64(
    handle: Handle,
    n: Int64,
    alpha: UnsafePointer[Float32],
    x: UnsafePointer[Float32],
    incx: Int64,
    stride_x: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_sscal_strided_batched_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int64,
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, n, alpha, x, incx, stride_x, batch_count)


fn rocblas_zherk_strided_batched(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    n: Int32,
    k: Int32,
    alpha: UnsafePointer[Float64],
    _a: UnsafePointer[ComplexFloat64],
    lda: Int32,
    stride__a: Int64,
    beta: UnsafePointer[Float64],
    _c: UnsafePointer[ComplexFloat64],
    ldc: Int32,
    stride__c: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_zherk_strided_batched",
        fn (
            Handle,
            Fill,
            Operation,
            Int32,
            Int32,
            UnsafePointer[Float64],
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            UnsafePointer[Float64],
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        uplo,
        trans_a,
        n,
        k,
        alpha,
        _a,
        lda,
        stride__a,
        beta,
        _c,
        ldc,
        stride__c,
        batch_count,
    )


fn rocblas_scal_ex(
    handle: Handle,
    n: Int32,
    alpha: OpaquePointer,
    alpha_type: DataType,
    x: OpaquePointer,
    x_type: DataType,
    incx: Int32,
    execution_type: DataType,
) -> Status:
    """
    \\brief <b> BLAS EX API </b>.

    \\details
    scal_ex  scales each element of vector x with scalar alpha.

        x := alpha * x

    Currently supported datatypes are as follows:

    ----------------------------------------
    | alpha_type | x_type | execution_type |
    |------------|--------|----------------|
    |  f32_r     | bf16_r |     f32_r      |
    |  bf16_r    | bf16_r |     f32_r      |
    |  f16_r     | f16_r  |     f16_r      |
    |  f16_r     | f16_r  |     f32_r      |
    |  f32_r     | f16_r  |     f32_r      |
    |  f32_r     | f32_r  |     f32_r      |
    |  f64_r     | f64_r  |     f64_r      |
    |  f32_c     | f32_c  |     f32_c      |
    |  f64_c     | f64_c  |     f64_c      |
    |  f32_r     | f32_c  |     f32_c      |
    |  f64_r     | f64_c  |     f64_c      |
    ----------------------------------------

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    n         [rocblas_int]
              the number of elements in x.
    @param[in]
    alpha     device pointer or host pointer for the scalar alpha.
    @param[in]
    alpha_type [rocblas_datatype]
               specifies the datatype of alpha.
    @param[in, out]
    x         device pointer storing vector x.
    @param[in]
    x_type [rocblas_datatype]
           specifies the datatype of vector x.
    @param[in]
    incx      [rocblas_int]
              specifies the increment for the elements of x.
    @param[in]
    execution_type [rocblas_datatype]
                   specifies the datatype of computation.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_scal_ex",
        fn (
            Handle,
            Int32,
            OpaquePointer,
            DataType,
            OpaquePointer,
            DataType,
            Int32,
            DataType,
        ) -> Status,
    ]()(handle, n, alpha, alpha_type, x, x_type, incx, execution_type)


fn rocblas_dtrsm(
    handle: Handle,
    side: Side,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    m: Int32,
    n: Int32,
    alpha: UnsafePointer[Float64],
    _a: UnsafePointer[Float64],
    lda: Int32,
    _b: UnsafePointer[Float64],
    ldb: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_dtrsm",
        fn (
            Handle,
            Side,
            Fill,
            Operation,
            Diagonal,
            Int32,
            Int32,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int32,
            UnsafePointer[Float64],
            Int32,
        ) -> Status,
    ]()(handle, side, uplo, trans_a, diag, m, n, alpha, _a, lda, _b, ldb)


fn rocblas_isamax_strided_batched(
    handle: Handle,
    n: Int32,
    x: UnsafePointer[Float32],
    incx: Int32,
    stridex: Int64,
    batch_count: Int32,
    result: UnsafePointer[Int32],
) -> Status:
    """
    \\brief <b> BLAS Level 1 API </b>.

    \\details
     amax_strided_batched finds the first index of the element of maximum magnitude of each vector x_i in a batch, for i = 1, ..., batch_count.

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    n         [rocblas_int]
              number of elements in each vector x_i.
    @param[in]
    x         device pointer to the first vector x_1.
    @param[in]
    incx      [rocblas_int]
              specifies the increment for the elements of each x_i. incx must be > 0.
    @param[in]
    stridex   [rocblas_stride]
              specifies the pointer increment between one x_i and the next x_(i + 1).
    @param[in]
    batch_count [rocblas_int]
              number of instances in the batch.
    @param[out]
    result
              device or host pointer for storing contiguous batch_count results.
              return is 0 if n <= 0, incx<=0.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_isamax_strided_batched",
        fn (
            Handle,
            Int32,
            UnsafePointer[Float32],
            Int32,
            Int64,
            Int32,
            UnsafePointer[Int32],
        ) -> Status,
    ]()(handle, n, x, incx, stridex, batch_count, result)


fn rocblas_caxpy_batched(
    handle: Handle,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat32],
    x: OpaquePointer,
    incx: Int32,
    y: OpaquePointer,
    incy: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_caxpy_batched",
        fn (
            Handle,
            Int32,
            UnsafePointer[ComplexFloat32],
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(handle, n, alpha, x, incx, y, incy, batch_count)


fn rocblas_dgemv_batched_64(
    handle: Handle,
    trans: Operation,
    m: Int64,
    n: Int64,
    alpha: UnsafePointer[Float64],
    _a: OpaquePointer,
    lda: Int64,
    x: OpaquePointer,
    incx: Int64,
    beta: UnsafePointer[Float64],
    y: OpaquePointer,
    incy: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_dgemv_batched_64",
        fn (
            Handle,
            Operation,
            Int64,
            Int64,
            UnsafePointer[Float64],
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            UnsafePointer[Float64],
            OpaquePointer,
            Int64,
            Int64,
        ) -> Status,
    ]()(
        handle, trans, m, n, alpha, _a, lda, x, incx, beta, y, incy, batch_count
    )


fn rocblas_zhpr2(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat64],
    x: UnsafePointer[ComplexFloat64],
    incx: Int32,
    y: UnsafePointer[ComplexFloat64],
    incy: Int32,
    _ap: UnsafePointer[ComplexFloat64],
) -> Status:
    return _get_dylib_function[
        "rocblas_zhpr2",
        fn (
            Handle,
            Fill,
            Int32,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int32,
            UnsafePointer[ComplexFloat64],
            Int32,
            UnsafePointer[ComplexFloat64],
        ) -> Status,
    ]()(handle, uplo, n, alpha, x, incx, y, incy, _ap)


fn rocblas_hgemm_batched(
    handle: Handle,
    trans_a: Operation,
    trans_b: Operation,
    m: Int32,
    n: Int32,
    k: Int32,
    alpha: UnsafePointer[Float16],
    _a: OpaquePointer,
    lda: Int32,
    _b: OpaquePointer,
    ldb: Int32,
    beta: UnsafePointer[Float16],
    _c: OpaquePointer,
    ldc: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_hgemm_batched",
        fn (
            Handle,
            Operation,
            Operation,
            Int32,
            Int32,
            Int32,
            UnsafePointer[Float16],
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            UnsafePointer[Float16],
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(
        handle,
        trans_a,
        trans_b,
        m,
        n,
        k,
        alpha,
        _a,
        lda,
        _b,
        ldb,
        beta,
        _c,
        ldc,
        batch_count,
    )


fn rocblas_strsm(
    handle: Handle,
    side: Side,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    m: Int32,
    n: Int32,
    alpha: UnsafePointer[Float32],
    _a: UnsafePointer[Float32],
    lda: Int32,
    _b: UnsafePointer[Float32],
    ldb: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 3 API </b>.

    \\details
    trsm solves:

        op(A)*X = alpha*B or  X*op(A) = alpha*B,

        where alpha is a scalar, X and B are m by n matrices,

        A is triangular matrix and op(A) is one of

        op( A ) = A   or   op( A ) = A^T   or   op( A ) = A^H.

        The matrix X is overwritten on B.

    Note about memory allocation:
    When trsm is launched with a k evenly divisible by the internal block size of 128,
    and is no larger than 10 of these blocks, the API takes advantage of utilizing pre-allocated
    memory found in the handle to increase overall performance. This memory can be managed by using
    the environment variable WORKBUF_TRSM_B_CHNK. When this variable is not set the device memory
    used for temporary storage will default to 1 MB and may result in chunking, which in turn may
    reduce performance. Under these circumstances it is recommended that WORKBUF_TRSM_B_CHNK be set
    to the desired chunk of right hand sides to be used at a time
    (where k is m when rocblas_side_left and is n when rocblas_side_right).

    Although not widespread, some gemm kernels used by trsm may use atomic operations.
    See Atomic Operations in the API Reference Guide for more information.

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.

    @param[in]
    side    [rocblas_side]
            - rocblas_side_left:       op(A)*X = alpha*B
            - rocblas_side_right:      X*op(A) = alpha*B

    @param[in]
    uplo    [rocblas_fill]
            - rocblas_fill_upper:  A is an upper triangular matrix.
            - rocblas_fill_lower:  A is a  lower triangular matrix.

    @param[in]
    transA  [rocblas_operation]
            - transB:    op(A) = A.
            - rocblas_operation_transpose:      op(A) = A^T
            - rocblas_operation_conjugate_transpose:  op(A) = A^H

    @param[in]
    diag    [rocblas_diagonal]
            - rocblas_diagonal_unit:     A is assumed to be unit triangular.
            - rocblas_diagonal_non_unit:  A is not assumed to be unit triangular.

    @param[in]
    m       [rocblas_int]
            m specifies the number of rows of B. m >= 0.

    @param[in]
    n       [rocblas_int]
            n specifies the number of columns of B. n >= 0.

    @param[in]
    alpha
            device pointer or host pointer specifying the scalar alpha. When alpha is
            &zero then A is not referenced and B need not be set before
            entry.

    @param[in]
    A       device pointer storing matrix A.
            of dimension ( lda, k ), where k is m
            when  rocblas_side_left  and
            is  n  when  rocblas_side_right
            only the upper/lower triangular part is accessed.

    @param[in]
    lda     [rocblas_int]
            lda specifies the first dimension of A.

                if side = rocblas_side_left,  lda >= max( 1, m ),
                if side = rocblas_side_right, lda >= max( 1, n ).

    @param[in,out]
    B       device pointer storing matrix B.

    @param[in]
    ldb    [rocblas_int]
           ldb specifies the first dimension of B. ldb >= max( 1, m ).

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_strsm",
        fn (
            Handle,
            Side,
            Fill,
            Operation,
            Diagonal,
            Int32,
            Int32,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int32,
            UnsafePointer[Float32],
            Int32,
        ) -> Status,
    ]()(handle, side, uplo, trans_a, diag, m, n, alpha, _a, lda, _b, ldb)


fn rocblas_stpsv_strided_batched(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int32,
    _ap: UnsafePointer[Float32],
    stride__a: Int64,
    x: UnsafePointer[Float32],
    incx: Int32,
    stride_x: Int64,
    batch_count: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 2 API </b>.

    \\details
    tpsv_strided_batched solves:

         A_i*x_i = b_i or
         A_i**T*x_i = b_i or
         A_i**H*x_i = b_i
        where x_i and b_i are vectors and A_i is a triangular matrix stored in the packed format,
        for i in [1, batch_count].

    The input vectors b_i are overwritten by the output vectors x_i.

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.

    @param[in]
    uplo    [rocblas_fill]
            - rocblas_fill_upper:  each A_i is an upper triangular matrix.
            - rocblas_fill_lower:  each A_i is a  lower triangular matrix.

    @param[in]
    transA  [rocblas_operation]
            - rocblas_operation_none: Solves A*x = b
            - rocblas_operation_transpose: Solves A**T*x = b
            - rocblas_operation_conjugate_transpose: Solves A**H*x = b

    @param[in]
    diag    [rocblas_diagonal]
            - rocblas_diagonal_unit:     each A_i is assumed to be unit triangular (i.e. the diagonal elements
            of each A_i are not used in computations).
            - rocblas_diagonal_non_unit: each A_i is not assumed to be unit triangular.

    @param[in]
    n         [rocblas_int]
              n specifies the number of rows of each b_i. n >= 0.

    @param[in]
    AP        device pointer pointing to the first packed matrix A_1,
              of dimension >= (n * (n + 1) / 2).

    @param[in]
    stride_A  [rocblas_stride]
              stride from the beginning of one packed matrix (AP_i) and the next (AP_i+1).

    @param[in, out]
    x         device pointer pointing to the first input vector b_1. Overwritten by each x_i on output.

    @param[in]
    incx      [rocblas_int]
              specifies the increment for the elements of each x_i.
    @param[in]
    stride_x  [rocblas_stride]
              stride from the beginning of one vector (x_i) and the next (x_i+1).
    @param[in]
    batch_count [rocblas_int]
                specifies the number of instances in the batch.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_stpsv_strided_batched",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int32,
            UnsafePointer[Float32],
            Int64,
            UnsafePointer[Float32],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        uplo,
        trans_a,
        diag,
        n,
        _ap,
        stride__a,
        x,
        incx,
        stride_x,
        batch_count,
    )


fn rocblas_dtrsv_strided_batched_64(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int64,
    _a: UnsafePointer[Float64],
    lda: Int64,
    stride__a: Int64,
    x: UnsafePointer[Float64],
    incx: Int64,
    stride_x: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_dtrsv_strided_batched_64",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int64,
            UnsafePointer[Float64],
            Int64,
            Int64,
            UnsafePointer[Float64],
            Int64,
            Int64,
            Int64,
        ) -> Status,
    ]()(
        handle,
        uplo,
        trans_a,
        diag,
        n,
        _a,
        lda,
        stride__a,
        x,
        incx,
        stride_x,
        batch_count,
    )


fn rocblas_zcopy_strided_batched(
    handle: Handle,
    n: Int32,
    x: UnsafePointer[ComplexFloat64],
    incx: Int32,
    stridex: Int64,
    y: UnsafePointer[ComplexFloat64],
    incy: Int32,
    stridey: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_zcopy_strided_batched",
        fn (
            Handle,
            Int32,
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(handle, n, x, incx, stridex, y, incy, stridey, batch_count)


fn rocblas_crotg_strided_batched_64(
    handle: Handle,
    a: UnsafePointer[ComplexFloat32],
    stride_a: Int64,
    b: UnsafePointer[ComplexFloat32],
    stride_b: Int64,
    c: UnsafePointer[Float32],
    stride_c: Int64,
    s: UnsafePointer[ComplexFloat32],
    stride_s: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_crotg_strided_batched_64",
        fn (
            Handle,
            UnsafePointer[ComplexFloat32],
            Int64,
            UnsafePointer[ComplexFloat32],
            Int64,
            UnsafePointer[Float32],
            Int64,
            UnsafePointer[ComplexFloat32],
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, a, stride_a, b, stride_b, c, stride_c, s, stride_s, batch_count)


fn rocblas_zgbmv_batched(
    handle: Handle,
    trans: Operation,
    m: Int32,
    n: Int32,
    kl: Int32,
    ku: Int32,
    alpha: UnsafePointer[ComplexFloat64],
    _a: OpaquePointer,
    lda: Int32,
    x: OpaquePointer,
    incx: Int32,
    beta: UnsafePointer[ComplexFloat64],
    y: OpaquePointer,
    incy: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_zgbmv_batched",
        fn (
            Handle,
            Operation,
            Int32,
            Int32,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat64],
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            UnsafePointer[ComplexFloat64],
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(
        handle,
        trans,
        m,
        n,
        kl,
        ku,
        alpha,
        _a,
        lda,
        x,
        incx,
        beta,
        y,
        incy,
        batch_count,
    )


fn rocblas_dcopy_strided_batched(
    handle: Handle,
    n: Int32,
    x: UnsafePointer[Float64],
    incx: Int32,
    stridex: Int64,
    y: UnsafePointer[Float64],
    incy: Int32,
    stridey: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_dcopy_strided_batched",
        fn (
            Handle,
            Int32,
            UnsafePointer[Float64],
            Int32,
            Int64,
            UnsafePointer[Float64],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(handle, n, x, incx, stridex, y, incy, stridey, batch_count)


fn rocblas_zrotg_64(
    handle: Handle,
    a: UnsafePointer[ComplexFloat64],
    b: UnsafePointer[ComplexFloat64],
    c: UnsafePointer[Float64],
    s: UnsafePointer[ComplexFloat64],
) -> Status:
    return _get_dylib_function[
        "rocblas_zrotg_64",
        fn (
            Handle,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            UnsafePointer[Float64],
            UnsafePointer[ComplexFloat64],
        ) -> Status,
    ]()(handle, a, b, c, s)


fn rocblas_cdotu_batched(
    handle: Handle,
    n: Int32,
    x: OpaquePointer,
    incx: Int32,
    y: OpaquePointer,
    incy: Int32,
    batch_count: Int32,
    result: UnsafePointer[ComplexFloat32],
) -> Status:
    return _get_dylib_function[
        "rocblas_cdotu_batched",
        fn (
            Handle,
            Int32,
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat32],
        ) -> Status,
    ]()(handle, n, x, incx, y, incy, batch_count, result)


fn rocblas_saxpy_64(
    handle: Handle,
    n: Int64,
    alpha: UnsafePointer[Float32],
    x: UnsafePointer[Float32],
    incx: Int64,
    y: UnsafePointer[Float32],
    incy: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_saxpy_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int64,
            UnsafePointer[Float32],
            Int64,
        ) -> Status,
    ]()(handle, n, alpha, x, incx, y, incy)


fn rocblas_chpmv_batched(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat32],
    _ap: OpaquePointer,
    x: OpaquePointer,
    incx: Int32,
    beta: UnsafePointer[ComplexFloat32],
    y: OpaquePointer,
    incy: Int32,
    batch_count: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 2 API </b>.

    \\details
    hpmv_batched performs the matrix-vector operation:

        y_i := alpha*A_i*x_i + beta*y_i
        where alpha and beta are scalars, x_i and y_i are n element vectors and A_i is an
        n by n Hermitian matrix, supplied in packed form (see description below),
        for each batch in i = [1, batch_count].

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    uplo      [rocblas_fill]
            - rocblas_fill_upper: the upper triangular part of each Hermitian matrix A_i is supplied in AP.
            - rocblas_fill_lower: the lower triangular part of each Hermitian matrix A_i is supplied in AP.
    @param[in]
    n         [rocblas_int]
              the order of each matrix A_i.
    @param[in]
    alpha     device pointer or host pointer to scalar alpha.
    @param[in]
    AP      device pointer of device pointers storing the packed version of the specified triangular
            portion of each Hermitian matrix A_i. Each A_i is of at least size ((n * (n + 1)) / 2).

                    if uplo == rocblas_fill_upper:
                        The upper triangular portion of each Hermitian matrix A_i is supplied.
                        The matrix is compacted so that each AP_i contains the triangular portion
                        column-by-column
                        so that:
                        AP(0) = A(0,0)
                        AP(1) = A(0,1)
                        AP(2) = A(1,1), etc.
                        Ex: (rocblas_fill_upper; n = 3)
                            (1, 0) (2, 1) (3, 2)
                            (2,-1) (4, 0) (5,-1) ---> [(1,0),(2,1),(4,0),(3,2),(5,-1),(6,0)]
                            (3,-2) (5, 1) (6, 0)

                    if uplo == rocblas_fill_lower:
                        The lower triangular portion of each Hermitian matrix A_i is supplied.
                        The matrix is compacted so that each AP_i contains the triangular portion
                        column-by-column
                        so that:
                        AP(0) = A(0,0)
                        AP(1) = A(1,0)
                        AP(2) = A(2,1), etc.
                        Ex: (rocblas_fill_lower; n = 3)
                            (1, 0) (2, 1) (3, 2)
                            (2,-1) (4, 0) (5,-1) ---> [(1,0),(2,-1),(3,-2),(4,0),(5,1),(6,0)]
                            (3,-2) (5, 1) (6, 0)
                    Note that the imaginary part of the diagonal elements are not accessed
                    and are assumed to be 0.
    @param[in]
    x         device array of device pointers storing each vector x_i.
    @param[in]
    incx      [rocblas_int]
              specifies the increment for the elements of each x_i.
    @param[in]
    beta      device pointer or host pointer to scalar beta.
    @param[in, out]
    y         device array of device pointers storing each vector y_i.
    @param[in]
    incy      [rocblas_int]
              specifies the increment for the elements of y.
    @param[in]
    batch_count [rocblas_int]
                number of instances in the batch.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_chpmv_batched",
        fn (
            Handle,
            Fill,
            Int32,
            UnsafePointer[ComplexFloat32],
            OpaquePointer,
            OpaquePointer,
            Int32,
            UnsafePointer[ComplexFloat32],
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(handle, uplo, n, alpha, _ap, x, incx, beta, y, incy, batch_count)


fn rocblas_srotmg_batched(
    handle: Handle,
    d1: OpaquePointer,
    d2: OpaquePointer,
    x1: OpaquePointer,
    y1: OpaquePointer,
    param: OpaquePointer,
    batch_count: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 1 API </b>.

    \\details
    rotmg_batched creates the modified Givens rotation matrix for the batched vectors (d1_i * x1_i, d2_i * y1_i), for i = 1, ..., batch_count.
          Parameters may be stored in either host or device memory. Location is specified by calling rocblas_set_pointer_mode:

    - If the pointer mode is set to rocblas_pointer_mode_host, then this function blocks the CPU until the GPU has finished and the results are available in host memory.
    - If the pointer mode is set to rocblas_pointer_mode_device, then this function returns immediately and synchronization is required to read the results.

    @param[in]
    handle  [rocblas_handle]
            handle to the rocblas library context queue.
    @param[in, out]
    d1      device batched array or host batched array of input scalars that is overwritten.
    @param[in, out]
    d2      device batched array or host batched array of input scalars that is overwritten.
    @param[in, out]
    x1      device batched array or host batched array of input scalars that is overwritten.
    @param[in]
    y1      device batched array or host batched array of input scalars.
    @param[out]
    param   device batched array or host batched array of vectors of 5 elements defining the rotation.

        param[0] = flag
        param[1] = H11
        param[2] = H21
        param[3] = H12
        param[4] = H22

        The flag parameter defines the form of H:

        flag = -1 => H = ( H11 H12 H21 H22 )
        flag =  0 => H = ( 1.0 H12 H21 1.0 )
        flag =  1 => H = ( H11 1.0 -1.0 H22 )
        flag = -2 => H = ( 1.0 0.0 0.0 1.0 )

        param may be stored in either host or device memory.
        Location is specified by calling rocblas_set_pointer_mode.

    @param[in]
    batch_count [rocblas_int]
                the number of instances in the batch.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_srotmg_batched",
        fn (
            Handle,
            OpaquePointer,
            OpaquePointer,
            OpaquePointer,
            OpaquePointer,
            OpaquePointer,
            Int32,
        ) -> Status,
    ]()(handle, d1, d2, x1, y1, param, batch_count)


fn rocblas_ssymv_batched_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    alpha: UnsafePointer[Float32],
    _a: OpaquePointer,
    lda: Int64,
    x: OpaquePointer,
    incx: Int64,
    beta: UnsafePointer[Float32],
    y: OpaquePointer,
    incy: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_ssymv_batched_64",
        fn (
            Handle,
            Fill,
            Int64,
            UnsafePointer[Float32],
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            UnsafePointer[Float32],
            OpaquePointer,
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, uplo, n, alpha, _a, lda, x, incx, beta, y, incy, batch_count)


fn rocblas_drotmg(
    handle: Handle,
    d1: UnsafePointer[Float64],
    d2: UnsafePointer[Float64],
    x1: UnsafePointer[Float64],
    y1: UnsafePointer[Float64],
    param: UnsafePointer[Float64],
) -> Status:
    return _get_dylib_function[
        "rocblas_drotmg",
        fn (
            Handle,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            UnsafePointer[Float64],
        ) -> Status,
    ]()(handle, d1, d2, x1, y1, param)


fn rocblas_daxpy_strided_batched_64(
    handle: Handle,
    n: Int64,
    alpha: UnsafePointer[Float64],
    x: UnsafePointer[Float64],
    incx: Int64,
    stridex: Int64,
    y: UnsafePointer[Float64],
    incy: Int64,
    stridey: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_daxpy_strided_batched_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int64,
            Int64,
            UnsafePointer[Float64],
            Int64,
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, n, alpha, x, incx, stridex, y, incy, stridey, batch_count)


fn rocblas_scal_strided_batched_ex_64(
    handle: Handle,
    n: Int64,
    alpha: OpaquePointer,
    alpha_type: DataType,
    x: OpaquePointer,
    x_type: DataType,
    incx: Int64,
    stridex: Int64,
    batch_count: Int64,
    execution_type: DataType,
) -> Status:
    return _get_dylib_function[
        "rocblas_scal_strided_batched_ex_64",
        fn (
            Handle,
            Int64,
            OpaquePointer,
            DataType,
            OpaquePointer,
            DataType,
            Int64,
            Int64,
            Int64,
            DataType,
        ) -> Status,
    ]()(
        handle,
        n,
        alpha,
        alpha_type,
        x,
        x_type,
        incx,
        stridex,
        batch_count,
        execution_type,
    )


fn rocblas_dotc_strided_batched_ex_64(
    handle: Handle,
    n: Int64,
    x: OpaquePointer,
    x_type: DataType,
    incx: Int64,
    stride_x: Int64,
    y: OpaquePointer,
    y_type: DataType,
    incy: Int64,
    stride_y: Int64,
    batch_count: Int64,
    result: OpaquePointer,
    result_type: DataType,
    execution_type: DataType,
) -> Status:
    return _get_dylib_function[
        "rocblas_dotc_strided_batched_ex_64",
        fn (
            Handle,
            Int64,
            OpaquePointer,
            DataType,
            Int64,
            Int64,
            OpaquePointer,
            DataType,
            Int64,
            Int64,
            Int64,
            OpaquePointer,
            DataType,
            DataType,
        ) -> Status,
    ]()(
        handle,
        n,
        x,
        x_type,
        incx,
        stride_x,
        y,
        y_type,
        incy,
        stride_y,
        batch_count,
        result,
        result_type,
        execution_type,
    )


fn rocblas_caxpy_64(
    handle: Handle,
    n: Int64,
    alpha: UnsafePointer[ComplexFloat32],
    x: UnsafePointer[ComplexFloat32],
    incx: Int64,
    y: UnsafePointer[ComplexFloat32],
    incy: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_caxpy_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int64,
            UnsafePointer[ComplexFloat32],
            Int64,
        ) -> Status,
    ]()(handle, n, alpha, x, incx, y, incy)


fn rocblas_dgemm_strided_batched(
    handle: Handle,
    trans_a: Operation,
    trans_b: Operation,
    m: Int32,
    n: Int32,
    k: Int32,
    alpha: UnsafePointer[Float64],
    _a: UnsafePointer[Float64],
    lda: Int32,
    stride_a: Int64,
    _b: UnsafePointer[Float64],
    ldb: Int32,
    stride_b: Int64,
    beta: UnsafePointer[Float64],
    _c: UnsafePointer[Float64],
    ldc: Int32,
    stride_c: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_dgemm_strided_batched",
        fn (
            Handle,
            Operation,
            Operation,
            Int32,
            Int32,
            Int32,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int32,
            Int64,
            UnsafePointer[Float64],
            Int32,
            Int64,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        trans_a,
        trans_b,
        m,
        n,
        k,
        alpha,
        _a,
        lda,
        stride_a,
        _b,
        ldb,
        stride_b,
        beta,
        _c,
        ldc,
        stride_c,
        batch_count,
    )


fn rocblas_cdotu_strided_batched(
    handle: Handle,
    n: Int32,
    x: UnsafePointer[ComplexFloat32],
    incx: Int32,
    stridex: Int64,
    y: UnsafePointer[ComplexFloat32],
    incy: Int32,
    stridey: Int64,
    batch_count: Int32,
    result: UnsafePointer[ComplexFloat32],
) -> Status:
    return _get_dylib_function[
        "rocblas_cdotu_strided_batched",
        fn (
            Handle,
            Int32,
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            Int32,
            UnsafePointer[ComplexFloat32],
        ) -> Status,
    ]()(handle, n, x, incx, stridex, y, incy, stridey, batch_count, result)


fn rocblas_ctpsv_batched(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int32,
    _ap: OpaquePointer,
    x: OpaquePointer,
    incx: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_ctpsv_batched",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int32,
            OpaquePointer,
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(handle, uplo, trans_a, diag, n, _ap, x, incx, batch_count)


fn rocblas_zherkx_batched(
    handle: Handle,
    uplo: Fill,
    trans: Operation,
    n: Int32,
    k: Int32,
    alpha: UnsafePointer[ComplexFloat64],
    _a: OpaquePointer,
    lda: Int32,
    _b: OpaquePointer,
    ldb: Int32,
    beta: UnsafePointer[Float64],
    _c: OpaquePointer,
    ldc: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_zherkx_batched",
        fn (
            Handle,
            Fill,
            Operation,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat64],
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            UnsafePointer[Float64],
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(
        handle,
        uplo,
        trans,
        n,
        k,
        alpha,
        _a,
        lda,
        _b,
        ldb,
        beta,
        _c,
        ldc,
        batch_count,
    )


fn rocblas_haxpy(
    handle: Handle,
    n: Int32,
    alpha: UnsafePointer[Float16],
    x: UnsafePointer[Float16],
    incx: Int32,
    y: UnsafePointer[Float16],
    incy: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 1 API </b>.

    \\details
    axpy   computes constant alpha multiplied by vector x, plus vector y:

        y := alpha * x + y

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    n         [rocblas_int]
              the number of elements in x and y.
    @param[in]
    alpha     device pointer or host pointer to specify the scalar alpha.
    @param[in]
    x         device pointer storing vector x.
    @param[in]
    incx      [rocblas_int]
              specifies the increment for the elements of x.
    @param[out]
    y         device pointer storing vector y.
    @param[in, out]
    incy      [rocblas_int]
              specifies the increment for the elements of y.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_haxpy",
        fn (
            Handle,
            Int32,
            UnsafePointer[Float16],
            UnsafePointer[Float16],
            Int32,
            UnsafePointer[Float16],
            Int32,
        ) -> Status,
    ]()(handle, n, alpha, x, incx, y, incy)


fn rocblas_dsyr2(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    alpha: UnsafePointer[Float64],
    x: UnsafePointer[Float64],
    incx: Int32,
    y: UnsafePointer[Float64],
    incy: Int32,
    _a: UnsafePointer[Float64],
    lda: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_dsyr2",
        fn (
            Handle,
            Fill,
            Int32,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int32,
            UnsafePointer[Float64],
            Int32,
            UnsafePointer[Float64],
            Int32,
        ) -> Status,
    ]()(handle, uplo, n, alpha, x, incx, y, incy, _a, lda)


fn rocblas_dtpmv(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int32,
    _a: UnsafePointer[Float64],
    x: UnsafePointer[Float64],
    incx: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_dtpmv",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int32,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int32,
        ) -> Status,
    ]()(handle, uplo, trans_a, diag, n, _a, x, incx)


fn rocblas_nrm2_batched_ex_64(
    handle: Handle,
    n: Int64,
    x: OpaquePointer,
    x_type: DataType,
    incx: Int64,
    batch_count: Int64,
    results: OpaquePointer,
    result_type: DataType,
    execution_type: DataType,
) -> Status:
    return _get_dylib_function[
        "rocblas_nrm2_batched_ex_64",
        fn (
            Handle,
            Int64,
            OpaquePointer,
            DataType,
            Int64,
            Int64,
            OpaquePointer,
            DataType,
            DataType,
        ) -> Status,
    ]()(
        handle,
        n,
        x,
        x_type,
        incx,
        batch_count,
        results,
        result_type,
        execution_type,
    )


fn rocblas_zdotc_strided_batched(
    handle: Handle,
    n: Int32,
    x: UnsafePointer[ComplexFloat64],
    incx: Int32,
    stridex: Int64,
    y: UnsafePointer[ComplexFloat64],
    incy: Int32,
    stridey: Int64,
    batch_count: Int32,
    result: UnsafePointer[ComplexFloat64],
) -> Status:
    return _get_dylib_function[
        "rocblas_zdotc_strided_batched",
        fn (
            Handle,
            Int32,
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            Int32,
            UnsafePointer[ComplexFloat64],
        ) -> Status,
    ]()(handle, n, x, incx, stridex, y, incy, stridey, batch_count, result)


fn rocblas_ssyr_strided_batched_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    alpha: UnsafePointer[Float32],
    x: UnsafePointer[Float32],
    incx: Int64,
    stridex: Int64,
    _a: UnsafePointer[Float32],
    lda: Int64,
    stride_a: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_ssyr_strided_batched_64",
        fn (
            Handle,
            Fill,
            Int64,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int64,
            Int64,
            UnsafePointer[Float32],
            Int64,
            Int64,
            Int64,
        ) -> Status,
    ]()(
        handle, uplo, n, alpha, x, incx, stridex, _a, lda, stride_a, batch_count
    )


fn rocblas_idamax_strided_batched(
    handle: Handle,
    n: Int32,
    x: UnsafePointer[Float64],
    incx: Int32,
    stridex: Int64,
    batch_count: Int32,
    result: UnsafePointer[Int32],
) -> Status:
    return _get_dylib_function[
        "rocblas_idamax_strided_batched",
        fn (
            Handle,
            Int32,
            UnsafePointer[Float64],
            Int32,
            Int64,
            Int32,
            UnsafePointer[Int32],
        ) -> Status,
    ]()(handle, n, x, incx, stridex, batch_count, result)


fn rocblas_ztrmm(
    handle: Handle,
    side: Side,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    m: Int32,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat64],
    _a: UnsafePointer[ComplexFloat64],
    lda: Int32,
    _b: UnsafePointer[ComplexFloat64],
    ldb: Int32,
    _c: UnsafePointer[ComplexFloat64],
    ldc: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_ztrmm",
        fn (
            Handle,
            Side,
            Fill,
            Operation,
            Diagonal,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int32,
            UnsafePointer[ComplexFloat64],
            Int32,
            UnsafePointer[ComplexFloat64],
            Int32,
        ) -> Status,
    ]()(
        handle,
        side,
        uplo,
        trans_a,
        diag,
        m,
        n,
        alpha,
        _a,
        lda,
        _b,
        ldb,
        _c,
        ldc,
    )


fn rocblas_csyrk_strided_batched(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    n: Int32,
    k: Int32,
    alpha: UnsafePointer[ComplexFloat32],
    _a: UnsafePointer[ComplexFloat32],
    lda: Int32,
    stride__a: Int64,
    beta: UnsafePointer[ComplexFloat32],
    _c: UnsafePointer[ComplexFloat32],
    ldc: Int32,
    stride__c: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_csyrk_strided_batched",
        fn (
            Handle,
            Fill,
            Operation,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        uplo,
        trans_a,
        n,
        k,
        alpha,
        _a,
        lda,
        stride__a,
        beta,
        _c,
        ldc,
        stride__c,
        batch_count,
    )


fn rocblas_csrot_64(
    handle: Handle,
    n: Int64,
    x: UnsafePointer[ComplexFloat32],
    incx: Int64,
    y: UnsafePointer[ComplexFloat32],
    incy: Int64,
    c: UnsafePointer[Float32],
    s: UnsafePointer[Float32],
) -> Status:
    return _get_dylib_function[
        "rocblas_csrot_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int64,
            UnsafePointer[ComplexFloat32],
            Int64,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
        ) -> Status,
    ]()(handle, n, x, incx, y, incy, c, s)


fn rocblas_dtrsm_batched(
    handle: Handle,
    side: Side,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    m: Int32,
    n: Int32,
    alpha: UnsafePointer[Float64],
    _a: OpaquePointer,
    lda: Int32,
    _b: OpaquePointer,
    ldb: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_dtrsm_batched",
        fn (
            Handle,
            Side,
            Fill,
            Operation,
            Diagonal,
            Int32,
            Int32,
            UnsafePointer[Float64],
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(
        handle,
        side,
        uplo,
        trans_a,
        diag,
        m,
        n,
        alpha,
        _a,
        lda,
        _b,
        ldb,
        batch_count,
    )


fn rocblas_hdot_batched_64(
    handle: Handle,
    n: Int64,
    x: OpaquePointer,
    incx: Int64,
    y: OpaquePointer,
    incy: Int64,
    batch_count: Int64,
    result: UnsafePointer[Float16],
) -> Status:
    return _get_dylib_function[
        "rocblas_hdot_batched_64",
        fn (
            Handle,
            Int64,
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            Int64,
            UnsafePointer[Float16],
        ) -> Status,
    ]()(handle, n, x, incx, y, incy, batch_count, result)


fn rocblas_ssbmv(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    k: Int32,
    alpha: UnsafePointer[Float32],
    _a: UnsafePointer[Float32],
    lda: Int32,
    x: UnsafePointer[Float32],
    incx: Int32,
    beta: UnsafePointer[Float32],
    y: UnsafePointer[Float32],
    incy: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 2 API </b>.

    \\details
    sbmv performs the matrix-vector operation:

        y := alpha*A*x + beta*y
        where alpha and beta are scalars, x and y are n element vectors and
        A should contain an upper or lower triangular n by n symmetric banded matrix.

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    uplo      rocblas_fill
            specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
            - if rocblas_fill_upper, the lower part of A is not referenced
            - if rocblas_fill_lower, the upper part of A is not referenced
    @param[in]
    n         [rocblas_int]
    @param[in]
    k         [rocblas_int]
              specifies the number of sub- and super-diagonals.
    @param[in]
    alpha
              specifies the scalar alpha.
    @param[in]
    A         pointer storing matrix A on the GPU.
    @param[in]
    lda       [rocblas_int]
              specifies the leading dimension of matrix A.
    @param[in]
    x         pointer storing vector x on the GPU.
    @param[in]
    incx      [rocblas_int]
              specifies the increment for the elements of x.
    @param[in]
    beta      specifies the scalar beta.
    @param[out]
    y         pointer storing vector y on the GPU.
    @param[in]
    incy      [rocblas_int]
              specifies the increment for the elements of y.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_ssbmv",
        fn (
            Handle,
            Fill,
            Int32,
            Int32,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int32,
            UnsafePointer[Float32],
            Int32,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int32,
        ) -> Status,
    ]()(handle, uplo, n, k, alpha, _a, lda, x, incx, beta, y, incy)


fn rocblas_drotm(
    handle: Handle,
    n: Int32,
    x: UnsafePointer[Float64],
    incx: Int32,
    y: UnsafePointer[Float64],
    incy: Int32,
    param: UnsafePointer[Float64],
) -> Status:
    return _get_dylib_function[
        "rocblas_drotm",
        fn (
            Handle,
            Int32,
            UnsafePointer[Float64],
            Int32,
            UnsafePointer[Float64],
            Int32,
            UnsafePointer[Float64],
        ) -> Status,
    ]()(handle, n, x, incx, y, incy, param)


fn rocblas_chemv_batched_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    alpha: UnsafePointer[ComplexFloat32],
    _a: OpaquePointer,
    lda: Int64,
    x: OpaquePointer,
    incx: Int64,
    beta: UnsafePointer[ComplexFloat32],
    y: OpaquePointer,
    incy: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_chemv_batched_64",
        fn (
            Handle,
            Fill,
            Int64,
            UnsafePointer[ComplexFloat32],
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            UnsafePointer[ComplexFloat32],
            OpaquePointer,
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, uplo, n, alpha, _a, lda, x, incx, beta, y, incy, batch_count)


fn rocblas_zgerc_strided_batched_64(
    handle: Handle,
    m: Int64,
    n: Int64,
    alpha: UnsafePointer[ComplexFloat64],
    x: UnsafePointer[ComplexFloat64],
    incx: Int64,
    stridex: Int64,
    y: UnsafePointer[ComplexFloat64],
    incy: Int64,
    stridey: Int64,
    _a: UnsafePointer[ComplexFloat64],
    lda: Int64,
    stride_a: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_zgerc_strided_batched_64",
        fn (
            Handle,
            Int64,
            Int64,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int64,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int64,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int64,
            Int64,
            Int64,
        ) -> Status,
    ]()(
        handle,
        m,
        n,
        alpha,
        x,
        incx,
        stridex,
        y,
        incy,
        stridey,
        _a,
        lda,
        stride_a,
        batch_count,
    )


fn rocblas_strmv_strided_batched_64(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int64,
    _a: UnsafePointer[Float32],
    lda: Int64,
    stride__a: Int64,
    x: UnsafePointer[Float32],
    incx: Int64,
    stride_x: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_strmv_strided_batched_64",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int64,
            UnsafePointer[Float32],
            Int64,
            Int64,
            UnsafePointer[Float32],
            Int64,
            Int64,
            Int64,
        ) -> Status,
    ]()(
        handle,
        uplo,
        trans_a,
        diag,
        n,
        _a,
        lda,
        stride__a,
        x,
        incx,
        stride_x,
        batch_count,
    )


fn rocblas_cspr_strided_batched_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    alpha: UnsafePointer[ComplexFloat32],
    x: UnsafePointer[ComplexFloat32],
    incx: Int64,
    stride_x: Int64,
    _ap: UnsafePointer[ComplexFloat32],
    stride__a: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_cspr_strided_batched_64",
        fn (
            Handle,
            Fill,
            Int64,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int64,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, uplo, n, alpha, x, incx, stride_x, _ap, stride__a, batch_count)


fn rocblas_sgemv_64(
    handle: Handle,
    trans: Operation,
    m: Int64,
    n: Int64,
    alpha: UnsafePointer[Float32],
    _a: UnsafePointer[Float32],
    lda: Int64,
    x: UnsafePointer[Float32],
    incx: Int64,
    beta: UnsafePointer[Float32],
    y: UnsafePointer[Float32],
    incy: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_sgemv_64",
        fn (
            Handle,
            Operation,
            Int64,
            Int64,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int64,
            UnsafePointer[Float32],
            Int64,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int64,
        ) -> Status,
    ]()(handle, trans, m, n, alpha, _a, lda, x, incx, beta, y, incy)


fn rocblas_csscal_batched_64(
    handle: Handle,
    n: Int64,
    alpha: UnsafePointer[Float32],
    x: OpaquePointer,
    incx: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_csscal_batched_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[Float32],
            OpaquePointer,
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, n, alpha, x, incx, batch_count)


fn rocblas_dsbmv_strided_batched_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    k: Int64,
    alpha: UnsafePointer[Float64],
    _a: UnsafePointer[Float64],
    lda: Int64,
    stride_a: Int64,
    x: UnsafePointer[Float64],
    incx: Int64,
    stridex: Int64,
    beta: UnsafePointer[Float64],
    y: UnsafePointer[Float64],
    incy: Int64,
    stridey: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_dsbmv_strided_batched_64",
        fn (
            Handle,
            Fill,
            Int64,
            Int64,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int64,
            Int64,
            UnsafePointer[Float64],
            Int64,
            Int64,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int64,
            Int64,
            Int64,
        ) -> Status,
    ]()(
        handle,
        uplo,
        n,
        k,
        alpha,
        _a,
        lda,
        stride_a,
        x,
        incx,
        stridex,
        beta,
        y,
        incy,
        stridey,
        batch_count,
    )


fn rocblas_sdgmm(
    handle: Handle,
    side: Side,
    m: Int32,
    n: Int32,
    _a: UnsafePointer[Float32],
    lda: Int32,
    x: UnsafePointer[Float32],
    incx: Int32,
    _c: UnsafePointer[Float32],
    ldc: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 3 API </b>.

    \\details
    dgmm performs one of the matrix-matrix operations:

        C = A * diag(x) if side == rocblas_side_right
        C = diag(x) * A if side == rocblas_side_left

        where C and A are m by n dimensional matrices. diag( x ) is a diagonal matrix
        and x is vector of dimension n if side == rocblas_side_right and dimension m
        if side == rocblas_side_left.


    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    side      [rocblas_side]
              specifies the side of diag(x).
    @param[in]
    m         [rocblas_int]
              matrix dimension m.
    @param[in]
    n         [rocblas_int]
              matrix dimension n.
    @param[in]
    A         device pointer storing matrix A.
    @param[in]
    lda       [rocblas_int]
              specifies the leading dimension of A.
    @param[in]
    x         device pointer storing vector x.
    @param[in]
    incx      [rocblas_int]
              specifies the increment between values of x
    @param[in, out]
    C         device pointer storing matrix C.
    @param[in]
    ldc       [rocblas_int]
              specifies the leading dimension of C.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_sdgmm",
        fn (
            Handle,
            Side,
            Int32,
            Int32,
            UnsafePointer[Float32],
            Int32,
            UnsafePointer[Float32],
            Int32,
            UnsafePointer[Float32],
            Int32,
        ) -> Status,
    ]()(handle, side, m, n, _a, lda, x, incx, _c, ldc)


fn rocblas_dtbsv_strided_batched_64(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int64,
    k: Int64,
    _a: UnsafePointer[Float64],
    lda: Int64,
    stride__a: Int64,
    x: UnsafePointer[Float64],
    incx: Int64,
    stride_x: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_dtbsv_strided_batched_64",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int64,
            Int64,
            UnsafePointer[Float64],
            Int64,
            Int64,
            UnsafePointer[Float64],
            Int64,
            Int64,
            Int64,
        ) -> Status,
    ]()(
        handle,
        uplo,
        trans_a,
        diag,
        n,
        k,
        _a,
        lda,
        stride__a,
        x,
        incx,
        stride_x,
        batch_count,
    )


fn rocblas_chpr_batched_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    alpha: UnsafePointer[Float32],
    x: OpaquePointer,
    incx: Int64,
    _ap: OpaquePointer,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_chpr_batched_64",
        fn (
            Handle,
            Fill,
            Int64,
            UnsafePointer[Float32],
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
        ) -> Status,
    ]()(handle, uplo, n, alpha, x, incx, _ap, batch_count)


fn rocblas_cgbmv(
    handle: Handle,
    trans: Operation,
    m: Int32,
    n: Int32,
    kl: Int32,
    ku: Int32,
    alpha: UnsafePointer[ComplexFloat32],
    _a: UnsafePointer[ComplexFloat32],
    lda: Int32,
    x: UnsafePointer[ComplexFloat32],
    incx: Int32,
    beta: UnsafePointer[ComplexFloat32],
    y: UnsafePointer[ComplexFloat32],
    incy: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_cgbmv",
        fn (
            Handle,
            Operation,
            Int32,
            Int32,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int32,
            UnsafePointer[ComplexFloat32],
            Int32,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int32,
        ) -> Status,
    ]()(handle, trans, m, n, kl, ku, alpha, _a, lda, x, incx, beta, y, incy)


fn rocblas_cdotu_batched_64(
    handle: Handle,
    n: Int64,
    x: OpaquePointer,
    incx: Int64,
    y: OpaquePointer,
    incy: Int64,
    batch_count: Int64,
    result: UnsafePointer[ComplexFloat32],
) -> Status:
    return _get_dylib_function[
        "rocblas_cdotu_batched_64",
        fn (
            Handle,
            Int64,
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            Int64,
            UnsafePointer[ComplexFloat32],
        ) -> Status,
    ]()(handle, n, x, incx, y, incy, batch_count, result)


fn rocblas_srotm_batched(
    handle: Handle,
    n: Int32,
    x: OpaquePointer,
    incx: Int32,
    y: OpaquePointer,
    incy: Int32,
    param: OpaquePointer,
    batch_count: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 1 API </b>.

    \\details
    rotm_batched applies the modified Givens rotation matrix defined by param_i to batched vectors x_i and y_i, for i = 1, ..., batch_count.

    @param[in]
    handle  [rocblas_handle]
            handle to the rocblas library context queue.
    @param[in]
    n       [rocblas_int]
            number of elements in the x and y vectors.
    @param[in, out]
    x       device array of device pointers storing each vector x_i.
    @param[in]
    incx    [rocblas_int]
            specifies the increment between elements of each x_i.
    @param[in, out]
    y       device array of device pointers storing each vector y_1.
    @param[in]
    incy    [rocblas_int]
            specifies the increment between elements of each y_i.
    @param[in]
    param   device array of device vectors of 5 elements defining the rotation.

        param[0] = flag
        param[1] = H11
        param[2] = H21
        param[3] = H12
        param[4] = H22

        The flag parameter defines the form of H:

        flag = -1 => H = ( H11 H12 H21 H22 )
        flag =  0 => H = ( 1.0 H12 H21 1.0 )
        flag =  1 => H = ( H11 1.0 -1.0 H22 )
        flag = -2 => H = ( 1.0 0.0 0.0 1.0 )

        param may ONLY be stored on the device for the batched version of this function.

    @param[in]
    batch_count [rocblas_int]
                the number of x and y arrays, i.e. the number of batches.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_srotm_batched",
        fn (
            Handle,
            Int32,
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
        ) -> Status,
    ]()(handle, n, x, incx, y, incy, param, batch_count)


fn rocblas_zgeam(
    handle: Handle,
    trans_a: Operation,
    trans_b: Operation,
    m: Int32,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat64],
    _a: UnsafePointer[ComplexFloat64],
    lda: Int32,
    beta: UnsafePointer[ComplexFloat64],
    _b: UnsafePointer[ComplexFloat64],
    ldb: Int32,
    _c: UnsafePointer[ComplexFloat64],
    ldc: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_zgeam",
        fn (
            Handle,
            Operation,
            Operation,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int32,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int32,
            UnsafePointer[ComplexFloat64],
            Int32,
        ) -> Status,
    ]()(handle, trans_a, trans_b, m, n, alpha, _a, lda, beta, _b, ldb, _c, ldc)


fn rocblas_ctrsv(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int32,
    _a: UnsafePointer[ComplexFloat32],
    lda: Int32,
    x: UnsafePointer[ComplexFloat32],
    incx: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_ctrsv",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int32,
            UnsafePointer[ComplexFloat32],
            Int32,
            UnsafePointer[ComplexFloat32],
            Int32,
        ) -> Status,
    ]()(handle, uplo, trans_a, diag, n, _a, lda, x, incx)


fn rocblas_zgemv_strided_batched_64(
    handle: Handle,
    trans_a: Operation,
    m: Int64,
    n: Int64,
    alpha: UnsafePointer[ComplexFloat64],
    _a: UnsafePointer[ComplexFloat64],
    lda: Int64,
    stride_a: Int64,
    x: UnsafePointer[ComplexFloat64],
    incx: Int64,
    stridex: Int64,
    beta: UnsafePointer[ComplexFloat64],
    y: UnsafePointer[ComplexFloat64],
    incy: Int64,
    stridey: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_zgemv_strided_batched_64",
        fn (
            Handle,
            Operation,
            Int64,
            Int64,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int64,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int64,
            Int64,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int64,
            Int64,
            Int64,
        ) -> Status,
    ]()(
        handle,
        trans_a,
        m,
        n,
        alpha,
        _a,
        lda,
        stride_a,
        x,
        incx,
        stridex,
        beta,
        y,
        incy,
        stridey,
        batch_count,
    )


fn rocblas_zhbmv_batched_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    k: Int64,
    alpha: UnsafePointer[ComplexFloat64],
    _a: OpaquePointer,
    lda: Int64,
    x: OpaquePointer,
    incx: Int64,
    beta: UnsafePointer[ComplexFloat64],
    y: OpaquePointer,
    incy: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_zhbmv_batched_64",
        fn (
            Handle,
            Fill,
            Int64,
            Int64,
            UnsafePointer[ComplexFloat64],
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            UnsafePointer[ComplexFloat64],
            OpaquePointer,
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, uplo, n, k, alpha, _a, lda, x, incx, beta, y, incy, batch_count)


fn rocblas_zgemm(
    handle: Handle,
    trans_a: Operation,
    trans_b: Operation,
    m: Int32,
    n: Int32,
    k: Int32,
    alpha: UnsafePointer[ComplexFloat64],
    _a: UnsafePointer[ComplexFloat64],
    lda: Int32,
    _b: UnsafePointer[ComplexFloat64],
    ldb: Int32,
    beta: UnsafePointer[ComplexFloat64],
    _c: UnsafePointer[ComplexFloat64],
    ldc: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_zgemm",
        fn (
            Handle,
            Operation,
            Operation,
            Int32,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int32,
            UnsafePointer[ComplexFloat64],
            Int32,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int32,
        ) -> Status,
    ]()(
        handle,
        trans_a,
        trans_b,
        m,
        n,
        k,
        alpha,
        _a,
        lda,
        _b,
        ldb,
        beta,
        _c,
        ldc,
    )


fn rocblas_cspr_batched(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat32],
    x: OpaquePointer,
    incx: Int32,
    _ap: OpaquePointer,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_cspr_batched",
        fn (
            Handle,
            Fill,
            Int32,
            UnsafePointer[ComplexFloat32],
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
        ) -> Status,
    ]()(handle, uplo, n, alpha, x, incx, _ap, batch_count)


fn rocblas_zhemv_batched_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    alpha: UnsafePointer[ComplexFloat64],
    _a: OpaquePointer,
    lda: Int64,
    x: OpaquePointer,
    incx: Int64,
    beta: UnsafePointer[ComplexFloat64],
    y: OpaquePointer,
    incy: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_zhemv_batched_64",
        fn (
            Handle,
            Fill,
            Int64,
            UnsafePointer[ComplexFloat64],
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            UnsafePointer[ComplexFloat64],
            OpaquePointer,
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, uplo, n, alpha, _a, lda, x, incx, beta, y, incy, batch_count)


fn rocblas_cgemv_64(
    handle: Handle,
    trans: Operation,
    m: Int64,
    n: Int64,
    alpha: UnsafePointer[ComplexFloat32],
    _a: UnsafePointer[ComplexFloat32],
    lda: Int64,
    x: UnsafePointer[ComplexFloat32],
    incx: Int64,
    beta: UnsafePointer[ComplexFloat32],
    y: UnsafePointer[ComplexFloat32],
    incy: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_cgemv_64",
        fn (
            Handle,
            Operation,
            Int64,
            Int64,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int64,
            UnsafePointer[ComplexFloat32],
            Int64,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int64,
        ) -> Status,
    ]()(handle, trans, m, n, alpha, _a, lda, x, incx, beta, y, incy)


fn rocblas_dtrmv_strided_batched(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int32,
    _a: UnsafePointer[Float64],
    lda: Int32,
    stride__a: Int64,
    x: UnsafePointer[Float64],
    incx: Int32,
    stride_x: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_dtrmv_strided_batched",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int32,
            UnsafePointer[Float64],
            Int32,
            Int64,
            UnsafePointer[Float64],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        uplo,
        trans_a,
        diag,
        n,
        _a,
        lda,
        stride__a,
        x,
        incx,
        stride_x,
        batch_count,
    )


fn rocblas_drotmg_strided_batched(
    handle: Handle,
    d1: UnsafePointer[Float64],
    stride_d1: Int64,
    d2: UnsafePointer[Float64],
    stride_d2: Int64,
    x1: UnsafePointer[Float64],
    stride_x1: Int64,
    y1: UnsafePointer[Float64],
    stride_y1: Int64,
    param: UnsafePointer[Float64],
    stride_param: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_drotmg_strided_batched",
        fn (
            Handle,
            UnsafePointer[Float64],
            Int64,
            UnsafePointer[Float64],
            Int64,
            UnsafePointer[Float64],
            Int64,
            UnsafePointer[Float64],
            Int64,
            UnsafePointer[Float64],
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        d1,
        stride_d1,
        d2,
        stride_d2,
        x1,
        stride_x1,
        y1,
        stride_y1,
        param,
        stride_param,
        batch_count,
    )


fn rocblas_zgeru_batched(
    handle: Handle,
    m: Int32,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat64],
    x: OpaquePointer,
    incx: Int32,
    y: OpaquePointer,
    incy: Int32,
    _a: OpaquePointer,
    lda: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_zgeru_batched",
        fn (
            Handle,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat64],
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(handle, m, n, alpha, x, incx, y, incy, _a, lda, batch_count)


fn rocblas_daxpy_strided_batched(
    handle: Handle,
    n: Int32,
    alpha: UnsafePointer[Float64],
    x: UnsafePointer[Float64],
    incx: Int32,
    stridex: Int64,
    y: UnsafePointer[Float64],
    incy: Int32,
    stridey: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_daxpy_strided_batched",
        fn (
            Handle,
            Int32,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int32,
            Int64,
            UnsafePointer[Float64],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(handle, n, alpha, x, incx, stridex, y, incy, stridey, batch_count)


fn rocblas_crot(
    handle: Handle,
    n: Int32,
    x: UnsafePointer[ComplexFloat32],
    incx: Int32,
    y: UnsafePointer[ComplexFloat32],
    incy: Int32,
    c: UnsafePointer[Float32],
    s: UnsafePointer[ComplexFloat32],
) -> Status:
    return _get_dylib_function[
        "rocblas_crot",
        fn (
            Handle,
            Int32,
            UnsafePointer[ComplexFloat32],
            Int32,
            UnsafePointer[ComplexFloat32],
            Int32,
            UnsafePointer[Float32],
            UnsafePointer[ComplexFloat32],
        ) -> Status,
    ]()(handle, n, x, incx, y, incy, c, s)


fn rocblas_zhpr2_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    alpha: UnsafePointer[ComplexFloat64],
    x: UnsafePointer[ComplexFloat64],
    incx: Int64,
    y: UnsafePointer[ComplexFloat64],
    incy: Int64,
    _ap: UnsafePointer[ComplexFloat64],
) -> Status:
    return _get_dylib_function[
        "rocblas_zhpr2_64",
        fn (
            Handle,
            Fill,
            Int64,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int64,
            UnsafePointer[ComplexFloat64],
            Int64,
            UnsafePointer[ComplexFloat64],
        ) -> Status,
    ]()(handle, uplo, n, alpha, x, incx, y, incy, _ap)


fn rocblas_initialize() -> NoneType:
    """
    \\brief Initialize rocBLAS on the current HIP device, to avoid costly startup time at the first call on that device.

    \\details

    Calling `rocblas_initialize()` allows upfront initialization including device specific kernel setup.
    Otherwise this function is automatically called on the first function call that requires these initializations (mainly GEMM).

    ****************************************************************************.
    """
    return _get_dylib_function["rocblas_initialize", fn () -> NoneType]()()


fn rocblas_drotm_strided_batched(
    handle: Handle,
    n: Int32,
    x: UnsafePointer[Float64],
    incx: Int32,
    stride_x: Int64,
    y: UnsafePointer[Float64],
    incy: Int32,
    stride_y: Int64,
    param: UnsafePointer[Float64],
    stride_param: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_drotm_strided_batched",
        fn (
            Handle,
            Int32,
            UnsafePointer[Float64],
            Int32,
            Int64,
            UnsafePointer[Float64],
            Int32,
            Int64,
            UnsafePointer[Float64],
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        n,
        x,
        incx,
        stride_x,
        y,
        incy,
        stride_y,
        param,
        stride_param,
        batch_count,
    )


fn rocblas_sgemmt_strided_batched(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    trans_b: Operation,
    n: Int32,
    k: Int32,
    alpha: UnsafePointer[Float32],
    _a: UnsafePointer[Float32],
    lda: Int32,
    stride_a: Int64,
    _b: UnsafePointer[Float32],
    ldb: Int32,
    stride_b: Int64,
    beta: UnsafePointer[Float32],
    _c: UnsafePointer[Float32],
    ldc: Int32,
    stride_c: Int64,
    batch_count: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 3 API </b>.

    \\details
    gemmt_strided_batched performs matrix-matrix operations and updates the upper or lower triangular part of the result matrix:

        C_i = alpha*op( A_i )*op( B_i ) + beta*C_i, for i = 1, ..., batch_count,

        where op( X ) is one of

        op( X ) = X      or
        op( X ) = X**T   or
        op( X ) = X**H,

        alpha and beta are scalars. A, B  are general matrices and C is either an upper or lower triangular matrix, with
        op( A ) an n by k by batch_count strided_batched matrix,
        op( B ) an k by n by batch_count strided_batched matrix and
        C an n by n by batch_count strided_batched matrix.

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    uplo    [rocblas_fill]
            - rocblas_fill_upper:  C is an upper triangular matrix
            - rocblas_fill_lower:  C is a  lower triangular matrix
    @param[in]
    transA    [rocblas_operation]
            - rocblas_operation_none:    op(A_i) = A_i.
            - rocblas_operation_transpose:      op(A_i) = A_i^T
            - rocblas_operation_conjugate_transpose:  op(A_i) = A_i^H
    @param[in]
    transB    [rocblas_operation]
            - rocblas_operation_none:    op(B_i) = B_i.
            - rocblas_operation_transpose:      op(B_i) = B_i^T
            - rocblas_operation_conjugate_transpose:  op(B_i) = B_i^H
    @param[in]
    n         [rocblas_int]
              number or rows of matrices op( A_i ), columns of op( B_i ), and (rows, columns) of C_i.
    @param[in]
    k         [rocblas_int]
              number of rows of matrices op( B_i ) and columns of op( A_i ).
    @param[in]
    alpha     device pointer or host pointer specifying the scalar alpha.
    @param[in]
    A         device array of device pointers storing each matrix A_i. If transa = rocblas_operation_none, then, the leading n-by-k part of the array contains each matrix A_i, otherwise the leading k-by-n part of the array contains each matrix A_i.
    @param[in]
    lda       [rocblas_int]
              specifies the leading dimension of each A_i. If transA == rocblas_operation_none, must have lda >= max(1, n), otherwise, must have lda >= max(1, k).
    @param[in]
    stride_a  [rocblas_stride]
              stride from the start of one A_i matrix to the next A_(i + 1).
    @param[in]
    B         device array of device pointers storing each matrix B_i. If transB = rocblas_operation_none, then, the leading k-by-n part of the array contains each matrix B_i, otherwise the leading n-by-k part of the array contains each matrix B_i.
    @param[in]
    ldb       [rocblas_int]
              specifies the leading dimension of each B_i. If transB == rocblas_operation_none, must have ldb >= max(1, k), otherwise, must have ldb >= max(1, n).
    @param[in]
    stride_b  [rocblas_stride]
              stride from the start of one B_i matrix to the next B_(i + 1).
    @param[in]
    beta      device pointer or host pointer specifying the scalar beta.
    @param[in, out]
    C         device array of device pointers storing each matrix C_i. If uplo == rocblas_fill_upper, the upper triangular part of the leading n-by-n array contains each matrix C_i, otherwise the lower triangular part of the leading n-by-n array contains each matrix C_i.
    @param[in]
    ldc       [rocblas_int]
              specifies the leading dimension of each C_i. Must have ldc >= max(1, n).
    @param[in]
    stride_c  [rocblas_stride]
              stride from the start of one C_i matrix to the next C_(i + 1).
    @param[in]
    batch_count
              [rocblas_int]
              number of gemm operations in the batch.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_sgemmt_strided_batched",
        fn (
            Handle,
            Fill,
            Operation,
            Operation,
            Int32,
            Int32,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int32,
            Int64,
            UnsafePointer[Float32],
            Int32,
            Int64,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        uplo,
        trans_a,
        trans_b,
        n,
        k,
        alpha,
        _a,
        lda,
        stride_a,
        _b,
        ldb,
        stride_b,
        beta,
        _c,
        ldc,
        stride_c,
        batch_count,
    )


fn rocblas_dtpmv_batched(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int32,
    _a: UnsafePointer[UnsafePointer[Float64]],
    x: UnsafePointer[UnsafePointer[Float64]],
    incx: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_dtpmv_batched",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int32,
            UnsafePointer[UnsafePointer[Float64]],
            UnsafePointer[UnsafePointer[Float64]],
            Int32,
            Int32,
        ) -> Status,
    ]()(handle, uplo, trans_a, diag, n, _a, x, incx, batch_count)


fn rocblas_dasum(
    handle: Handle,
    n: Int32,
    x: UnsafePointer[Float64],
    incx: Int32,
    result: UnsafePointer[Float64],
) -> Status:
    return _get_dylib_function[
        "rocblas_dasum",
        fn (
            Handle, Int32, UnsafePointer[Float64], Int32, UnsafePointer[Float64]
        ) -> Status,
    ]()(handle, n, x, incx, result)


fn rocblas_csyr_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    alpha: UnsafePointer[ComplexFloat32],
    x: UnsafePointer[ComplexFloat32],
    incx: Int64,
    _a: UnsafePointer[ComplexFloat32],
    lda: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_csyr_64",
        fn (
            Handle,
            Fill,
            Int64,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int64,
            UnsafePointer[ComplexFloat32],
            Int64,
        ) -> Status,
    ]()(handle, uplo, n, alpha, x, incx, _a, lda)


fn rocblas_dasum_batched(
    handle: Handle,
    n: Int32,
    x: OpaquePointer,
    incx: Int32,
    batch_count: Int32,
    results: UnsafePointer[Float64],
) -> Status:
    return _get_dylib_function[
        "rocblas_dasum_batched",
        fn (
            Handle,
            Int32,
            OpaquePointer,
            Int32,
            Int32,
            UnsafePointer[Float64],
        ) -> Status,
    ]()(handle, n, x, incx, batch_count, results)


fn rocblas_sswap_strided_batched_64(
    handle: Handle,
    n: Int64,
    x: UnsafePointer[Float32],
    incx: Int64,
    stridex: Int64,
    y: UnsafePointer[Float32],
    incy: Int64,
    stridey: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_sswap_strided_batched_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[Float32],
            Int64,
            Int64,
            UnsafePointer[Float32],
            Int64,
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, n, x, incx, stridex, y, incy, stridey, batch_count)


fn rocblas_zherkx(
    handle: Handle,
    uplo: Fill,
    trans: Operation,
    n: Int32,
    k: Int32,
    alpha: UnsafePointer[ComplexFloat64],
    _a: UnsafePointer[ComplexFloat64],
    lda: Int32,
    _b: UnsafePointer[ComplexFloat64],
    ldb: Int32,
    beta: UnsafePointer[Float64],
    _c: UnsafePointer[ComplexFloat64],
    ldc: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_zherkx",
        fn (
            Handle,
            Fill,
            Operation,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int32,
            UnsafePointer[ComplexFloat64],
            Int32,
            UnsafePointer[Float64],
            UnsafePointer[ComplexFloat64],
            Int32,
        ) -> Status,
    ]()(handle, uplo, trans, n, k, alpha, _a, lda, _b, ldb, beta, _c, ldc)


fn rocblas_cgeru_batched(
    handle: Handle,
    m: Int32,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat32],
    x: OpaquePointer,
    incx: Int32,
    y: OpaquePointer,
    incy: Int32,
    _a: OpaquePointer,
    lda: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_cgeru_batched",
        fn (
            Handle,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat32],
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(handle, m, n, alpha, x, incx, y, incy, _a, lda, batch_count)


fn rocblas_strmv_64(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int64,
    _a: UnsafePointer[Float32],
    lda: Int64,
    x: UnsafePointer[Float32],
    incx: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_strmv_64",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int64,
            UnsafePointer[Float32],
            Int64,
            UnsafePointer[Float32],
            Int64,
        ) -> Status,
    ]()(handle, uplo, trans_a, diag, n, _a, lda, x, incx)


fn rocblas_haxpy_batched(
    handle: Handle,
    n: Int32,
    alpha: UnsafePointer[Float16],
    x: OpaquePointer,
    incx: Int32,
    y: OpaquePointer,
    incy: Int32,
    batch_count: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 1 API </b>.

    \\details
    axpy_batched compute y := alpha * x + y over a set of batched vectors.

    @param[in]
    handle    rocblas_handle
              handle to the rocblas library context queue.
    @param[in]
    n         rocblas_int
    @param[in]
    alpha     specifies the scalar alpha.
    @param[in]
    x         pointer storing vector x on the GPU.
    @param[in]
    incx      rocblas_int
              specifies the increment for the elements of x.
    @param[out]
    y         pointer storing vector y on the GPU.
    @param[in, out]
    incy      rocblas_int
              specifies the increment for the elements of y.

    @param[in]
    batch_count rocblas_int
              number of instances in the batch.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_haxpy_batched",
        fn (
            Handle,
            Int32,
            UnsafePointer[Float16],
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(handle, n, alpha, x, incx, y, incy, batch_count)


fn rocblas_idamin_batched_64(
    handle: Handle,
    n: Int64,
    x: OpaquePointer,
    incx: Int64,
    batch_count: Int64,
    result: UnsafePointer[Int64],
) -> Status:
    return _get_dylib_function[
        "rocblas_idamin_batched_64",
        fn (
            Handle,
            Int64,
            OpaquePointer,
            Int64,
            Int64,
            UnsafePointer[Int64],
        ) -> Status,
    ]()(handle, n, x, incx, batch_count, result)


fn rocblas_tssgemv_strided_batched_64(
    handle: Handle,
    trans_a: Operation,
    m: Int64,
    n: Int64,
    alpha: UnsafePointer[Float32],
    _a: UnsafePointer[BFloat16],
    lda: Int64,
    stride_a: Int64,
    x: UnsafePointer[BFloat16],
    incx: Int64,
    stridex: Int64,
    beta: UnsafePointer[Float32],
    y: UnsafePointer[Float32],
    incy: Int64,
    stridey: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_tssgemv_strided_batched_64",
        fn (
            Handle,
            Operation,
            Int64,
            Int64,
            UnsafePointer[Float32],
            UnsafePointer[BFloat16],
            Int64,
            Int64,
            UnsafePointer[BFloat16],
            Int64,
            Int64,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int64,
            Int64,
            Int64,
        ) -> Status,
    ]()(
        handle,
        trans_a,
        m,
        n,
        alpha,
        _a,
        lda,
        stride_a,
        x,
        incx,
        stridex,
        beta,
        y,
        incy,
        stridey,
        batch_count,
    )


fn rocblas_chpmv_strided_batched(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat32],
    _ap: UnsafePointer[ComplexFloat32],
    stride__a: Int64,
    x: UnsafePointer[ComplexFloat32],
    incx: Int32,
    stride_x: Int64,
    beta: UnsafePointer[ComplexFloat32],
    y: UnsafePointer[ComplexFloat32],
    incy: Int32,
    stride_y: Int64,
    batch_count: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 2 API </b>.

    \\details
    hpmv_strided_batched performs the matrix-vector operation:

        y_i := alpha*A_i*x_i + beta*y_i
        where alpha and beta are scalars, x_i and y_i are n element vectors and A_i is an
        n by n Hermitian matrix, supplied in packed form (see description below),
        for each batch in i = [1, batch_count].

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    uplo      [rocblas_fill]
            - rocblas_fill_upper: the upper triangular part of each Hermitian matrix A_i is supplied in AP.
            - rocblas_fill_lower: the lower triangular part of each Hermitian matrix A_i is supplied in AP.
    @param[in]
    n         [rocblas_int]
              the order of each matrix A_i.
    @param[in]
    alpha     device pointer or host pointer to scalar alpha.
    @param[in]
    AP        device pointer pointing to the beginning of the first matrix (AP_1). Stores the packed
              version of the specified triangular portion of each Hermitian matrix AP_i of size ((n * (n + 1)) / 2).

                    if uplo == rocblas_fill_upper:
                        The upper triangular portion of each Hermitian matrix A_i is supplied.
                        The matrix is compacted so that each AP_i contains the triangular portion
                        column-by-column
                        so that:
                        AP(0) = A(0,0)
                        AP(1) = A(0,1)
                        AP(2) = A(1,1), etc.
                        Ex: (rocblas_fill_upper; n = 3)
                            (1, 0) (2, 1) (3, 2)
                            (2,-1) (4, 0) (5,-1) ---> [(1,0),(2,1),(4,0),(3,2),(5,-1),(6,0)]
                            (3,-2) (5, 1) (6, 0)

                    if uplo == rocblas_fill_lower:
                        The lower triangular portion of each Hermitian matrix A_i is supplied.
                        The matrix is compacted so that each AP_i contains the triangular portion
                        column-by-column
                        so that:
                        AP(0) = A(0,0)
                        AP(1) = A(1,0)
                        AP(2) = A(2,1), etc.
                        Ex: (rocblas_fill_lower; n = 3)
                            (1, 0) (2, 1) (3, 2)
                            (2,-1) (4, 0) (5,-1) ---> [(1,0),(2,-1),(3,-2),(4,0),(5,1),(6,0)]
                            (3,-2) (5, 1) (6, 0)
                    Note that the imaginary part of the diagonal elements are not accessed
                    and are assumed to be 0.
    @param[in]
    stride_A  [rocblas_stride]
              stride from the start of one matrix (AP_i) and the next one (AP_i+1).
    @param[in]
    x         device array pointing to the beginning of the first vector (x_1).
    @param[in]
    incx      [rocblas_int]
              specifies the increment for the elements of each x_i.
    @param[in]
    stride_x  [rocblas_stride]
              stride from the start of one vector (x_i) and the next one (x_i+1).
    @param[in]
    beta      device pointer or host pointer to scalar beta.
    @param[in, out]
    y         device array pointing to the beginning of the first vector (y_1).
    @param[in]
    incy      [rocblas_int]
              specifies the increment for the elements of y.
    @param[in]
    stride_y  [rocblas_stride]
              stride from the start of one vector (y_i) and the next one (y_i+1).
    @param[in]
    batch_count [rocblas_int]
                number of instances in the batch.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_chpmv_strided_batched",
        fn (
            Handle,
            Fill,
            Int32,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int64,
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        uplo,
        n,
        alpha,
        _ap,
        stride__a,
        x,
        incx,
        stride_x,
        beta,
        y,
        incy,
        stride_y,
        batch_count,
    )


fn rocblas_zsyr2k(
    handle: Handle,
    uplo: Fill,
    trans: Operation,
    n: Int32,
    k: Int32,
    alpha: UnsafePointer[ComplexFloat64],
    _a: UnsafePointer[ComplexFloat64],
    lda: Int32,
    _b: UnsafePointer[ComplexFloat64],
    ldb: Int32,
    beta: UnsafePointer[ComplexFloat64],
    _c: UnsafePointer[ComplexFloat64],
    ldc: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_zsyr2k",
        fn (
            Handle,
            Fill,
            Operation,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int32,
            UnsafePointer[ComplexFloat64],
            Int32,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int32,
        ) -> Status,
    ]()(handle, uplo, trans, n, k, alpha, _a, lda, _b, ldb, beta, _c, ldc)


fn rocblas_gemm_strided_batched_ex(
    handle: Handle,
    trans_a: Operation,
    trans_b: Operation,
    m: Int32,
    n: Int32,
    k: Int32,
    alpha: OpaquePointer,
    a: OpaquePointer,
    a_type: DataType,
    lda: Int32,
    stride_a: Int64,
    b: OpaquePointer,
    b_type: DataType,
    ldb: Int32,
    stride_b: Int64,
    beta: OpaquePointer,
    c: OpaquePointer,
    c_type: DataType,
    ldc: Int32,
    stride_c: Int64,
    d: OpaquePointer,
    d_type: DataType,
    ldd: Int32,
    stride_d: Int64,
    batch_count: Int32,
    compute_type: DataType,
    algo: Algorithm,
    solution_index: Int32,
    flags: UInt32,
) -> Status:
    """
    \\brief <b> BLAS EX API </b>.

    \\details
    gemm_strided_batched_ex performs one of the strided_batched matrix-matrix operations:

        D_i = alpha*op(A_i)*op(B_i) + beta*C_i, for i = 1, ..., batch_count

    where op( X ) is one of

        op( X ) = X      or
        op( X ) = X**T   or
        op( X ) = X**H,

    alpha and beta are scalars, and A, B, C, and D are strided_batched matrices, with
    op( A ) an m by k by batch_count strided_batched matrix,
    op( B ) a k by n by batch_count strided_batched matrix and
    C and D are m by n by batch_count strided_batched matrices.
    C and D may point to the same matrices if their parameters are identical.

    The strided_batched matrices are multiple matrices separated by a constant stride.
    The number of matrices is batch_count.

    Supported types are as follows:
        - rocblas_datatype_f64_r = a_type = b_type = c_type = d_type = compute_type
        - rocblas_datatype_f32_r = a_type = b_type = c_type = d_type = compute_type
        - rocblas_datatype_f16_r = a_type = b_type = c_type = d_type = compute_type
        - rocblas_datatype_f16_r = a_type = b_type = c_type = d_type; rocblas_datatype_f32_r =
    compute_type
        - rocblas_datatype_bf16_r = a_type = b_type = c_type = d_type; rocblas_datatype_f32_r =
    compute_type
        - rocblas_datatype_i8_r = a_type = b_type; rocblas_datatype_i32_r = c_type = d_type =
    compute_type
        - rocblas_datatype_f32_c  = a_type = b_type = c_type = d_type = compute_type
        - rocblas_datatype_f64_c  = a_type = b_type = c_type = d_type = compute_type

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    transA    [rocblas_operation]
              specifies the form of op( A ).
    @param[in]
    transB    [rocblas_operation]
              specifies the form of op( B ).
    @param[in]
    m         [rocblas_int]
              matrix dimension m.
    @param[in]
    n         [rocblas_int]
              matrix dimension n.
    @param[in]
    k         [rocblas_int]
              matrix dimension k.
    @param[in]
    alpha     [const void *]
              device pointer or host pointer specifying the scalar alpha. Same datatype as compute_type.
    @param[in]
    a         [void *]
              device pointer pointing to first matrix A_1.
    @param[in]
    a_type    [rocblas_datatype]
              specifies the datatype of each matrix A_i.
    @param[in]
    lda       [rocblas_int]
              specifies the leading dimension of each A_i.
    @param[in]
    stride_a  [rocblas_stride]
              specifies stride from start of one A_i matrix to the next A_(i + 1).
    @param[in]
    b         [void *]
              device pointer pointing to first matrix B_1.
    @param[in]
    b_type    [rocblas_datatype]
              specifies the datatype of each matrix B_i.
    @param[in]
    ldb       [rocblas_int]
              specifies the leading dimension of each B_i.
    @param[in]
    stride_b  [rocblas_stride]
              specifies stride from start of one B_i matrix to the next B_(i + 1).
    @param[in]
    beta      [const void *]
              device pointer or host pointer specifying the scalar beta. Same datatype as compute_type.
    @param[in]
    c         [void *]
              device pointer pointing to first matrix C_1.
    @param[in]
    c_type    [rocblas_datatype]
              specifies the datatype of each matrix C_i.
    @param[in]
    ldc       [rocblas_int]
              specifies the leading dimension of each C_i.
    @param[in]
    stride_c  [rocblas_stride]
              specifies stride from start of one C_i matrix to the next C_(i + 1).
    @param[out]
    d         [void *]
              device pointer storing each matrix D_i.
              If d and c pointers are to the same matrix then d_type must equal c_type and ldd must equal ldc
              and stride_d must equal stride_c or the respective invalid status will be returned.
    @param[in]
    d_type    [rocblas_datatype]
              specifies the datatype of each matrix D_i.
    @param[in]
    ldd       [rocblas_int]
              specifies the leading dimension of each D_i.
    @param[in]
    stride_d  [rocblas_stride]
              specifies stride from start of one D_i matrix to the next D_(i + 1).
    @param[in]
    batch_count
              [rocblas_int]
              number of gemm operations in the batch.
    @param[in]
    compute_type
              [rocblas_datatype]
              specifies the datatype of computation.
    @param[in]
    algo      [rocblas_gemm_algo]
              enumerant specifying the algorithm type.
    @param[in]
    solution_index
              [int32_t]
              if algo is Algorithmsolution_index, this controls which solution is used.
              When algo is not Algorithmsolution_index, or if solution_index <= 0, the default solution is used.
              This parameter was unused in previous releases and instead always used the default solution
    @param[in]
    flags     [uint32_t]
              optional gemm flags.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_gemm_strided_batched_ex",
        fn (
            Handle,
            Operation,
            Operation,
            Int32,
            Int32,
            Int32,
            OpaquePointer,
            OpaquePointer,
            DataType,
            Int32,
            Int64,
            OpaquePointer,
            DataType,
            Int32,
            Int64,
            OpaquePointer,
            OpaquePointer,
            DataType,
            Int32,
            Int64,
            OpaquePointer,
            DataType,
            Int32,
            Int64,
            Int32,
            DataType,
            Algorithm,
            Int32,
            UInt32,
        ) -> Status,
    ]()(
        handle,
        trans_a,
        trans_b,
        m,
        n,
        k,
        alpha,
        a,
        a_type,
        lda,
        stride_a,
        b,
        b_type,
        ldb,
        stride_b,
        beta,
        c,
        c_type,
        ldc,
        stride_c,
        d,
        d_type,
        ldd,
        stride_d,
        batch_count,
        compute_type,
        algo,
        solution_index,
        flags,
    )


fn rocblas_ztrtri(
    handle: Handle,
    uplo: Fill,
    diag: Diagonal,
    n: Int32,
    _a: UnsafePointer[ComplexFloat64],
    lda: Int32,
    inv_a: UnsafePointer[ComplexFloat64],
    ldinv_a: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_ztrtri",
        fn (
            Handle,
            Fill,
            Diagonal,
            Int32,
            UnsafePointer[ComplexFloat64],
            Int32,
            UnsafePointer[ComplexFloat64],
            Int32,
        ) -> Status,
    ]()(handle, uplo, diag, n, _a, lda, inv_a, ldinv_a)


fn rocblas_ctrmv(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int32,
    _a: UnsafePointer[ComplexFloat32],
    lda: Int32,
    x: UnsafePointer[ComplexFloat32],
    incx: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_ctrmv",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int32,
            UnsafePointer[ComplexFloat32],
            Int32,
            UnsafePointer[ComplexFloat32],
            Int32,
        ) -> Status,
    ]()(handle, uplo, trans_a, diag, n, _a, lda, x, incx)


fn rocblas_dtrmv_batched_64(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int64,
    _a: UnsafePointer[UnsafePointer[Float64]],
    lda: Int64,
    x: UnsafePointer[UnsafePointer[Float64]],
    incx: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_dtrmv_batched_64",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int64,
            UnsafePointer[UnsafePointer[Float64]],
            Int64,
            UnsafePointer[UnsafePointer[Float64]],
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, uplo, trans_a, diag, n, _a, lda, x, incx, batch_count)


fn rocblas_sger_strided_batched_64(
    handle: Handle,
    m: Int64,
    n: Int64,
    alpha: UnsafePointer[Float32],
    x: UnsafePointer[Float32],
    incx: Int64,
    stridex: Int64,
    y: UnsafePointer[Float32],
    incy: Int64,
    stridey: Int64,
    _a: UnsafePointer[Float32],
    lda: Int64,
    stride_a: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_sger_strided_batched_64",
        fn (
            Handle,
            Int64,
            Int64,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int64,
            Int64,
            UnsafePointer[Float32],
            Int64,
            Int64,
            UnsafePointer[Float32],
            Int64,
            Int64,
            Int64,
        ) -> Status,
    ]()(
        handle,
        m,
        n,
        alpha,
        x,
        incx,
        stridex,
        y,
        incy,
        stridey,
        _a,
        lda,
        stride_a,
        batch_count,
    )


fn rocblas_dtpsv_batched_64(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int64,
    _ap: OpaquePointer,
    x: OpaquePointer,
    incx: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_dtpsv_batched_64",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int64,
            OpaquePointer,
            OpaquePointer,
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, uplo, trans_a, diag, n, _ap, x, incx, batch_count)


fn rocblas_sdot_batched_64(
    handle: Handle,
    n: Int64,
    x: OpaquePointer,
    incx: Int64,
    y: OpaquePointer,
    incy: Int64,
    batch_count: Int64,
    result: UnsafePointer[Float32],
) -> Status:
    return _get_dylib_function[
        "rocblas_sdot_batched_64",
        fn (
            Handle,
            Int64,
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            Int64,
            UnsafePointer[Float32],
        ) -> Status,
    ]()(handle, n, x, incx, y, incy, batch_count, result)


fn rocblas_dznrm2_batched(
    handle: Handle,
    n: Int32,
    x: OpaquePointer,
    incx: Int32,
    batch_count: Int32,
    results: UnsafePointer[Float64],
) -> Status:
    return _get_dylib_function[
        "rocblas_dznrm2_batched",
        fn (
            Handle,
            Int32,
            OpaquePointer,
            Int32,
            Int32,
            UnsafePointer[Float64],
        ) -> Status,
    ]()(handle, n, x, incx, batch_count, results)


fn rocblas_ddgmm_batched(
    handle: Handle,
    side: Side,
    m: Int32,
    n: Int32,
    _a: OpaquePointer,
    lda: Int32,
    x: OpaquePointer,
    incx: Int32,
    _c: OpaquePointer,
    ldc: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_ddgmm_batched",
        fn (
            Handle,
            Side,
            Int32,
            Int32,
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(handle, side, m, n, _a, lda, x, incx, _c, ldc, batch_count)


fn rocblas_srotg_strided_batched_64(
    handle: Handle,
    a: UnsafePointer[Float32],
    stride_a: Int64,
    b: UnsafePointer[Float32],
    stride_b: Int64,
    c: UnsafePointer[Float32],
    stride_c: Int64,
    s: UnsafePointer[Float32],
    stride_s: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_srotg_strided_batched_64",
        fn (
            Handle,
            UnsafePointer[Float32],
            Int64,
            UnsafePointer[Float32],
            Int64,
            UnsafePointer[Float32],
            Int64,
            UnsafePointer[Float32],
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, a, stride_a, b, stride_b, c, stride_c, s, stride_s, batch_count)


fn rocblas_dgbmv_64(
    handle: Handle,
    trans: Operation,
    m: Int64,
    n: Int64,
    kl: Int64,
    ku: Int64,
    alpha: UnsafePointer[Float64],
    _a: UnsafePointer[Float64],
    lda: Int64,
    x: UnsafePointer[Float64],
    incx: Int64,
    beta: UnsafePointer[Float64],
    y: UnsafePointer[Float64],
    incy: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_dgbmv_64",
        fn (
            Handle,
            Operation,
            Int64,
            Int64,
            Int64,
            Int64,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int64,
            UnsafePointer[Float64],
            Int64,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int64,
        ) -> Status,
    ]()(handle, trans, m, n, kl, ku, alpha, _a, lda, x, incx, beta, y, incy)


fn rocblas_sasum_batched_64(
    handle: Handle,
    n: Int64,
    x: OpaquePointer,
    incx: Int64,
    batch_count: Int64,
    results: UnsafePointer[Float32],
) -> Status:
    return _get_dylib_function[
        "rocblas_sasum_batched_64",
        fn (
            Handle,
            Int64,
            OpaquePointer,
            Int64,
            Int64,
            UnsafePointer[Float32],
        ) -> Status,
    ]()(handle, n, x, incx, batch_count, results)


fn rocblas_dspmv_strided_batched(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    alpha: UnsafePointer[Float64],
    _a: UnsafePointer[Float64],
    stride_a: Int64,
    x: UnsafePointer[Float64],
    incx: Int32,
    stridex: Int64,
    beta: UnsafePointer[Float64],
    y: UnsafePointer[Float64],
    incy: Int32,
    stridey: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_dspmv_strided_batched",
        fn (
            Handle,
            Fill,
            Int32,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int64,
            UnsafePointer[Float64],
            Int32,
            Int64,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        uplo,
        n,
        alpha,
        _a,
        stride_a,
        x,
        incx,
        stridex,
        beta,
        y,
        incy,
        stridey,
        batch_count,
    )


fn rocblas_chbmv_strided_batched_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    k: Int64,
    alpha: UnsafePointer[ComplexFloat32],
    _a: UnsafePointer[ComplexFloat32],
    lda: Int64,
    stride__a: Int64,
    x: UnsafePointer[ComplexFloat32],
    incx: Int64,
    stride_x: Int64,
    beta: UnsafePointer[ComplexFloat32],
    y: UnsafePointer[ComplexFloat32],
    incy: Int64,
    stride_y: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_chbmv_strided_batched_64",
        fn (
            Handle,
            Fill,
            Int64,
            Int64,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int64,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int64,
            Int64,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int64,
            Int64,
            Int64,
        ) -> Status,
    ]()(
        handle,
        uplo,
        n,
        k,
        alpha,
        _a,
        lda,
        stride__a,
        x,
        incx,
        stride_x,
        beta,
        y,
        incy,
        stride_y,
        batch_count,
    )


fn rocblas_zswap_batched_64(
    handle: Handle,
    n: Int64,
    x: OpaquePointer,
    incx: Int64,
    y: OpaquePointer,
    incy: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_zswap_batched_64",
        fn (
            Handle,
            Int64,
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, n, x, incx, y, incy, batch_count)


fn rocblas_sgemv_strided_batched(
    handle: Handle,
    trans_a: Operation,
    m: Int32,
    n: Int32,
    alpha: UnsafePointer[Float32],
    _a: UnsafePointer[Float32],
    lda: Int32,
    stride_a: Int64,
    x: UnsafePointer[Float32],
    incx: Int32,
    stridex: Int64,
    beta: UnsafePointer[Float32],
    y: UnsafePointer[Float32],
    incy: Int32,
    stridey: Int64,
    batch_count: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 2 API </b>.

    \\details
    gemv_strided_batched performs a batch of matrix-vector operations:

        y_i := alpha*A_i*x_i    + beta*y_i,   or
        y_i := alpha*A_i**T*x_i + beta*y_i,   or
        y_i := alpha*A_i**H*x_i + beta*y_i,
        where (A_i, x_i, y_i) is the i-th instance of the batch.
        alpha and beta are scalars, x_i and y_i are vectors and A_i is an
        m by n matrix, for i = 1, ..., batch_count.

    @param[in]
    handle      [rocblas_handle]
                handle to the rocblas library context queue.
    @param[in]
    transA      [rocblas_operation]
                indicates whether matrices A_i are transposed (conjugated) or not.
    @param[in]
    m           [rocblas_int]
                number of rows of matrices A_i.
    @param[in]
    n           [rocblas_int]
                number of columns of matrices A_i.
    @param[in]
    alpha       device pointer or host pointer to scalar alpha.
    @param[in]
    A           device pointer to the first matrix (A_1) in the batch.
    @param[in]
    lda         [rocblas_int]
                specifies the leading dimension of matrices A_i.
    @param[in]
    strideA     [rocblas_stride]
                stride from the start of one matrix (A_i) and the next one (A_i+1).
    @param[in]
    x           device pointer to the first vector (x_1) in the batch.
    @param[in]
    incx        [rocblas_int]
                specifies the increment for the elements of vectors x_i.
    @param[in]
    stridex     [rocblas_stride]
                stride from the start of one vector (x_i) and the next one (x_i+1).
                There are no restrictions placed on stride_x. However, ensure that stride_x is of appropriate size. When trans equals rocblas_operation_none
                this typically means stride_x >= n * incx, otherwise stride_x >= m * incx.
    @param[in]
    beta        device pointer or host pointer to scalar beta.
    @param[in, out]
    y           device pointer to the first vector (y_1) in the batch.
    @param[in]
    incy        [rocblas_int]
                specifies the increment for the elements of vectors y_i.
    @param[in]
    stridey     [rocblas_stride]
                stride from the start of one vector (y_i) and the next one (y_i+1).
                There are no restrictions placed on stride_y. However, ensure that stride_y is of appropriate size. When trans equals rocblas_operation_none
                this typically means stride_y >= m * incy, otherwise stride_y >= n * incy. stridey should be non zero.
    @param[in]
    batch_count [rocblas_int]
                number of instances in the batch.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_sgemv_strided_batched",
        fn (
            Handle,
            Operation,
            Int32,
            Int32,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int32,
            Int64,
            UnsafePointer[Float32],
            Int32,
            Int64,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        trans_a,
        m,
        n,
        alpha,
        _a,
        lda,
        stride_a,
        x,
        incx,
        stridex,
        beta,
        y,
        incy,
        stridey,
        batch_count,
    )


fn rocblas_csrot_batched_64(
    handle: Handle,
    n: Int64,
    x: OpaquePointer,
    incx: Int64,
    y: OpaquePointer,
    incy: Int64,
    c: UnsafePointer[Float32],
    s: UnsafePointer[Float32],
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_csrot_batched_64",
        fn (
            Handle,
            Int64,
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int64,
        ) -> Status,
    ]()(handle, n, x, incx, y, incy, c, s, batch_count)


fn rocblas_idamin_batched(
    handle: Handle,
    n: Int32,
    x: OpaquePointer,
    incx: Int32,
    batch_count: Int32,
    result: UnsafePointer[Int32],
) -> Status:
    return _get_dylib_function[
        "rocblas_idamin_batched",
        fn (
            Handle,
            Int32,
            OpaquePointer,
            Int32,
            Int32,
            UnsafePointer[Int32],
        ) -> Status,
    ]()(handle, n, x, incx, batch_count, result)


fn rocblas_zswap_64(
    handle: Handle,
    n: Int64,
    x: UnsafePointer[ComplexFloat64],
    incx: Int64,
    y: UnsafePointer[ComplexFloat64],
    incy: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_zswap_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int64,
            UnsafePointer[ComplexFloat64],
            Int64,
        ) -> Status,
    ]()(handle, n, x, incx, y, incy)


fn rocblas_strsv_batched(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int32,
    _a: OpaquePointer,
    lda: Int32,
    x: OpaquePointer,
    incx: Int32,
    batch_count: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 2 API </b>.

    \\details
    trsv_batched solves:

         A_i*x_i = b_i or
         A_i**T*x_i = b_i or
         A_i**H*x_i = b_i,
        where (A_i, x_i, b_i) is the i-th instance of the batch.
        x_i and b_i are vectors and A_i is an
        n by n triangular matrix.

    The vector x is overwritten on b.

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.

    @param[in]
    uplo    [rocblas_fill]
            - rocblas_fill_upper:  A is an upper triangular matrix.
            - rocblas_fill_lower:  A is a  lower triangular matrix.

    @param[in]
    transA     [rocblas_operation]
            - rocblas_operation_none:    op(A) = A.
            - rocblas_operation_transpose:   op(A) = A^T
            - rocblas_operation_conjugate_transpose:  op(A) = A^H

    @param[in]
    diag    [rocblas_diagonal]
            - rocblas_diagonal_unit:     A is assumed to be unit triangular.
            - rocblas_diagonal_non_unit:  A is not assumed to be unit triangular.

    @param[in]
    n         [rocblas_int]
              n specifies the number of rows of b. n >= 0.

    @param[in]
    A         device pointer to an array of device pointers to the A_i matrices, of dimension ( lda, n ). If uplo == rocblas_fill_upper, the upper triangular part of the leading n-by-n array contains the matrix A_i, otherwise the lower triangular part of the leading n-by-n array contains the matrix A_i.

    @param[in]
    lda       [rocblas_int]
              specifies the leading dimension of A_i. lda must be at least max( 1, n ).

    @param[in, out]
    x         device pointer to an array of device pointers to the x_i vectors. On exit, each x_i is overwritten with the transformed vector x_i.

    @param[in]
    incx      [rocblas_int]
              specifies the increment for the elements of x.

    @param[in]
    batch_count [rocblas_int]
                number of instances in the batch.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_strsv_batched",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int32,
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(handle, uplo, trans_a, diag, n, _a, lda, x, incx, batch_count)


fn rocblas_zhbmv(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    k: Int32,
    alpha: UnsafePointer[ComplexFloat64],
    _a: UnsafePointer[ComplexFloat64],
    lda: Int32,
    x: UnsafePointer[ComplexFloat64],
    incx: Int32,
    beta: UnsafePointer[ComplexFloat64],
    y: UnsafePointer[ComplexFloat64],
    incy: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_zhbmv",
        fn (
            Handle,
            Fill,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int32,
            UnsafePointer[ComplexFloat64],
            Int32,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int32,
        ) -> Status,
    ]()(handle, uplo, n, k, alpha, _a, lda, x, incx, beta, y, incy)


fn rocblas_zrot_strided_batched_64(
    handle: Handle,
    n: Int64,
    x: UnsafePointer[ComplexFloat64],
    incx: Int64,
    stride_x: Int64,
    y: UnsafePointer[ComplexFloat64],
    incy: Int64,
    stride_y: Int64,
    c: UnsafePointer[Float64],
    s: UnsafePointer[ComplexFloat64],
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_zrot_strided_batched_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int64,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int64,
            Int64,
            UnsafePointer[Float64],
            UnsafePointer[ComplexFloat64],
            Int64,
        ) -> Status,
    ]()(handle, n, x, incx, stride_x, y, incy, stride_y, c, s, batch_count)


fn rocblas_zher_strided_batched_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    alpha: UnsafePointer[Float64],
    x: UnsafePointer[ComplexFloat64],
    incx: Int64,
    stride_x: Int64,
    _a: UnsafePointer[ComplexFloat64],
    lda: Int64,
    stride__a: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_zher_strided_batched_64",
        fn (
            Handle,
            Fill,
            Int64,
            UnsafePointer[Float64],
            UnsafePointer[ComplexFloat64],
            Int64,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int64,
            Int64,
            Int64,
        ) -> Status,
    ]()(
        handle,
        uplo,
        n,
        alpha,
        x,
        incx,
        stride_x,
        _a,
        lda,
        stride__a,
        batch_count,
    )


fn rocblas_ztrsv_batched(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int32,
    _a: OpaquePointer,
    lda: Int32,
    x: OpaquePointer,
    incx: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_ztrsv_batched",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int32,
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(handle, uplo, trans_a, diag, n, _a, lda, x, incx, batch_count)


fn rocblas_dtrmv_64(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int64,
    _a: UnsafePointer[Float64],
    lda: Int64,
    x: UnsafePointer[Float64],
    incx: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_dtrmv_64",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int64,
            UnsafePointer[Float64],
            Int64,
            UnsafePointer[Float64],
            Int64,
        ) -> Status,
    ]()(handle, uplo, trans_a, diag, n, _a, lda, x, incx)


fn rocblas_crotg(
    handle: Handle,
    a: UnsafePointer[ComplexFloat32],
    b: UnsafePointer[ComplexFloat32],
    c: UnsafePointer[Float32],
    s: UnsafePointer[ComplexFloat32],
) -> Status:
    return _get_dylib_function[
        "rocblas_crotg",
        fn (
            Handle,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            UnsafePointer[Float32],
            UnsafePointer[ComplexFloat32],
        ) -> Status,
    ]()(handle, a, b, c, s)


fn rocblas_dtbsv_batched(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int32,
    k: Int32,
    _a: OpaquePointer,
    lda: Int32,
    x: OpaquePointer,
    incx: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_dtbsv_batched",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int32,
            Int32,
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(handle, uplo, trans_a, diag, n, k, _a, lda, x, incx, batch_count)


fn rocblas_cswap_batched(
    handle: Handle,
    n: Int32,
    x: OpaquePointer,
    incx: Int32,
    y: OpaquePointer,
    incy: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_cswap_batched",
        fn (
            Handle,
            Int32,
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(handle, n, x, incx, y, incy, batch_count)


fn rocblas_zsyr2_batched(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat64],
    x: OpaquePointer,
    incx: Int32,
    y: OpaquePointer,
    incy: Int32,
    _a: OpaquePointer,
    lda: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_zsyr2_batched",
        fn (
            Handle,
            Fill,
            Int32,
            UnsafePointer[ComplexFloat64],
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(handle, uplo, n, alpha, x, incx, y, incy, _a, lda, batch_count)


fn rocblas_caxpy_strided_batched(
    handle: Handle,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat32],
    x: UnsafePointer[ComplexFloat32],
    incx: Int32,
    stridex: Int64,
    y: UnsafePointer[ComplexFloat32],
    incy: Int32,
    stridey: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_caxpy_strided_batched",
        fn (
            Handle,
            Int32,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(handle, n, alpha, x, incx, stridex, y, incy, stridey, batch_count)


fn rocblas_izamin_batched(
    handle: Handle,
    n: Int32,
    x: OpaquePointer,
    incx: Int32,
    batch_count: Int32,
    result: UnsafePointer[Int32],
) -> Status:
    return _get_dylib_function[
        "rocblas_izamin_batched",
        fn (
            Handle,
            Int32,
            OpaquePointer,
            Int32,
            Int32,
            UnsafePointer[Int32],
        ) -> Status,
    ]()(handle, n, x, incx, batch_count, result)


fn rocblas_dtpsv_batched(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int32,
    _ap: OpaquePointer,
    x: OpaquePointer,
    incx: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_dtpsv_batched",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int32,
            OpaquePointer,
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(handle, uplo, trans_a, diag, n, _ap, x, incx, batch_count)


fn rocblas_ssyr2_batched_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    alpha: UnsafePointer[Float32],
    x: OpaquePointer,
    incx: Int64,
    y: OpaquePointer,
    incy: Int64,
    _a: OpaquePointer,
    lda: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_ssyr2_batched_64",
        fn (
            Handle,
            Fill,
            Int64,
            UnsafePointer[Float32],
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, uplo, n, alpha, x, incx, y, incy, _a, lda, batch_count)


fn rocblas_cdotc(
    handle: Handle,
    n: Int32,
    x: UnsafePointer[ComplexFloat32],
    incx: Int32,
    y: UnsafePointer[ComplexFloat32],
    incy: Int32,
    result: UnsafePointer[ComplexFloat32],
) -> Status:
    return _get_dylib_function[
        "rocblas_cdotc",
        fn (
            Handle,
            Int32,
            UnsafePointer[ComplexFloat32],
            Int32,
            UnsafePointer[ComplexFloat32],
            Int32,
            UnsafePointer[ComplexFloat32],
        ) -> Status,
    ]()(handle, n, x, incx, y, incy, result)


fn rocblas_sspr_batched_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    alpha: UnsafePointer[Float32],
    x: OpaquePointer,
    incx: Int64,
    _ap: OpaquePointer,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_sspr_batched_64",
        fn (
            Handle,
            Fill,
            Int64,
            UnsafePointer[Float32],
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
        ) -> Status,
    ]()(handle, uplo, n, alpha, x, incx, _ap, batch_count)


fn rocblas_csrot_strided_batched(
    handle: Handle,
    n: Int32,
    x: UnsafePointer[ComplexFloat32],
    incx: Int32,
    stride_x: Int64,
    y: UnsafePointer[ComplexFloat32],
    incy: Int32,
    stride_y: Int64,
    c: UnsafePointer[Float32],
    s: UnsafePointer[Float32],
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_csrot_strided_batched",
        fn (
            Handle,
            Int32,
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int32,
        ) -> Status,
    ]()(handle, n, x, incx, stride_x, y, incy, stride_y, c, s, batch_count)


fn rocblas_zher2_batched(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat64],
    x: OpaquePointer,
    incx: Int32,
    y: OpaquePointer,
    incy: Int32,
    _a: OpaquePointer,
    lda: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_zher2_batched",
        fn (
            Handle,
            Fill,
            Int32,
            UnsafePointer[ComplexFloat64],
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(handle, uplo, n, alpha, x, incx, y, incy, _a, lda, batch_count)


fn rocblas_zcopy_batched_64(
    handle: Handle,
    n: Int64,
    x: OpaquePointer,
    incx: Int64,
    y: OpaquePointer,
    incy: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_zcopy_batched_64",
        fn (
            Handle,
            Int64,
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, n, x, incx, y, incy, batch_count)


fn rocblas_zsymv_batched(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat64],
    _a: OpaquePointer,
    lda: Int32,
    x: OpaquePointer,
    incx: Int32,
    beta: UnsafePointer[ComplexFloat64],
    y: OpaquePointer,
    incy: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_zsymv_batched",
        fn (
            Handle,
            Fill,
            Int32,
            UnsafePointer[ComplexFloat64],
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            UnsafePointer[ComplexFloat64],
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(handle, uplo, n, alpha, _a, lda, x, incx, beta, y, incy, batch_count)


fn rocblas_sasum_strided_batched_64(
    handle: Handle,
    n: Int64,
    x: UnsafePointer[Float32],
    incx: Int64,
    stridex: Int64,
    batch_count: Int64,
    results: UnsafePointer[Float32],
) -> Status:
    return _get_dylib_function[
        "rocblas_sasum_strided_batched_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[Float32],
            Int64,
            Int64,
            Int64,
            UnsafePointer[Float32],
        ) -> Status,
    ]()(handle, n, x, incx, stridex, batch_count, results)


fn rocblas_isamin_64(
    handle: Handle,
    n: Int64,
    x: UnsafePointer[Float32],
    incx: Int64,
    result: UnsafePointer[Int64],
) -> Status:
    return _get_dylib_function[
        "rocblas_isamin_64",
        fn (
            Handle, Int64, UnsafePointer[Float32], Int64, UnsafePointer[Int64]
        ) -> Status,
    ]()(handle, n, x, incx, result)


fn rocblas_dsyr(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    alpha: UnsafePointer[Float64],
    x: UnsafePointer[Float64],
    incx: Int32,
    _a: UnsafePointer[Float64],
    lda: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_dsyr",
        fn (
            Handle,
            Fill,
            Int32,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int32,
            UnsafePointer[Float64],
            Int32,
        ) -> Status,
    ]()(handle, uplo, n, alpha, x, incx, _a, lda)


fn rocblas_sgemv_batched(
    handle: Handle,
    trans: Operation,
    m: Int32,
    n: Int32,
    alpha: UnsafePointer[Float32],
    _a: OpaquePointer,
    lda: Int32,
    x: OpaquePointer,
    incx: Int32,
    beta: UnsafePointer[Float32],
    y: OpaquePointer,
    incy: Int32,
    batch_count: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 2 API </b>.

    \\details
    gemv_batched performs a batch of matrix-vector operations:

        y_i := alpha*A_i*x_i    + beta*y_i,   or
        y_i := alpha*A_i**T*x_i + beta*y_i,   or
        y_i := alpha*A_i**H*x_i + beta*y_i,
        where (A_i, x_i, y_i) is the i-th instance of the batch.
        alpha and beta are scalars, x_i and y_i are vectors and A_i is an
        m by n matrix, for i = 1, ..., batch_count.

    @param[in]
    handle      [rocblas_handle]
                handle to the rocblas library context queue.
    @param[in]
    trans       [rocblas_operation]
                indicates whether matrices A_i are transposed (conjugated) or not.
    @param[in]
    m           [rocblas_int]
                number of rows of each matrix A_i.
    @param[in]
    n           [rocblas_int]
                number of columns of each matrix A_i.
    @param[in]
    alpha       device pointer or host pointer to scalar alpha.
    @param[in]
    A           device array of device pointers storing each matrix A_i.
    @param[in]
    lda         [rocblas_int]
                specifies the leading dimension of each matrix A_i.
    @param[in]
    x           device array of device pointers storing each vector x_i.
    @param[in]
    incx        [rocblas_int]
                specifies the increment for the elements of each vector x_i.
    @param[in]
    beta        device pointer or host pointer to scalar beta.
    @param[in, out]
    y           device array of device pointers storing each vector y_i.
    @param[in]
    incy        [rocblas_int]
                specifies the increment for the elements of each vector y_i.
    @param[in]
    batch_count [rocblas_int]
                number of instances in the batch.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_sgemv_batched",
        fn (
            Handle,
            Operation,
            Int32,
            Int32,
            UnsafePointer[Float32],
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            UnsafePointer[Float32],
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(
        handle, trans, m, n, alpha, _a, lda, x, incx, beta, y, incy, batch_count
    )


fn rocblas_ctpmv_batched_64(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int64,
    _a: UnsafePointer[UnsafePointer[ComplexFloat32]],
    x: UnsafePointer[UnsafePointer[ComplexFloat32]],
    incx: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_ctpmv_batched_64",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int64,
            UnsafePointer[UnsafePointer[ComplexFloat32]],
            UnsafePointer[UnsafePointer[ComplexFloat32]],
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, uplo, trans_a, diag, n, _a, x, incx, batch_count)


fn rocblas_device_malloc_ptr(
    ptr: UnsafePointer[MallocBase],
    res: UnsafePointer[OpaquePointer],
) -> Status:
    return _get_dylib_function[
        "rocblas_device_malloc_ptr",
        fn (
            UnsafePointer[MallocBase],
            UnsafePointer[OpaquePointer],
        ) -> Status,
    ]()(ptr, res)


fn rocblas_sger_strided_batched(
    handle: Handle,
    m: Int32,
    n: Int32,
    alpha: UnsafePointer[Float32],
    x: UnsafePointer[Float32],
    incx: Int32,
    stridex: Int64,
    y: UnsafePointer[Float32],
    incy: Int32,
    stridey: Int64,
    _a: UnsafePointer[Float32],
    lda: Int32,
    stride_a: Int64,
    batch_count: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 2 API </b>.

    \\details
    ger_strided_batched,geru_strided_batched,gerc_strided_batched performs the matrix-vector operations:

        A_i := A_i + alpha*x_i*y_i**T, OR
        A_i := A_i + alpha*x_i*y_i**H  for gerc
        where (A_i, x_i, y_i) is the i-th instance of the batch.
        alpha is a scalar, x_i and y_i are vectors and A_i is an
        m by n matrix, for i = 1, ..., batch_count.

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    m         [rocblas_int]
              the number of rows of each matrix A_i.
    @param[in]
    n         [rocblas_int]
              the number of columns of each matrix A_i.
    @param[in]
    alpha
              device pointer or host pointer to scalar alpha.
    @param[in]
    x         device pointer to the first vector (x_1) in the batch.
    @param[in]
    incx      [rocblas_int]
              specifies the increments for the elements of each vector x_i.
    @param[in]
    stridex   [rocblas_stride]
              stride from the start of one vector (x_i) and the next one (x_i+1).
              There are no restrictions placed on stride_x. However, ensure that stride_x is of appropriate size. For a typical
              case this means stride_x >= m * incx.
    @param[in, out]
    y         device pointer to the first vector (y_1) in the batch.
    @param[in]
    incy      [rocblas_int]
              specifies the increment for the elements of each vector y_i.
    @param[in]
    stridey   [rocblas_stride]
              stride from the start of one vector (y_i) and the next one (y_i+1).
              There are no restrictions placed on stride_y. However, ensure that stride_y is of appropriate size. For a typical
              case this means stride_y >= n * incy.
    @param[in, out]
    A         device pointer to the first matrix (A_1) in the batch.
    @param[in]
    lda       [rocblas_int]
              specifies the leading dimension of each A_i.
    @param[in]
    strideA     [rocblas_stride]
                stride from the start of one matrix (A_i) and the next one (A_i+1)
    @param[in]
    batch_count [rocblas_int]
                number of instances in the batch.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_sger_strided_batched",
        fn (
            Handle,
            Int32,
            Int32,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int32,
            Int64,
            UnsafePointer[Float32],
            Int32,
            Int64,
            UnsafePointer[Float32],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        m,
        n,
        alpha,
        x,
        incx,
        stridex,
        y,
        incy,
        stridey,
        _a,
        lda,
        stride_a,
        batch_count,
    )


fn rocblas_daxpy(
    handle: Handle,
    n: Int32,
    alpha: UnsafePointer[Float64],
    x: UnsafePointer[Float64],
    incx: Int32,
    y: UnsafePointer[Float64],
    incy: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_daxpy",
        fn (
            Handle,
            Int32,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int32,
            UnsafePointer[Float64],
            Int32,
        ) -> Status,
    ]()(handle, n, alpha, x, incx, y, incy)


fn rocblas_icamin_batched_64(
    handle: Handle,
    n: Int64,
    x: OpaquePointer,
    incx: Int64,
    batch_count: Int64,
    result: UnsafePointer[Int64],
) -> Status:
    return _get_dylib_function[
        "rocblas_icamin_batched_64",
        fn (
            Handle,
            Int64,
            OpaquePointer,
            Int64,
            Int64,
            UnsafePointer[Int64],
        ) -> Status,
    ]()(handle, n, x, incx, batch_count, result)


fn rocblas_ssyr2_strided_batched(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    alpha: UnsafePointer[Float32],
    x: UnsafePointer[Float32],
    incx: Int32,
    stridex: Int64,
    y: UnsafePointer[Float32],
    incy: Int32,
    stridey: Int64,
    _a: UnsafePointer[Float32],
    lda: Int32,
    stride_a: Int64,
    batch_count: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 2 API </b>.

    \\details
    syr2_strided_batched the matrix-vector operations:

        A[i] := A[i] + alpha*x[i]*y[i]**T + alpha*y[i]*x[i]**T
        where alpha is a scalar, x[i] and y[i] are vectors, and A[i] is a
        n by n symmetric matrices, for i = 1 , ... , batch_count

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    uplo      [rocblas_fill]
            specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
            - if rocblas_fill_upper, the lower part of A is not referenced
            - if rocblas_fill_lower, the upper part of A is not referenced
    @param[in]
    n         [rocblas_int]
              the number of rows and columns of each matrix A.
    @param[in]
    alpha
              device pointer or host pointer to scalar alpha.
    @param[in]
    x         device pointer to the first vector x_1.
    @param[in]
    incx      [rocblas_int]
              specifies the increment for the elements of each x_i.
    @param[in]
    stridex   [rocblas_stride]
              specifies the pointer increment between vectors (x_i) and (x_i+1).
    @param[in]
    y         device pointer to the first vector y_1.
    @param[in]
    incy      [rocblas_int]
              specifies the increment for the elements of each y_i.
    @param[in]
    stridey   [rocblas_stride]
              specifies the pointer increment between vectors (y_i) and (y_i+1).
    @param[in, out]
    A         device pointer to the first matrix A_1.
    @param[in]
    lda       [rocblas_int]
              specifies the leading dimension of each A_i.
    @param[in]
    strideA   [rocblas_stride]
              stride from the start of one matrix (A_i) and the next one (A_i+1).
    @param[in]
    batch_count [rocblas_int]
              number of instances in the batch.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_ssyr2_strided_batched",
        fn (
            Handle,
            Fill,
            Int32,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int32,
            Int64,
            UnsafePointer[Float32],
            Int32,
            Int64,
            UnsafePointer[Float32],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        uplo,
        n,
        alpha,
        x,
        incx,
        stridex,
        y,
        incy,
        stridey,
        _a,
        lda,
        stride_a,
        batch_count,
    )


fn rocblas_hssgemv_strided_batched(
    handle: Handle,
    trans_a: Operation,
    m: Int32,
    n: Int32,
    alpha: UnsafePointer[Float32],
    _a: UnsafePointer[Float16],
    lda: Int32,
    stride_a: Int64,
    x: UnsafePointer[Float16],
    incx: Int32,
    stridex: Int64,
    beta: UnsafePointer[Float32],
    y: UnsafePointer[Float32],
    incy: Int32,
    stridey: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_hssgemv_strided_batched",
        fn (
            Handle,
            Operation,
            Int32,
            Int32,
            UnsafePointer[Float32],
            UnsafePointer[Float16],
            Int32,
            Int64,
            UnsafePointer[Float16],
            Int32,
            Int64,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        trans_a,
        m,
        n,
        alpha,
        _a,
        lda,
        stride_a,
        x,
        incx,
        stridex,
        beta,
        y,
        incy,
        stridey,
        batch_count,
    )


fn rocblas_cgeru_batched_64(
    handle: Handle,
    m: Int64,
    n: Int64,
    alpha: UnsafePointer[ComplexFloat32],
    x: OpaquePointer,
    incx: Int64,
    y: OpaquePointer,
    incy: Int64,
    _a: OpaquePointer,
    lda: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_cgeru_batched_64",
        fn (
            Handle,
            Int64,
            Int64,
            UnsafePointer[ComplexFloat32],
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, m, n, alpha, x, incx, y, incy, _a, lda, batch_count)


fn rocblas_ctrmv_strided_batched_64(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int64,
    _a: UnsafePointer[ComplexFloat32],
    lda: Int64,
    stride__a: Int64,
    x: UnsafePointer[ComplexFloat32],
    incx: Int64,
    stride_x: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_ctrmv_strided_batched_64",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int64,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int64,
            Int64,
            Int64,
        ) -> Status,
    ]()(
        handle,
        uplo,
        trans_a,
        diag,
        n,
        _a,
        lda,
        stride__a,
        x,
        incx,
        stride_x,
        batch_count,
    )


fn rocblas_chpmv_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    alpha: UnsafePointer[ComplexFloat32],
    _ap: UnsafePointer[ComplexFloat32],
    x: UnsafePointer[ComplexFloat32],
    incx: Int64,
    beta: UnsafePointer[ComplexFloat32],
    y: UnsafePointer[ComplexFloat32],
    incy: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_chpmv_64",
        fn (
            Handle,
            Fill,
            Int64,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int64,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int64,
        ) -> Status,
    ]()(handle, uplo, n, alpha, _ap, x, incx, beta, y, incy)


fn rocblas_dotc_batched_ex(
    handle: Handle,
    n: Int32,
    x: OpaquePointer,
    x_type: DataType,
    incx: Int32,
    y: OpaquePointer,
    y_type: DataType,
    incy: Int32,
    batch_count: Int32,
    result: OpaquePointer,
    result_type: DataType,
    execution_type: DataType,
) -> Status:
    return _get_dylib_function[
        "rocblas_dotc_batched_ex",
        fn (
            Handle,
            Int32,
            OpaquePointer,
            DataType,
            Int32,
            OpaquePointer,
            DataType,
            Int32,
            Int32,
            OpaquePointer,
            DataType,
            DataType,
        ) -> Status,
    ]()(
        handle,
        n,
        x,
        x_type,
        incx,
        y,
        y_type,
        incy,
        batch_count,
        result,
        result_type,
        execution_type,
    )


fn rocblas_dgeam_strided_batched(
    handle: Handle,
    trans_a: Operation,
    trans_b: Operation,
    m: Int32,
    n: Int32,
    alpha: UnsafePointer[Float64],
    _a: UnsafePointer[Float64],
    lda: Int32,
    stride__a: Int64,
    beta: UnsafePointer[Float64],
    _b: UnsafePointer[Float64],
    ldb: Int32,
    stride__b: Int64,
    _c: UnsafePointer[Float64],
    ldc: Int32,
    stride__c: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_dgeam_strided_batched",
        fn (
            Handle,
            Operation,
            Operation,
            Int32,
            Int32,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int32,
            Int64,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int32,
            Int64,
            UnsafePointer[Float64],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        trans_a,
        trans_b,
        m,
        n,
        alpha,
        _a,
        lda,
        stride__a,
        beta,
        _b,
        ldb,
        stride__b,
        _c,
        ldc,
        stride__c,
        batch_count,
    )


fn rocblas_dgbmv_strided_batched(
    handle: Handle,
    trans: Operation,
    m: Int32,
    n: Int32,
    kl: Int32,
    ku: Int32,
    alpha: UnsafePointer[Float64],
    _a: UnsafePointer[Float64],
    lda: Int32,
    stride__a: Int64,
    x: UnsafePointer[Float64],
    incx: Int32,
    stride_x: Int64,
    beta: UnsafePointer[Float64],
    y: UnsafePointer[Float64],
    incy: Int32,
    stride_y: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_dgbmv_strided_batched",
        fn (
            Handle,
            Operation,
            Int32,
            Int32,
            Int32,
            Int32,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int32,
            Int64,
            UnsafePointer[Float64],
            Int32,
            Int64,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        trans,
        m,
        n,
        kl,
        ku,
        alpha,
        _a,
        lda,
        stride__a,
        x,
        incx,
        stride_x,
        beta,
        y,
        incy,
        stride_y,
        batch_count,
    )


fn rocblas_ssymv(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    alpha: UnsafePointer[Float32],
    _a: UnsafePointer[Float32],
    lda: Int32,
    x: UnsafePointer[Float32],
    incx: Int32,
    beta: UnsafePointer[Float32],
    y: UnsafePointer[Float32],
    incy: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 2 API </b>.

    \\details
    symv performs the matrix-vector operation:

        y := alpha*A*x + beta*y
        where alpha and beta are scalars, x and y are n element vectors and
        A should contain an upper or lower triangular n by n symmetric matrix.

    symv has an implementation which uses atomic operations. See Atomic Operations
    in the API Reference Guide for more information.

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    uplo     [rocblas_fill]
            specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
            - if rocblas_fill_upper, the lower part of A is not referenced.
            - if rocblas_fill_lower, the upper part of A is not referenced.
    @param[in]
    n         [rocblas_int]
    @param[in]
    alpha
              specifies the scalar alpha.
    @param[in]
    A         pointer storing matrix A on the GPU
    @param[in]
    lda       [rocblas_int]
              specifies the leading dimension of A.
    @param[in]
    x         pointer storing vector x on the GPU.
    @param[in]
    incx      [rocblas_int]
              specifies the increment for the elements of x.
    @param[in]
    beta      specifies the scalar beta
    @param[out]
    y         pointer storing vector y on the GPU.
    @param[in]
    incy      [rocblas_int]
              specifies the increment for the elements of y.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_ssymv",
        fn (
            Handle,
            Fill,
            Int32,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int32,
            UnsafePointer[Float32],
            Int32,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int32,
        ) -> Status,
    ]()(handle, uplo, n, alpha, _a, lda, x, incx, beta, y, incy)


fn rocblas_ssbmv_strided_batched_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    k: Int64,
    alpha: UnsafePointer[Float32],
    _a: UnsafePointer[Float32],
    lda: Int64,
    stride_a: Int64,
    x: UnsafePointer[Float32],
    incx: Int64,
    stridex: Int64,
    beta: UnsafePointer[Float32],
    y: UnsafePointer[Float32],
    incy: Int64,
    stridey: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_ssbmv_strided_batched_64",
        fn (
            Handle,
            Fill,
            Int64,
            Int64,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int64,
            Int64,
            UnsafePointer[Float32],
            Int64,
            Int64,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int64,
            Int64,
            Int64,
        ) -> Status,
    ]()(
        handle,
        uplo,
        n,
        k,
        alpha,
        _a,
        lda,
        stride_a,
        x,
        incx,
        stridex,
        beta,
        y,
        incy,
        stridey,
        batch_count,
    )


fn rocblas_sger_batched(
    handle: Handle,
    m: Int32,
    n: Int32,
    alpha: UnsafePointer[Float32],
    x: OpaquePointer,
    incx: Int32,
    y: OpaquePointer,
    incy: Int32,
    _a: OpaquePointer,
    lda: Int32,
    batch_count: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 2 API </b>.

    \\details
    ger_batched,geru_batched,gerc_batched perform a batch of the matrix-vector operations:

        A := A + alpha*x*y**T , OR
        A := A + alpha*x*y**H for gerc
        where (A_i, x_i, y_i) is the i-th instance of the batch.
        alpha is a scalar, x_i and y_i are vectors and A_i is an
        m by n matrix, for i = 1, ..., batch_count.

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    m         [rocblas_int]
              the number of rows of each matrix A_i.
    @param[in]
    n         [rocblas_int]
              the number of columns of each matrix A_i.
    @param[in]
    alpha
              device pointer or host pointer to scalar alpha.
    @param[in]
    x         device array of device pointers storing each vector x_i.
    @param[in]
    incx      [rocblas_int]
              specifies the increment for the elements of each vector x_i.
    @param[in]
    y         device array of device pointers storing each vector y_i.
    @param[in]
    incy      [rocblas_int]
              specifies the increment for the elements of each vector y_i.
    @param[in, out]
    A         device array of device pointers storing each matrix A_i.
    @param[in]
    lda       [rocblas_int]
              specifies the leading dimension of each A_i.
    @param[in]
    batch_count [rocblas_int]
                number of instances in the batch.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_sger_batched",
        fn (
            Handle,
            Int32,
            Int32,
            UnsafePointer[Float32],
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(handle, m, n, alpha, x, incx, y, incy, _a, lda, batch_count)


fn rocblas_izamax_batched(
    handle: Handle,
    n: Int32,
    x: OpaquePointer,
    incx: Int32,
    batch_count: Int32,
    result: UnsafePointer[Int32],
) -> Status:
    return _get_dylib_function[
        "rocblas_izamax_batched",
        fn (
            Handle,
            Int32,
            OpaquePointer,
            Int32,
            Int32,
            UnsafePointer[Int32],
        ) -> Status,
    ]()(handle, n, x, incx, batch_count, result)


fn rocblas_cgbmv_strided_batched_64(
    handle: Handle,
    trans: Operation,
    m: Int64,
    n: Int64,
    kl: Int64,
    ku: Int64,
    alpha: UnsafePointer[ComplexFloat32],
    _a: UnsafePointer[ComplexFloat32],
    lda: Int64,
    stride__a: Int64,
    x: UnsafePointer[ComplexFloat32],
    incx: Int64,
    stride_x: Int64,
    beta: UnsafePointer[ComplexFloat32],
    y: UnsafePointer[ComplexFloat32],
    incy: Int64,
    stride_y: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_cgbmv_strided_batched_64",
        fn (
            Handle,
            Operation,
            Int64,
            Int64,
            Int64,
            Int64,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int64,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int64,
            Int64,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int64,
            Int64,
            Int64,
        ) -> Status,
    ]()(
        handle,
        trans,
        m,
        n,
        kl,
        ku,
        alpha,
        _a,
        lda,
        stride__a,
        x,
        incx,
        stride_x,
        beta,
        y,
        incy,
        stride_y,
        batch_count,
    )


fn rocblas_csscal_strided_batched(
    handle: Handle,
    n: Int32,
    alpha: UnsafePointer[Float32],
    x: UnsafePointer[ComplexFloat32],
    incx: Int32,
    stride_x: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_csscal_strided_batched",
        fn (
            Handle,
            Int32,
            UnsafePointer[Float32],
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(handle, n, alpha, x, incx, stride_x, batch_count)


fn rocblas_cgerc_batched(
    handle: Handle,
    m: Int32,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat32],
    x: OpaquePointer,
    incx: Int32,
    y: OpaquePointer,
    incy: Int32,
    _a: OpaquePointer,
    lda: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_cgerc_batched",
        fn (
            Handle,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat32],
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(handle, m, n, alpha, x, incx, y, incy, _a, lda, batch_count)


fn rocblas_dspr2(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    alpha: UnsafePointer[Float64],
    x: UnsafePointer[Float64],
    incx: Int32,
    y: UnsafePointer[Float64],
    incy: Int32,
    _ap: UnsafePointer[Float64],
) -> Status:
    return _get_dylib_function[
        "rocblas_dspr2",
        fn (
            Handle,
            Fill,
            Int32,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int32,
            UnsafePointer[Float64],
            Int32,
            UnsafePointer[Float64],
        ) -> Status,
    ]()(handle, uplo, n, alpha, x, incx, y, incy, _ap)


fn rocblas_zspr_strided_batched_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    alpha: UnsafePointer[ComplexFloat64],
    x: UnsafePointer[ComplexFloat64],
    incx: Int64,
    stride_x: Int64,
    _ap: UnsafePointer[ComplexFloat64],
    stride__a: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_zspr_strided_batched_64",
        fn (
            Handle,
            Fill,
            Int64,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int64,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, uplo, n, alpha, x, incx, stride_x, _ap, stride__a, batch_count)


fn rocblas_scnrm2_strided_batched(
    handle: Handle,
    n: Int32,
    x: UnsafePointer[ComplexFloat32],
    incx: Int32,
    stridex: Int64,
    batch_count: Int32,
    results: UnsafePointer[Float32],
) -> Status:
    return _get_dylib_function[
        "rocblas_scnrm2_strided_batched",
        fn (
            Handle,
            Int32,
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            Int32,
            UnsafePointer[Float32],
        ) -> Status,
    ]()(handle, n, x, incx, stridex, batch_count, results)


fn rocblas_zgemmt_batched(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    trans_b: Operation,
    n: Int32,
    k: Int32,
    alpha: UnsafePointer[ComplexFloat64],
    _a: OpaquePointer,
    lda: Int32,
    _b: OpaquePointer,
    ldb: Int32,
    beta: UnsafePointer[ComplexFloat64],
    _c: OpaquePointer,
    ldc: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_zgemmt_batched",
        fn (
            Handle,
            Fill,
            Operation,
            Operation,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat64],
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            UnsafePointer[ComplexFloat64],
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(
        handle,
        uplo,
        trans_a,
        trans_b,
        n,
        k,
        alpha,
        _a,
        lda,
        _b,
        ldb,
        beta,
        _c,
        ldc,
        batch_count,
    )


fn rocblas_csymm_strided_batched(
    handle: Handle,
    side: Side,
    uplo: Fill,
    m: Int32,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat32],
    _a: UnsafePointer[ComplexFloat32],
    lda: Int32,
    stride__a: Int64,
    _b: UnsafePointer[ComplexFloat32],
    ldb: Int32,
    stride__b: Int64,
    beta: UnsafePointer[ComplexFloat32],
    _c: UnsafePointer[ComplexFloat32],
    ldc: Int32,
    stride__c: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_csymm_strided_batched",
        fn (
            Handle,
            Side,
            Fill,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        side,
        uplo,
        m,
        n,
        alpha,
        _a,
        lda,
        stride__a,
        _b,
        ldb,
        stride__b,
        beta,
        _c,
        ldc,
        stride__c,
        batch_count,
    )


fn rocblas_csyr_batched(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat32],
    x: OpaquePointer,
    incx: Int32,
    _a: OpaquePointer,
    lda: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_csyr_batched",
        fn (
            Handle,
            Fill,
            Int32,
            UnsafePointer[ComplexFloat32],
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(handle, uplo, n, alpha, x, incx, _a, lda, batch_count)


fn rocblas_zsyrk_batched(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    n: Int32,
    k: Int32,
    alpha: UnsafePointer[ComplexFloat64],
    _a: OpaquePointer,
    lda: Int32,
    beta: UnsafePointer[ComplexFloat64],
    _c: OpaquePointer,
    ldc: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_zsyrk_batched",
        fn (
            Handle,
            Fill,
            Operation,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat64],
            OpaquePointer,
            Int32,
            UnsafePointer[ComplexFloat64],
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(handle, uplo, trans_a, n, k, alpha, _a, lda, beta, _c, ldc, batch_count)


fn rocblas_sgeam(
    handle: Handle,
    trans_a: Operation,
    trans_b: Operation,
    m: Int32,
    n: Int32,
    alpha: UnsafePointer[Float32],
    _a: UnsafePointer[Float32],
    lda: Int32,
    beta: UnsafePointer[Float32],
    _b: UnsafePointer[Float32],
    ldb: Int32,
    _c: UnsafePointer[Float32],
    ldc: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 3 API </b>.

    \\details
    geam performs one of the matrix-matrix operations:

        C = alpha*op( A ) + beta*op( B ),

        where op( X ) is one of

        op( X ) = X      or
        op( X ) = X**T   or
        op( X ) = X**H,

        alpha and beta are scalars, and A, B and C are matrices, with
        op( A ) an m by n matrix, op( B ) an m by n matrix, and C an m by n matrix.

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    transA    [rocblas_operation]
              specifies the form of op( A ).
    @param[in]
    transB    [rocblas_operation]
              specifies the form of op( B ).
    @param[in]
    m         [rocblas_int]
              matrix dimension m.
    @param[in]
    n         [rocblas_int]
              matrix dimension n.
    @param[in]
    alpha     device pointer or host pointer specifying the scalar alpha.
    @param[in]
    A         device pointer storing matrix A.
    @param[in]
    lda       [rocblas_int]
              specifies the leading dimension of A.
    @param[in]
    beta      device pointer or host pointer specifying the scalar beta.
    @param[in]
    B         device pointer storing matrix B.
    @param[in]
    ldb       [rocblas_int]
              specifies the leading dimension of B.
    @param[in, out]
    C         device pointer storing matrix C.
    @param[in]
    ldc       [rocblas_int]
              specifies the leading dimension of C.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_sgeam",
        fn (
            Handle,
            Operation,
            Operation,
            Int32,
            Int32,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int32,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int32,
            UnsafePointer[Float32],
            Int32,
        ) -> Status,
    ]()(handle, trans_a, trans_b, m, n, alpha, _a, lda, beta, _b, ldb, _c, ldc)


fn rocblas_dznrm2_strided_batched_64(
    handle: Handle,
    n: Int64,
    x: UnsafePointer[ComplexFloat64],
    incx: Int64,
    stridex: Int64,
    batch_count: Int64,
    results: UnsafePointer[Float64],
) -> Status:
    return _get_dylib_function[
        "rocblas_dznrm2_strided_batched_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int64,
            Int64,
            Int64,
            UnsafePointer[Float64],
        ) -> Status,
    ]()(handle, n, x, incx, stridex, batch_count, results)


fn rocblas_zhpmv_batched_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    alpha: UnsafePointer[ComplexFloat64],
    _ap: OpaquePointer,
    x: OpaquePointer,
    incx: Int64,
    beta: UnsafePointer[ComplexFloat64],
    y: OpaquePointer,
    incy: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_zhpmv_batched_64",
        fn (
            Handle,
            Fill,
            Int64,
            UnsafePointer[ComplexFloat64],
            OpaquePointer,
            OpaquePointer,
            Int64,
            UnsafePointer[ComplexFloat64],
            OpaquePointer,
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, uplo, n, alpha, _ap, x, incx, beta, y, incy, batch_count)


fn rocblas_strsm_strided_batched_64(
    handle: Handle,
    side: Side,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    m: Int64,
    n: Int64,
    alpha: UnsafePointer[Float32],
    _a: UnsafePointer[Float32],
    lda: Int64,
    stride_a: Int64,
    _b: UnsafePointer[Float32],
    ldb: Int64,
    stride_b: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_strsm_strided_batched_64",
        fn (
            Handle,
            Side,
            Fill,
            Operation,
            Diagonal,
            Int64,
            Int64,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int64,
            Int64,
            UnsafePointer[Float32],
            Int64,
            Int64,
            Int64,
        ) -> Status,
    ]()(
        handle,
        side,
        uplo,
        trans_a,
        diag,
        m,
        n,
        alpha,
        _a,
        lda,
        stride_a,
        _b,
        ldb,
        stride_b,
        batch_count,
    )


fn rocblas_ztbsv_batched(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int32,
    k: Int32,
    _a: OpaquePointer,
    lda: Int32,
    x: OpaquePointer,
    incx: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_ztbsv_batched",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int32,
            Int32,
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(handle, uplo, trans_a, diag, n, k, _a, lda, x, incx, batch_count)


fn rocblas_csyrk(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    n: Int32,
    k: Int32,
    alpha: UnsafePointer[ComplexFloat32],
    _a: UnsafePointer[ComplexFloat32],
    lda: Int32,
    beta: UnsafePointer[ComplexFloat32],
    _c: UnsafePointer[ComplexFloat32],
    ldc: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_csyrk",
        fn (
            Handle,
            Fill,
            Operation,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int32,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int32,
        ) -> Status,
    ]()(handle, uplo, trans_a, n, k, alpha, _a, lda, beta, _c, ldc)


fn rocblas_axpy_ex(
    handle: Handle,
    n: Int32,
    alpha: OpaquePointer,
    alpha_type: DataType,
    x: OpaquePointer,
    x_type: DataType,
    incx: Int32,
    y: OpaquePointer,
    y_type: DataType,
    incy: Int32,
    execution_type: DataType,
) -> Status:
    """
    \\brief <b> BLAS EX API </b>.

    \\details
    axpy_ex   computes constant alpha multiplied by vector x, plus vector y.

        y := alpha * x + y

    Currently supported datatypes are as follows:

    -------------------------------------------------
    | alpha_type | x_type | y_type | execution_type |
    |------------|--------|--------|----------------|
    |  bf16_r    | bf16_r |  bf16_r|      f32_r     |
    |  f32_r     | bf16_r |  bf16_r|      f32_r     |
    |  f16_r     | f16_r  |  f16_r |      f16_r     |
    |  f16_r     | f16_r  |  f16_r |      f32_r     |
    |  f32_r     | f16_r  |  f16_r |      f32_r     |
    |  f32_r     | f32_r  |  f32_r |      f32_r     |
    |  f64_r     | f64_r  |  f64_r |      f64_r     |
    |  f32_c     | f32_c  |  f32_c |      f32_c     |
    |  f64_c     | f64_c  |  f64_c |      f64_c     |
    -------------------------------------------------

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    n         [rocblas_int]
              the number of elements in x and y.
    @param[in]
    alpha     device pointer or host pointer to specify the scalar alpha.
    @param[in]
    alpha_type [rocblas_datatype]
              specifies the datatype of alpha.
    @param[in]
    x         device pointer storing vector x.
    @param[in]
    x_type [rocblas_datatype]
           specifies the datatype of vector x.
    @param[in]
    incx      [rocblas_int]
              specifies the increment for the elements of x.
    @param[in, out]
    y         device pointer storing vector y.
    @param[in]
    y_type [rocblas_datatype]
          specifies the datatype of vector y.
    @param[in]
    incy      [rocblas_int]
              specifies the increment for the elements of y.
    @param[in]
    execution_type [rocblas_datatype]
                  specifies the datatype of computation.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_axpy_ex",
        fn (
            Handle,
            Int32,
            OpaquePointer,
            DataType,
            OpaquePointer,
            DataType,
            Int32,
            OpaquePointer,
            DataType,
            Int32,
            DataType,
        ) -> Status,
    ]()(
        handle,
        n,
        alpha,
        alpha_type,
        x,
        x_type,
        incx,
        y,
        y_type,
        incy,
        execution_type,
    )


fn rocblas_zrotg_batched(
    handle: Handle,
    a: OpaquePointer,
    b: OpaquePointer,
    c: OpaquePointer,
    s: OpaquePointer,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_zrotg_batched",
        fn (
            Handle,
            OpaquePointer,
            OpaquePointer,
            OpaquePointer,
            OpaquePointer,
            Int32,
        ) -> Status,
    ]()(handle, a, b, c, s, batch_count)


fn rocblas_get_version_string(buf: UnsafePointer[Int8], len: Int) -> Status:
    """\\brief   Loads char* buf with the rocblas library version. size_t len
    is the maximum length of char* buf.

    \\details

    @param[in, out]
    buf             pointer to buffer for version string

    @param[in]
    len             length of buf

    ****************************************************************************.
    """
    return _get_dylib_function[
        "rocblas_get_version_string", fn (UnsafePointer[Int8], Int) -> Status
    ]()(buf, len)


fn rocblas_csyr2_strided_batched_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    alpha: UnsafePointer[ComplexFloat32],
    x: UnsafePointer[ComplexFloat32],
    incx: Int64,
    stridex: Int64,
    y: UnsafePointer[ComplexFloat32],
    incy: Int64,
    stridey: Int64,
    _a: UnsafePointer[ComplexFloat32],
    lda: Int64,
    stride_a: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_csyr2_strided_batched_64",
        fn (
            Handle,
            Fill,
            Int64,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int64,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int64,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int64,
            Int64,
            Int64,
        ) -> Status,
    ]()(
        handle,
        uplo,
        n,
        alpha,
        x,
        incx,
        stridex,
        y,
        incy,
        stridey,
        _a,
        lda,
        stride_a,
        batch_count,
    )


fn rocblas_dsyr_strided_batched(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    alpha: UnsafePointer[Float64],
    x: UnsafePointer[Float64],
    incx: Int32,
    stridex: Int64,
    _a: UnsafePointer[Float64],
    lda: Int32,
    stride_a: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_dsyr_strided_batched",
        fn (
            Handle,
            Fill,
            Int32,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int32,
            Int64,
            UnsafePointer[Float64],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle, uplo, n, alpha, x, incx, stridex, _a, lda, stride_a, batch_count
    )


fn rocblas_ssymm_strided_batched(
    handle: Handle,
    side: Side,
    uplo: Fill,
    m: Int32,
    n: Int32,
    alpha: UnsafePointer[Float32],
    _a: UnsafePointer[Float32],
    lda: Int32,
    stride__a: Int64,
    _b: UnsafePointer[Float32],
    ldb: Int32,
    stride__b: Int64,
    beta: UnsafePointer[Float32],
    _c: UnsafePointer[Float32],
    ldc: Int32,
    stride__c: Int64,
    batch_count: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 3 API </b>.

    \\details
    symm_strided_batched performs a batch of the matrix-matrix operations:

        C_i := alpha*A_i*B_i + beta*C_i if side == rocblas_side_left,
        C_i := alpha*B_i*A_i + beta*C_i if side == rocblas_side_right,

        where alpha and beta are scalars, B_i and C_i are m by n matrices, and
        A_i is a symmetric matrix stored as either upper or lower.

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.

    @param[in]
    side  [rocblas_side]
            - rocblas_side_left:      C_i := alpha*A_i*B_i + beta*C_i
            - rocblas_side_right:     C_i := alpha*B_i*A_i + beta*C_i

    @param[in]
    uplo    [rocblas_fill]
            - rocblas_fill_upper:  A_i is an upper triangular matrix
            - rocblas_fill_lower:  A_i is a  lower triangular matrix

    @param[in]
    m       [rocblas_int]
            m specifies the number of rows of B_i and C_i. m >= 0.

    @param[in]
    n       [rocblas_int]
            n specifies the number of columns of B_i and C_i. n >= 0.

    @param[in]
    alpha
            alpha specifies the scalar alpha. When alpha is
            zero then A_i and B_i are not referenced.

    @param[in]
    A       device pointer to first matrix A_1
            - A_i is m by m if side == rocblas_side_left
            - A_i is n by n if side == rocblas_side_right
            only the upper/lower triangular part is accessed.

    @param[in]
    lda     [rocblas_int]
            lda specifies the first dimension of A_i.

                if side = rocblas_side_left,  lda >= max( 1, m ),
                otherwise lda >= max( 1, n ).

    @param[in]
    stride_A  [rocblas_stride]
              stride from the start of one matrix (A_i) and the next one (A_i+1).

    @param[in]
    B       device pointer to first matrix B_1 of dimension (ldb, n) on the GPU.

    @param[in]
    ldb     [rocblas_int]
            ldb specifies the first dimension of B_i. ldb >= max( 1, m ).

    @param[in]
    stride_B  [rocblas_stride]
              stride from the start of one matrix (B_i) and the next one (B_i+1).
    @param[in]
    beta
            beta specifies the scalar beta. When beta is
            zero then C need not be set before entry.

    @param[in]
    C        device pointer to first matrix C_1 of dimension (ldc, n) on the GPU.

    @param[in]
    ldc    [rocblas_int]
           ldc specifies the first dimension of C. ldc >= max( 1, m ).

    @param[in, out]
    stride_C  [rocblas_stride]
              stride from the start of one matrix (C_i) and the next one (C_i+1).

    @param[in]
    batch_count [rocblas_int]
                number of instances in the batch.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_ssymm_strided_batched",
        fn (
            Handle,
            Side,
            Fill,
            Int32,
            Int32,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int32,
            Int64,
            UnsafePointer[Float32],
            Int32,
            Int64,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        side,
        uplo,
        m,
        n,
        alpha,
        _a,
        lda,
        stride__a,
        _b,
        ldb,
        stride__b,
        beta,
        _c,
        ldc,
        stride__c,
        batch_count,
    )


fn rocblas_idamax_strided_batched_64(
    handle: Handle,
    n: Int64,
    x: UnsafePointer[Float64],
    incx: Int64,
    stridex: Int64,
    batch_count: Int64,
    result: UnsafePointer[Int64],
) -> Status:
    return _get_dylib_function[
        "rocblas_idamax_strided_batched_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[Float64],
            Int64,
            Int64,
            Int64,
            UnsafePointer[Int64],
        ) -> Status,
    ]()(handle, n, x, incx, stridex, batch_count, result)


fn rocblas_rot_strided_batched_ex_64(
    handle: Handle,
    n: Int64,
    x: OpaquePointer,
    x_type: DataType,
    incx: Int64,
    stride_x: Int64,
    y: OpaquePointer,
    y_type: DataType,
    incy: Int64,
    stride_y: Int64,
    c: OpaquePointer,
    s: OpaquePointer,
    cs_type: DataType,
    batch_count: Int64,
    execution_type: DataType,
) -> Status:
    return _get_dylib_function[
        "rocblas_rot_strided_batched_ex_64",
        fn (
            Handle,
            Int64,
            OpaquePointer,
            DataType,
            Int64,
            Int64,
            OpaquePointer,
            DataType,
            Int64,
            Int64,
            OpaquePointer,
            OpaquePointer,
            DataType,
            Int64,
            DataType,
        ) -> Status,
    ]()(
        handle,
        n,
        x,
        x_type,
        incx,
        stride_x,
        y,
        y_type,
        incy,
        stride_y,
        c,
        s,
        cs_type,
        batch_count,
        execution_type,
    )


fn rocblas_sswap_batched_64(
    handle: Handle,
    n: Int64,
    x: OpaquePointer,
    incx: Int64,
    y: OpaquePointer,
    incy: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_sswap_batched_64",
        fn (
            Handle,
            Int64,
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, n, x, incx, y, incy, batch_count)


fn rocblas_chbmv_batched_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    k: Int64,
    alpha: UnsafePointer[ComplexFloat32],
    _a: OpaquePointer,
    lda: Int64,
    x: OpaquePointer,
    incx: Int64,
    beta: UnsafePointer[ComplexFloat32],
    y: OpaquePointer,
    incy: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_chbmv_batched_64",
        fn (
            Handle,
            Fill,
            Int64,
            Int64,
            UnsafePointer[ComplexFloat32],
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            UnsafePointer[ComplexFloat32],
            OpaquePointer,
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, uplo, n, k, alpha, _a, lda, x, incx, beta, y, incy, batch_count)


fn rocblas_sdot_batched(
    handle: Handle,
    n: Int32,
    x: OpaquePointer,
    incx: Int32,
    y: OpaquePointer,
    incy: Int32,
    batch_count: Int32,
    result: UnsafePointer[Float32],
) -> Status:
    """
    \\brief <b> BLAS Level 1 API </b>.

    \\details
    dot_batched(u) performs a batch of dot products of vectors x and y:

        result_i = x_i * y_i;

    dotc_batched  performs a batch of dot products of the conjugate of complex vector x and complex vector y

        result_i = conjugate (x_i) * y_i;
        where (x_i, y_i) is the i-th instance of the batch.
        x_i and y_i are vectors, for i = 1, ..., batch_count.

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    n         [rocblas_int]
              the number of elements in each x_i and y_i.
    @param[in]
    x         device array of device pointers storing each vector x_i.
    @param[in]
    incx      [rocblas_int]
              specifies the increment for the elements of each x_i.
    @param[in]
    y         device array of device pointers storing each vector y_i.
    @param[in]
    incy      [rocblas_int]
              specifies the increment for the elements of each y_i.
    @param[in]
    batch_count [rocblas_int]
                number of instances in the batch.
    @param[in, out]
    result
              device array or host array of batch_count size to store the dot products of each batch.
              return 0.0 for each element if n <= 0.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_sdot_batched",
        fn (
            Handle,
            Int32,
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            Int32,
            UnsafePointer[Float32],
        ) -> Status,
    ]()(handle, n, x, incx, y, incy, batch_count, result)


fn rocblas_dtrsm_strided_batched_64(
    handle: Handle,
    side: Side,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    m: Int64,
    n: Int64,
    alpha: UnsafePointer[Float64],
    _a: UnsafePointer[Float64],
    lda: Int64,
    stride_a: Int64,
    _b: UnsafePointer[Float64],
    ldb: Int64,
    stride_b: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_dtrsm_strided_batched_64",
        fn (
            Handle,
            Side,
            Fill,
            Operation,
            Diagonal,
            Int64,
            Int64,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int64,
            Int64,
            UnsafePointer[Float64],
            Int64,
            Int64,
            Int64,
        ) -> Status,
    ]()(
        handle,
        side,
        uplo,
        trans_a,
        diag,
        m,
        n,
        alpha,
        _a,
        lda,
        stride_a,
        _b,
        ldb,
        stride_b,
        batch_count,
    )


fn rocblas_isamin_strided_batched(
    handle: Handle,
    n: Int32,
    x: UnsafePointer[Float32],
    incx: Int32,
    stridex: Int64,
    batch_count: Int32,
    result: UnsafePointer[Int32],
) -> Status:
    """
    \\brief <b> BLAS Level 1 API </b>.

    \\details
     amin_strided_batched finds the first index of the element of minimum magnitude of each vector x_i in a batch, for i = 1, ..., batch_count.

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    n         [rocblas_int]
              number of elements in each vector x_i.
    @param[in]
    x         device pointer to the first vector x_1.
    @param[in]
    incx      [rocblas_int]
              specifies the increment for the elements of each x_i. incx must be > 0.
    @param[in]
    stridex   [rocblas_stride]
              specifies the pointer increment between one x_i and the next x_(i + 1).
    @param[in]
    batch_count [rocblas_int]
              number of instances in the batch.
    @param[out]
    result
              device or host pointer to array for storing contiguous batch_count results.
              return is 0 if n <= 0, incx<=0.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_isamin_strided_batched",
        fn (
            Handle,
            Int32,
            UnsafePointer[Float32],
            Int32,
            Int64,
            Int32,
            UnsafePointer[Int32],
        ) -> Status,
    ]()(handle, n, x, incx, stridex, batch_count, result)


fn rocblas_cgeam_strided_batched(
    handle: Handle,
    trans_a: Operation,
    trans_b: Operation,
    m: Int32,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat32],
    _a: UnsafePointer[ComplexFloat32],
    lda: Int32,
    stride__a: Int64,
    beta: UnsafePointer[ComplexFloat32],
    _b: UnsafePointer[ComplexFloat32],
    ldb: Int32,
    stride__b: Int64,
    _c: UnsafePointer[ComplexFloat32],
    ldc: Int32,
    stride__c: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_cgeam_strided_batched",
        fn (
            Handle,
            Operation,
            Operation,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        trans_a,
        trans_b,
        m,
        n,
        alpha,
        _a,
        lda,
        stride__a,
        beta,
        _b,
        ldb,
        stride__b,
        _c,
        ldc,
        stride__c,
        batch_count,
    )


fn rocblas_ccopy_batched(
    handle: Handle,
    n: Int32,
    x: OpaquePointer,
    incx: Int32,
    y: OpaquePointer,
    incy: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_ccopy_batched",
        fn (
            Handle,
            Int32,
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(handle, n, x, incx, y, incy, batch_count)


fn rocblas_sgbmv_64(
    handle: Handle,
    trans: Operation,
    m: Int64,
    n: Int64,
    kl: Int64,
    ku: Int64,
    alpha: UnsafePointer[Float32],
    _a: UnsafePointer[Float32],
    lda: Int64,
    x: UnsafePointer[Float32],
    incx: Int64,
    beta: UnsafePointer[Float32],
    y: UnsafePointer[Float32],
    incy: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_sgbmv_64",
        fn (
            Handle,
            Operation,
            Int64,
            Int64,
            Int64,
            Int64,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int64,
            UnsafePointer[Float32],
            Int64,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int64,
        ) -> Status,
    ]()(handle, trans, m, n, kl, ku, alpha, _a, lda, x, incx, beta, y, incy)


fn rocblas_device_malloc_success(
    ptr: UnsafePointer[MallocBase],
) -> Bool:
    return _get_dylib_function[
        "rocblas_device_malloc_success",
        fn (UnsafePointer[MallocBase]) -> Bool,
    ]()(ptr)


fn rocblas_chpr_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    alpha: UnsafePointer[Float32],
    x: UnsafePointer[ComplexFloat32],
    incx: Int64,
    _ap: UnsafePointer[ComplexFloat32],
) -> Status:
    return _get_dylib_function[
        "rocblas_chpr_64",
        fn (
            Handle,
            Fill,
            Int64,
            UnsafePointer[Float32],
            UnsafePointer[ComplexFloat32],
            Int64,
            UnsafePointer[ComplexFloat32],
        ) -> Status,
    ]()(handle, uplo, n, alpha, x, incx, _ap)


fn rocblas_stpsv(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int32,
    _ap: UnsafePointer[Float32],
    x: UnsafePointer[Float32],
    incx: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 2 API </b>.

    \\details
    tpsv solves:

         A*x = b or
         A**T*x = b or
         A**H*x = b
         where x and b are vectors and A is a triangular matrix stored in the packed format.

    The input vector b is overwritten by the output vector x.

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.

    @param[in]
    uplo    [rocblas_fill]
            - rocblas_fill_upper:  A is an upper triangular matrix.
            - rocblas_fill_lower:  A is a  lower triangular matrix.

    @param[in]
    transA  [rocblas_operation]
            - rocblas_operation_none: Solves A*x = b
            - rocblas_operation_transpose: Solves A**T*x = b
            - rocblas_operation_conjugate_transpose: Solves A**H*x = b

    @param[in]
    diag    [rocblas_diagonal]
            - rocblas_diagonal_unit:  A is assumed to be unit triangular (i.e. the diagonal elements
            of A are not used in computations).
            - rocblas_diagonal_non_unit: A is not assumed to be unit triangular.

    @param[in]
    n         [rocblas_int]
              n specifies the number of rows of b. n >= 0.

    @param[in]
    AP        device pointer storing the packed version of matrix A,
              of dimension >= (n * (n + 1) / 2).

    @param[in, out]
    x         device pointer storing vector b on input, overwritten by x on output.

    @param[in]
    incx      [rocblas_int]
              specifies the increment for the elements of x.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_stpsv",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int32,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int32,
        ) -> Status,
    ]()(handle, uplo, trans_a, diag, n, _ap, x, incx)


fn rocblas_csyrkx_strided_batched(
    handle: Handle,
    uplo: Fill,
    trans: Operation,
    n: Int32,
    k: Int32,
    alpha: UnsafePointer[ComplexFloat32],
    _a: UnsafePointer[ComplexFloat32],
    lda: Int32,
    stride__a: Int64,
    _b: UnsafePointer[ComplexFloat32],
    ldb: Int32,
    stride__b: Int64,
    beta: UnsafePointer[ComplexFloat32],
    _c: UnsafePointer[ComplexFloat32],
    ldc: Int32,
    stride__c: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_csyrkx_strided_batched",
        fn (
            Handle,
            Fill,
            Operation,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        uplo,
        trans,
        n,
        k,
        alpha,
        _a,
        lda,
        stride__a,
        _b,
        ldb,
        stride__b,
        beta,
        _c,
        ldc,
        stride__c,
        batch_count,
    )


fn rocblas_dger_strided_batched_64(
    handle: Handle,
    m: Int64,
    n: Int64,
    alpha: UnsafePointer[Float64],
    x: UnsafePointer[Float64],
    incx: Int64,
    stridex: Int64,
    y: UnsafePointer[Float64],
    incy: Int64,
    stridey: Int64,
    _a: UnsafePointer[Float64],
    lda: Int64,
    stride_a: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_dger_strided_batched_64",
        fn (
            Handle,
            Int64,
            Int64,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int64,
            Int64,
            UnsafePointer[Float64],
            Int64,
            Int64,
            UnsafePointer[Float64],
            Int64,
            Int64,
            Int64,
        ) -> Status,
    ]()(
        handle,
        m,
        n,
        alpha,
        x,
        incx,
        stridex,
        y,
        incy,
        stridey,
        _a,
        lda,
        stride_a,
        batch_count,
    )


fn rocblas_ctrmv_strided_batched(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int32,
    _a: UnsafePointer[ComplexFloat32],
    lda: Int32,
    stride__a: Int64,
    x: UnsafePointer[ComplexFloat32],
    incx: Int32,
    stride_x: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_ctrmv_strided_batched",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int32,
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        uplo,
        trans_a,
        diag,
        n,
        _a,
        lda,
        stride__a,
        x,
        incx,
        stride_x,
        batch_count,
    )


fn rocblas_zrot_strided_batched(
    handle: Handle,
    n: Int32,
    x: UnsafePointer[ComplexFloat64],
    incx: Int32,
    stride_x: Int64,
    y: UnsafePointer[ComplexFloat64],
    incy: Int32,
    stride_y: Int64,
    c: UnsafePointer[Float64],
    s: UnsafePointer[ComplexFloat64],
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_zrot_strided_batched",
        fn (
            Handle,
            Int32,
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            UnsafePointer[Float64],
            UnsafePointer[ComplexFloat64],
            Int32,
        ) -> Status,
    ]()(handle, n, x, incx, stride_x, y, incy, stride_y, c, s, batch_count)


fn rocblas_hgemm_kernel_name(
    handle: Handle,
    trans_a: Operation,
    trans_b: Operation,
    m: Int32,
    n: Int32,
    k: Int32,
    alpha: UnsafePointer[Float16],
    _a: UnsafePointer[Float16],
    lda: Int32,
    stride_a: Int64,
    _b: UnsafePointer[Float16],
    ldb: Int32,
    stride_b: Int64,
    beta: UnsafePointer[Float16],
    _c: UnsafePointer[Float16],
    ldc: Int32,
    stride_c: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_hgemm_kernel_name",
        fn (
            Handle,
            Operation,
            Operation,
            Int32,
            Int32,
            Int32,
            UnsafePointer[Float16],
            UnsafePointer[Float16],
            Int32,
            Int64,
            UnsafePointer[Float16],
            Int32,
            Int64,
            UnsafePointer[Float16],
            UnsafePointer[Float16],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        trans_a,
        trans_b,
        m,
        n,
        k,
        alpha,
        _a,
        lda,
        stride_a,
        _b,
        ldb,
        stride_b,
        beta,
        _c,
        ldc,
        stride_c,
        batch_count,
    )


fn rocblas_scopy_strided_batched_64(
    handle: Handle,
    n: Int64,
    x: UnsafePointer[Float32],
    incx: Int64,
    stridex: Int64,
    y: UnsafePointer[Float32],
    incy: Int64,
    stridey: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_scopy_strided_batched_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[Float32],
            Int64,
            Int64,
            UnsafePointer[Float32],
            Int64,
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, n, x, incx, stridex, y, incy, stridey, batch_count)


fn rocblas_icamax_strided_batched(
    handle: Handle,
    n: Int32,
    x: UnsafePointer[ComplexFloat32],
    incx: Int32,
    stridex: Int64,
    batch_count: Int32,
    result: UnsafePointer[Int32],
) -> Status:
    return _get_dylib_function[
        "rocblas_icamax_strided_batched",
        fn (
            Handle,
            Int32,
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            Int32,
            UnsafePointer[Int32],
        ) -> Status,
    ]()(handle, n, x, incx, stridex, batch_count, result)


fn rocblas_zhpr_strided_batched_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    alpha: UnsafePointer[Float64],
    x: UnsafePointer[ComplexFloat64],
    incx: Int64,
    stride_x: Int64,
    _ap: UnsafePointer[ComplexFloat64],
    stride__a: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_zhpr_strided_batched_64",
        fn (
            Handle,
            Fill,
            Int64,
            UnsafePointer[Float64],
            UnsafePointer[ComplexFloat64],
            Int64,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, uplo, n, alpha, x, incx, stride_x, _ap, stride__a, batch_count)


fn rocblas_ztrsm_64(
    handle: Handle,
    side: Side,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    m: Int64,
    n: Int64,
    alpha: UnsafePointer[ComplexFloat64],
    _a: UnsafePointer[ComplexFloat64],
    lda: Int64,
    _b: UnsafePointer[ComplexFloat64],
    ldb: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_ztrsm_64",
        fn (
            Handle,
            Side,
            Fill,
            Operation,
            Diagonal,
            Int64,
            Int64,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int64,
            UnsafePointer[ComplexFloat64],
            Int64,
        ) -> Status,
    ]()(handle, side, uplo, trans_a, diag, m, n, alpha, _a, lda, _b, ldb)


fn rocblas_stpsv_strided_batched_64(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int64,
    _ap: UnsafePointer[Float32],
    stride__a: Int64,
    x: UnsafePointer[Float32],
    incx: Int64,
    stride_x: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_stpsv_strided_batched_64",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int64,
            UnsafePointer[Float32],
            Int64,
            UnsafePointer[Float32],
            Int64,
            Int64,
            Int64,
        ) -> Status,
    ]()(
        handle,
        uplo,
        trans_a,
        diag,
        n,
        _ap,
        stride__a,
        x,
        incx,
        stride_x,
        batch_count,
    )


fn rocblas_csyr_batched_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    alpha: UnsafePointer[ComplexFloat32],
    x: OpaquePointer,
    incx: Int64,
    _a: OpaquePointer,
    lda: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_csyr_batched_64",
        fn (
            Handle,
            Fill,
            Int64,
            UnsafePointer[ComplexFloat32],
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, uplo, n, alpha, x, incx, _a, lda, batch_count)


fn rocblas_ctpmv_64(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int64,
    _a: UnsafePointer[ComplexFloat32],
    x: UnsafePointer[ComplexFloat32],
    incx: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_ctpmv_64",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int64,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int64,
        ) -> Status,
    ]()(handle, uplo, trans_a, diag, n, _a, x, incx)


fn rocblas_strmm_batched(
    handle: Handle,
    side: Side,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    m: Int32,
    n: Int32,
    alpha: UnsafePointer[Float32],
    _a: OpaquePointer,
    lda: Int32,
    _b: OpaquePointer,
    ldb: Int32,
    _c: OpaquePointer,
    ldc: Int32,
    batch_count: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 3 API </b>.

    \\details
    trmm_batched performs one of the matrix-matrix operations:

        C_i := alpha*op( A_i )*B_i,   or
        C_i := alpha*B_i*op( A_i )  for i = 0, 1, ... batch_count -1,

    The Legacy BLAS in-place trmm_batched functionality,

        B_i := alpha*op( A_i )*B_i,   or
        B_i := alpha*B_i*op( A_i )  for i = 0, 1, ... batch_count -1,

    is available by setting pointer C equal to pointer B and ldc equal to ldb.

        alpha  is a scalar,  B_i  is an m by n matrix, C_i  is an m by n matrix,  A_i  is a unit, or
        non-unit,  upper or lower triangular matrix  and  op( A_i )  is one  of

        op( A_i ) = A_i     or
        op( A_i ) = A_i^T   or
        op( A_i ) = A_i^H.

        When uplo == rocblas_fill_upper the  leading  k by k
        upper triangular part of the array  A must contain the upper
        triangular matrix and the strictly lower triangular part of
        A is not referenced. Here k is m when side == rocblas_side_left
        and is n when side == rocblas_side_right.

        When uplo == rocblas_fill_lower the  leading  k by k
        lower triangular part of the array  A must contain the lower
        triangular matrix  and the strictly upper triangular part of
        A is not referenced. Here k is m when  side == rocblas_side_left
        and is n when side == rocblas_side_right.

        Note that when  diag == rocblas_diagonal_unit  the diagonal elements of
        A  are not referenced either,  but are assumed to be  unity.

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.

    @param[in]
    side    [rocblas_side]
            Specifies whether op(A_i) multiplies B_i from the left or right as follows:
            - rocblas_side_left:       C_i := alpha*op( A_i )*B_i
            - rocblas_side_right:      C_i := alpha*B_i*op( A_i )

    @param[in]
    uplo    [rocblas_fill]
            Specifies whether the matrix A is an upper or lower triangular matrix as follows:
            - rocblas_fill_upper:  A is an upper triangular matrix.
            - rocblas_fill_lower:  A is a  lower triangular matrix.

    @param[in]
    transA  [rocblas_operation]
            Specifies the form of op(A_i) to be used in the matrix multiplication as follows:
            - rocblas_operation_none:    op(A_i) = A_i
            - rocblas_operation_transpose:      op(A_i) = A_i^T
            - rocblas_operation_conjugate_transpose:  op(A_i) = A_i^H

    @param[in]
    diag    [rocblas_diagonal]
            Specifies whether or not A_i is unit triangular as follows:
            - rocblas_diagonal_unit:      A_i is assumed to be unit triangular.
            - rocblas_diagonal_non_unit:  A_i is not assumed to be unit triangular.

    @param[in]
    m       [rocblas_int]
            m specifies the number of rows of B_i. m >= 0.

    @param[in]
    n       [rocblas_int]
            n specifies the number of columns of B_i. n >= 0.

    @param[in]
    alpha
            alpha specifies the scalar alpha. When alpha is
            zero then A_i is not referenced and B_i need not be set before
            entry.

    @param[in]
    A       Device array of device pointers storing each matrix A_i on the GPU.
            Each A_i is of dimension ( lda, k ), where k is m
            when  side == rocblas_side_left  and
            is  n  when  side == rocblas_side_right.

            When uplo == rocblas_fill_upper the  leading  k by k
            upper triangular part of the array  A must contain the upper
            triangular matrix  and the strictly lower triangular part of
            A is not referenced.

            When uplo == rocblas_fill_lower the  leading  k by k
            lower triangular part of the array  A must contain the lower
            triangular matrix  and the strictly upper triangular part of
            A is not referenced.

        Note that when  diag == rocblas_diagonal_unit  the diagonal elements of
        A_i  are not referenced either,  but are assumed to be  unity.

    @param[in]
    lda     [rocblas_int]
            lda specifies the first dimension of A.

                if side == rocblas_side_left,  lda >= max( 1, m ),
                if side == rocblas_side_right, lda >= max( 1, n ).

    @param[in]
    B       device array of device pointers storing each matrix B_i on the GPU.

    @param[in]
    ldb    [rocblas_int]
           ldb specifies the first dimension of B_i. ldb >= max( 1, m ).

    @param[out]
    C      device array of device pointers storing each matrix C_i on the GPU.

    @param[in]
    ldc   [rocblas_int]
          ldc specifies the first dimension of C. ldc >= max( 1, m).
          If B and C are pointers to the same array of pointers then ldc must
          equal ldb or rocblas_status_invalid_value will be returned.

    @param[in]
    batch_count [rocblas_int]
                number of instances i in the batch.
    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_strmm_batched",
        fn (
            Handle,
            Side,
            Fill,
            Operation,
            Diagonal,
            Int32,
            Int32,
            UnsafePointer[Float32],
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(
        handle,
        side,
        uplo,
        trans_a,
        diag,
        m,
        n,
        alpha,
        _a,
        lda,
        _b,
        ldb,
        _c,
        ldc,
        batch_count,
    )


fn rocblas_ztrsm(
    handle: Handle,
    side: Side,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    m: Int32,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat64],
    _a: UnsafePointer[ComplexFloat64],
    lda: Int32,
    _b: UnsafePointer[ComplexFloat64],
    ldb: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_ztrsm",
        fn (
            Handle,
            Side,
            Fill,
            Operation,
            Diagonal,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int32,
            UnsafePointer[ComplexFloat64],
            Int32,
        ) -> Status,
    ]()(handle, side, uplo, trans_a, diag, m, n, alpha, _a, lda, _b, ldb)


fn rocblas_zdgmm_strided_batched(
    handle: Handle,
    side: Side,
    m: Int32,
    n: Int32,
    _a: UnsafePointer[ComplexFloat64],
    lda: Int32,
    stride__a: Int64,
    x: UnsafePointer[ComplexFloat64],
    incx: Int32,
    stride_x: Int64,
    _c: UnsafePointer[ComplexFloat64],
    ldc: Int32,
    stride__c: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_zdgmm_strided_batched",
        fn (
            Handle,
            Side,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        side,
        m,
        n,
        _a,
        lda,
        stride__a,
        x,
        incx,
        stride_x,
        _c,
        ldc,
        stride__c,
        batch_count,
    )


fn rocblas_icamin_64(
    handle: Handle,
    n: Int64,
    x: UnsafePointer[ComplexFloat32],
    incx: Int64,
    result: UnsafePointer[Int64],
) -> Status:
    return _get_dylib_function[
        "rocblas_icamin_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int64,
            UnsafePointer[Int64],
        ) -> Status,
    ]()(handle, n, x, incx, result)


fn rocblas_dsyr2k(
    handle: Handle,
    uplo: Fill,
    trans: Operation,
    n: Int32,
    k: Int32,
    alpha: UnsafePointer[Float64],
    _a: UnsafePointer[Float64],
    lda: Int32,
    _b: UnsafePointer[Float64],
    ldb: Int32,
    beta: UnsafePointer[Float64],
    _c: UnsafePointer[Float64],
    ldc: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_dsyr2k",
        fn (
            Handle,
            Fill,
            Operation,
            Int32,
            Int32,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int32,
            UnsafePointer[Float64],
            Int32,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int32,
        ) -> Status,
    ]()(handle, uplo, trans, n, k, alpha, _a, lda, _b, ldb, beta, _c, ldc)


fn rocblas_zrotg_batched_64(
    handle: Handle,
    a: OpaquePointer,
    b: OpaquePointer,
    c: OpaquePointer,
    s: OpaquePointer,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_zrotg_batched_64",
        fn (
            Handle,
            OpaquePointer,
            OpaquePointer,
            OpaquePointer,
            OpaquePointer,
            Int64,
        ) -> Status,
    ]()(handle, a, b, c, s, batch_count)


fn rocblas_dtrmm_strided_batched(
    handle: Handle,
    side: Side,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    m: Int32,
    n: Int32,
    alpha: UnsafePointer[Float64],
    _a: UnsafePointer[Float64],
    lda: Int32,
    stride__a: Int64,
    _b: UnsafePointer[Float64],
    ldb: Int32,
    stride__b: Int64,
    _c: UnsafePointer[Float64],
    ldc: Int32,
    stride__c: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_dtrmm_strided_batched",
        fn (
            Handle,
            Side,
            Fill,
            Operation,
            Diagonal,
            Int32,
            Int32,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int32,
            Int64,
            UnsafePointer[Float64],
            Int32,
            Int64,
            UnsafePointer[Float64],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        side,
        uplo,
        trans_a,
        diag,
        m,
        n,
        alpha,
        _a,
        lda,
        stride__a,
        _b,
        ldb,
        stride__b,
        _c,
        ldc,
        stride__c,
        batch_count,
    )


fn rocblas_drot_batched(
    handle: Handle,
    n: Int32,
    x: OpaquePointer,
    incx: Int32,
    y: OpaquePointer,
    incy: Int32,
    c: UnsafePointer[Float64],
    s: UnsafePointer[Float64],
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_drot_batched",
        fn (
            Handle,
            Int32,
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int32,
        ) -> Status,
    ]()(handle, n, x, incx, y, incy, c, s, batch_count)


fn rocblas_zgemv_strided_batched(
    handle: Handle,
    trans_a: Operation,
    m: Int32,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat64],
    _a: UnsafePointer[ComplexFloat64],
    lda: Int32,
    stride_a: Int64,
    x: UnsafePointer[ComplexFloat64],
    incx: Int32,
    stridex: Int64,
    beta: UnsafePointer[ComplexFloat64],
    y: UnsafePointer[ComplexFloat64],
    incy: Int32,
    stridey: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_zgemv_strided_batched",
        fn (
            Handle,
            Operation,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        trans_a,
        m,
        n,
        alpha,
        _a,
        lda,
        stride_a,
        x,
        incx,
        stridex,
        beta,
        y,
        incy,
        stridey,
        batch_count,
    )


fn rocblas_dtrtri_batched(
    handle: Handle,
    uplo: Fill,
    diag: Diagonal,
    n: Int32,
    _a: OpaquePointer,
    lda: Int32,
    inv_a: OpaquePointer,
    ldinv_a: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_dtrtri_batched",
        fn (
            Handle,
            Fill,
            Diagonal,
            Int32,
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(handle, uplo, diag, n, _a, lda, inv_a, ldinv_a, batch_count)


fn rocblas_cgemv_batched_64(
    handle: Handle,
    trans: Operation,
    m: Int64,
    n: Int64,
    alpha: UnsafePointer[ComplexFloat32],
    _a: OpaquePointer,
    lda: Int64,
    x: OpaquePointer,
    incx: Int64,
    beta: UnsafePointer[ComplexFloat32],
    y: OpaquePointer,
    incy: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_cgemv_batched_64",
        fn (
            Handle,
            Operation,
            Int64,
            Int64,
            UnsafePointer[ComplexFloat32],
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            UnsafePointer[ComplexFloat32],
            OpaquePointer,
            Int64,
            Int64,
        ) -> Status,
    ]()(
        handle, trans, m, n, alpha, _a, lda, x, incx, beta, y, incy, batch_count
    )


fn rocblas_strmv_strided_batched(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int32,
    _a: UnsafePointer[Float32],
    lda: Int32,
    stride__a: Int64,
    x: UnsafePointer[Float32],
    incx: Int32,
    stride_x: Int64,
    batch_count: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 2 API </b>.

    \\details
    trmv_strided_batched performs one of the matrix-vector operations:

        x_i = A_i*x_i or
        x_i = A_i**T*x_i, or
        x_i = A_i**H*x_i, 0 < i < batch_count
        where x_i is an n element vector and A_i is an n by n (unit, or non-unit, upper or lower triangular matrix)
        with strides specifying how to retrieve $x_i$ (resp. $A_i$) from $x_{i-1}$ (resp. $A_i$).

    The vectors x_i are overwritten.

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.

    @param[in]
    uplo    [rocblas_fill]
            - rocblas_fill_upper:  A_i is an upper triangular matrix.
            - rocblas_fill_lower:  A_i is a  lower triangular matrix.

    @param[in]
    transA     [rocblas_operation]
            - rocblas_operation_none:    op(A) = A.
            - rocblas_operation_transpose:   op(A) = A^T
            - rocblas_operation_conjugate_transpose:  op(A) = A^H

    @param[in]
    diag    [rocblas_diagonal]
            - rocblas_diagonal_unit:     A_i is assumed to be unit triangular.
            - rocblas_diagonal_non_unit:  A_i is not assumed to be unit triangular.

    @param[in]
    n         [rocblas_int]
              n specifies the number of rows of matrices A_i. n >= 0.

    @param[in]
    A         device pointer to the matrix A_1 of the batch, of dimension ( lda, n ). If uplo == rocblas_fill_upper, the upper triangular part of the leading n-by-n array contains the matrix A_i, otherwise the lower triangular part of the leading n-by-n array contains the matrix A_i.

    @param[in]
    lda       [rocblas_int]
              specifies the leading dimension of A_i. lda must be at least max( 1, n ).

    @param[in]
    stride_A  [rocblas_stride]
              stride from the start of one A_i matrix to the next A_{i + 1}.

    @param[in, out]
    x         device pointer to the vector x_1 of the batch. On exit, each x_i is overwritten with the transformed vector x_i.

    @param[in]
    incx      [rocblas_int]
              specifies the increment for the elements of one vector x.

    @param[in]
    stride_x  [rocblas_stride]
              stride from the start of one x_i vector to the next x_{i + 1}.

    @param[in]
    batch_count [rocblas_int]
              The number of batched matrices/vectors.


    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_strmv_strided_batched",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int32,
            UnsafePointer[Float32],
            Int32,
            Int64,
            UnsafePointer[Float32],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        uplo,
        trans_a,
        diag,
        n,
        _a,
        lda,
        stride__a,
        x,
        incx,
        stride_x,
        batch_count,
    )


fn rocblas_dznrm2_64(
    handle: Handle,
    n: Int64,
    x: UnsafePointer[ComplexFloat64],
    incx: Int64,
    result: UnsafePointer[Float64],
) -> Status:
    return _get_dylib_function[
        "rocblas_dznrm2_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int64,
            UnsafePointer[Float64],
        ) -> Status,
    ]()(handle, n, x, incx, result)


fn rocblas_zdscal_strided_batched(
    handle: Handle,
    n: Int32,
    alpha: UnsafePointer[Float64],
    x: UnsafePointer[ComplexFloat64],
    incx: Int32,
    stride_x: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_zdscal_strided_batched",
        fn (
            Handle,
            Int32,
            UnsafePointer[Float64],
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(handle, n, alpha, x, incx, stride_x, batch_count)


fn rocblas_daxpy_batched_64(
    handle: Handle,
    n: Int64,
    alpha: UnsafePointer[Float64],
    x: OpaquePointer,
    incx: Int64,
    y: OpaquePointer,
    incy: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_daxpy_batched_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[Float64],
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, n, alpha, x, incx, y, incy, batch_count)


fn rocblas_chpr_batched(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    alpha: UnsafePointer[Float32],
    x: OpaquePointer,
    incx: Int32,
    _ap: OpaquePointer,
    batch_count: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 2 API </b>.

    \\details
    hpr_batched performs the matrix-vector operations:

        A_i := A_i + alpha*x_i*x_i**H
        where alpha is a real scalar, x_i is a vector, and A_i is an
        n by n symmetric matrix, supplied in packed form, for i = 1, ..., batch_count.

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    uplo      [rocblas_fill]
            specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
            - rocblas_fill_upper: The upper triangular part of each A_i is supplied in AP.
            - rocblas_fill_lower: The lower triangular part of each A_i is supplied in AP.
    @param[in]
    n         [rocblas_int]
              the number of rows and columns of each matrix A_i. Must be at least 0.
    @param[in]
    alpha
              device pointer or host pointer to scalar alpha.
    @param[in]
    x         device array of device pointers storing each vector x_i.
    @param[in]
    incx      [rocblas_int]
              specifies the increment for the elements of each x_i.
    @param[in, out]
    AP        device array of device pointers storing the packed version of the specified triangular portion of
              each Hermitian matrix A_i of at least size ((n * (n + 1)) / 2). Array is of at least size batch_count.

                    if uplo == rocblas_fill_upper:
                        The upper triangular portion of each Hermitian matrix A_i is supplied.
                        The matrix is compacted so that AP contains the triangular portion
                        column-by-column
                        so that:
                        AP(0) = A(0,0)
                        AP(1) = A(0,1)
                        AP(2) = A(1,1), etc.
                        Ex: (rocblas_fill_upper; n = 3)
                            (1, 0) (2, 1) (4,9)
                            (2,-1) (3, 0) (5,3) ---> [(1,0),(2,1),(3,0),(4,9),(5,3),(6,0)]
                            (4,-9) (5,-3) (6,0)

                    if uplo == rocblas_fill_lower:
                        The lower triangular portion of each Hermitian matrix A_i is supplied.
                        The matrix is compacted so that AP contains the triangular portion
                        column-by-column
                        so that:
                        AP(0) = A(0,0)
                        AP(1) = A(1,0)
                        AP(2) = A(2,1), etc.
                        Ex: (rocblas_fill_lower; n = 3)
                            (1, 0) (2, 1) (4,9)
                            (2,-1) (3, 0) (5,3) ---> [(1,0),(2,-1),(4,-9),(3,0),(5,-3),(6,0)]
                            (4,-9) (5,-3) (6,0)
                    Note that the imaginary part of the diagonal elements are not accessed
                    and are assumed to be 0.
    @param[in]
    batch_count [rocblas_int]
                number of instances in the batch.
    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_chpr_batched",
        fn (
            Handle,
            Fill,
            Int32,
            UnsafePointer[Float32],
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
        ) -> Status,
    ]()(handle, uplo, n, alpha, x, incx, _ap, batch_count)


fn rocblas_dcopy_strided_batched_64(
    handle: Handle,
    n: Int64,
    x: UnsafePointer[Float64],
    incx: Int64,
    stridex: Int64,
    y: UnsafePointer[Float64],
    incy: Int64,
    stridey: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_dcopy_strided_batched_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[Float64],
            Int64,
            Int64,
            UnsafePointer[Float64],
            Int64,
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, n, x, incx, stridex, y, incy, stridey, batch_count)


fn rocblas_zcopy_strided_batched_64(
    handle: Handle,
    n: Int64,
    x: UnsafePointer[ComplexFloat64],
    incx: Int64,
    stridex: Int64,
    y: UnsafePointer[ComplexFloat64],
    incy: Int64,
    stridey: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_zcopy_strided_batched_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int64,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int64,
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, n, x, incx, stridex, y, incy, stridey, batch_count)


fn rocblas_ssyr2k(
    handle: Handle,
    uplo: Fill,
    trans: Operation,
    n: Int32,
    k: Int32,
    alpha: UnsafePointer[Float32],
    _a: UnsafePointer[Float32],
    lda: Int32,
    _b: UnsafePointer[Float32],
    ldb: Int32,
    beta: UnsafePointer[Float32],
    _c: UnsafePointer[Float32],
    ldc: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 3 API </b>.

    \\details
    syr2k performs one of the matrix-matrix operations for a symmetric rank-2k update:

        C := alpha*(op( A )*op( B )^T + op( B )*op( A )^T) + beta*C,

        where  alpha and beta are scalars, op(A) and op(B) are n by k matrix, and
        C is a symmetric n x n matrix stored as either upper or lower.

        op( A ) = A, op( B ) = B, and A and B are n by k if trans == rocblas_operation_none
        op( A ) = A^T, op( B ) = B^T, and A and B are k by n if trans == rocblas_operation_transpose
        or for ssyr2k and dsyr2k when trans == rocblas_operation_conjugate_transpose

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.

    @param[in]
    uplo    [rocblas_fill]
            - rocblas_fill_upper:  C is an upper triangular matrix
            - rocblas_fill_lower:  C is a  lower triangular matrix

    @param[in]
    trans  [rocblas_operation]
            - rocblas_operation_transpose:           op( A ) = A^T, op( B ) = B^T
            - rocblas_operation_none:                op( A ) = A, op( B ) = B
            - rocblas_operation_conjugate_transpose: op( A ) = A^T, op( B ) = B^T

            rocblas_operation_conjugate_transpose is not supported for complex types in csyr2k and zsyr2k.

    @param[in]
    n       [rocblas_int]
            n specifies the number of rows and columns of C. n >= 0.

    @param[in]
    k       [rocblas_int]
            k specifies the number of columns of op(A) and op(B). k >= 0.

    @param[in]
    alpha
            alpha specifies the scalar alpha. When alpha is
            zero then A is not referenced and A need not be set before
            entry.

    @param[in]
    A       pointer storing matrix A on the GPU.
            Matrix dimension is ( lda, k ) when if trans = rocblas_operation_none, otherwise (lda, n)
            only the upper/lower triangular part is accessed.

    @param[in]
    lda     [rocblas_int]
            lda specifies the first dimension of A.

            if trans = rocblas_operation_none,  lda >= max( 1, n ),
            otherwise lda >= max( 1, k ).

    @param[in]
    B       pointer storing matrix B on the GPU.
            Matrix dimension is ( ldb, k ) when if trans = rocblas_operation_none, otherwise (ldb, n)
            only the upper/lower triangular part is accessed.

    @param[in]
    ldb     [rocblas_int]
            ldb specifies the first dimension of B.
            if trans = rocblas_operation_none,  ldb >= max( 1, n ),
            otherwise ldb >= max( 1, k ).
    @param[in]
    beta
            beta specifies the scalar beta. When beta is
            zero then C need not be set before entry.

    @param[in]
    C       pointer storing matrix C on the GPU.

    @param[in]
    ldc    [rocblas_int]
           ldc specifies the first dimension of C. ldc >= max( 1, n ).

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_ssyr2k",
        fn (
            Handle,
            Fill,
            Operation,
            Int32,
            Int32,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int32,
            UnsafePointer[Float32],
            Int32,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int32,
        ) -> Status,
    ]()(handle, uplo, trans, n, k, alpha, _a, lda, _b, ldb, beta, _c, ldc)


fn rocblas_dswap_batched(
    handle: Handle,
    n: Int32,
    x: OpaquePointer,
    incx: Int32,
    y: OpaquePointer,
    incy: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_dswap_batched",
        fn (
            Handle,
            Int32,
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(handle, n, x, incx, y, incy, batch_count)


fn rocblas_scopy_batched(
    handle: Handle,
    n: Int32,
    x: OpaquePointer,
    incx: Int32,
    y: OpaquePointer,
    incy: Int32,
    batch_count: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 1 API </b>.

    \\details
    copy_batched copies each element x_i[j] into y_i[j], for  j = 1 , ... , n; i = 1 , ... , batch_count:

        y_i := x_i,
        where (x_i, y_i) is the i-th instance of the batch.
        x_i and y_i are vectors.

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    n         [rocblas_int]
              the number of elements in each x_i to be copied to y_i.
    @param[in]
    x         device array of device pointers storing each vector x_i.
    @param[in]
    incx      [rocblas_int]
              specifies the increment for the elements of each vector x_i.
    @param[out]
    y         device array of device pointers storing each vector y_i.
    @param[in]
    incy      [rocblas_int]
              specifies the increment for the elements of each vector y_i.
    @param[in]
    batch_count [rocblas_int]
                number of instances in the batch.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_scopy_batched",
        fn (
            Handle,
            Int32,
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(handle, n, x, incx, y, incy, batch_count)


fn rocblas_izamin(
    handle: Handle,
    n: Int32,
    x: UnsafePointer[ComplexFloat64],
    incx: Int32,
    result: UnsafePointer[Int32],
) -> Status:
    return _get_dylib_function[
        "rocblas_izamin",
        fn (
            Handle,
            Int32,
            UnsafePointer[ComplexFloat64],
            Int32,
            UnsafePointer[Int32],
        ) -> Status,
    ]()(handle, n, x, incx, result)


fn rocblas_sspr_strided_batched_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    alpha: UnsafePointer[Float32],
    x: UnsafePointer[Float32],
    incx: Int64,
    stride_x: Int64,
    _ap: UnsafePointer[Float32],
    stride__a: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_sspr_strided_batched_64",
        fn (
            Handle,
            Fill,
            Int64,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int64,
            Int64,
            UnsafePointer[Float32],
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, uplo, n, alpha, x, incx, stride_x, _ap, stride__a, batch_count)


fn rocblas_dzasum_strided_batched(
    handle: Handle,
    n: Int32,
    x: UnsafePointer[ComplexFloat64],
    incx: Int32,
    stridex: Int64,
    batch_count: Int32,
    results: UnsafePointer[Float64],
) -> Status:
    return _get_dylib_function[
        "rocblas_dzasum_strided_batched",
        fn (
            Handle,
            Int32,
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            Int32,
            UnsafePointer[Float64],
        ) -> Status,
    ]()(handle, n, x, incx, stridex, batch_count, results)


fn rocblas_icamax(
    handle: Handle,
    n: Int32,
    x: UnsafePointer[ComplexFloat32],
    incx: Int32,
    result: UnsafePointer[Int32],
) -> Status:
    return _get_dylib_function[
        "rocblas_icamax",
        fn (
            Handle,
            Int32,
            UnsafePointer[ComplexFloat32],
            Int32,
            UnsafePointer[Int32],
        ) -> Status,
    ]()(handle, n, x, incx, result)


fn rocblas_dsyr2_batched_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    alpha: UnsafePointer[Float64],
    x: OpaquePointer,
    incx: Int64,
    y: OpaquePointer,
    incy: Int64,
    _a: OpaquePointer,
    lda: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_dsyr2_batched_64",
        fn (
            Handle,
            Fill,
            Int64,
            UnsafePointer[Float64],
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, uplo, n, alpha, x, incx, y, incy, _a, lda, batch_count)


fn rocblas_strsm_batched(
    handle: Handle,
    side: Side,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    m: Int32,
    n: Int32,
    alpha: UnsafePointer[Float32],
    _a: OpaquePointer,
    lda: Int32,
    _b: OpaquePointer,
    ldb: Int32,
    batch_count: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 3 API </b>.

    \\details
    trsm_batched performs the following batched operation:

        op(A_i)*X_i = alpha*B_i or
        X_i*op(A_i) = alpha*B_i, for i = 1, ..., batch_count,

        where alpha is a scalar, X and B are batched m by n matrices,

        A is triangular batched matrix and op(A) is one of

        op( A ) = A   or
        op( A ) = A^T   or
        op( A ) = A^H.

        Each matrix X_i is overwritten on B_i for i = 1, ..., batch_count.

    Note about memory allocation:
    When trsm is launched with a k evenly divisible by the internal block size of 128,
    and is no larger than 10 of these blocks, the API takes advantage of utilizing pre-allocated
    memory found in the handle to increase overall performance. This memory can be managed by using
    the environment variable WORKBUF_TRSM_B_CHNK. When this variable is not set the device memory
    used for temporary storage will default to 1 MB and may result in chunking, which in turn may
    reduce performance. Under these circumstances it is recommended that WORKBUF_TRSM_B_CHNK be set
    to the desired chunk of right hand sides to be used at a time
    (where k is m when rocblas_side_left and is n when rocblas_side_right).

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    side    [rocblas_side]
            - rocblas_side_left:       op(A)*X = alpha*B
            - rocblas_side_right:      X*op(A) = alpha*B
    @param[in]
    uplo    [rocblas_fill]
            - rocblas_fill_upper:  each A_i is an upper triangular matrix.
            - rocblas_fill_lower:  each A_i is a  lower triangular matrix.
    @param[in]
    transA  [rocblas_operation]
            - transB:    op(A) = A
            - rocblas_operation_transpose:      op(A) = A^T
            - rocblas_operation_conjugate_transpose:  op(A) = A^H
    @param[in]
    diag    [rocblas_diagonal]
            - rocblas_diagonal_unit:     each A_i is assumed to be unit triangular.
            - rocblas_diagonal_non_unit:  each A_i is not assumed to be unit triangular.
    @param[in]
    m       [rocblas_int]
            m specifies the number of rows of each B_i. m >= 0.
    @param[in]
    n       [rocblas_int]
            n specifies the number of columns of each B_i. n >= 0.
    @param[in]
    alpha
            device pointer or host pointer specifying the scalar alpha. When alpha is
            &zero then A is not referenced and B need not be set before
            entry.
    @param[in]
    A       device array of device pointers storing each matrix A_i on the GPU.
            Matrices are of dimension ( lda, k ), where k is m
            when  rocblas_side_left  and is  n  when  rocblas_side_right
            only the upper/lower triangular part is accessed.
    @param[in]
    lda     [rocblas_int]
            lda specifies the first dimension of each A_i.

                if side = rocblas_side_left,  lda >= max( 1, m ),
                if side = rocblas_side_right, lda >= max( 1, n ).
    @param[in,out]
    B       device array of device pointers storing each matrix B_i on the GPU.
    @param[in]
    ldb    [rocblas_int]
           ldb specifies the first dimension of each B_i. ldb >= max( 1, m ).
    @param[in]
    batch_count [rocblas_int]
                number of trsm operations in the batch.
    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_strsm_batched",
        fn (
            Handle,
            Side,
            Fill,
            Operation,
            Diagonal,
            Int32,
            Int32,
            UnsafePointer[Float32],
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(
        handle,
        side,
        uplo,
        trans_a,
        diag,
        m,
        n,
        alpha,
        _a,
        lda,
        _b,
        ldb,
        batch_count,
    )


fn rocblas_zhpmv_strided_batched(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat64],
    _ap: UnsafePointer[ComplexFloat64],
    stride__a: Int64,
    x: UnsafePointer[ComplexFloat64],
    incx: Int32,
    stride_x: Int64,
    beta: UnsafePointer[ComplexFloat64],
    y: UnsafePointer[ComplexFloat64],
    incy: Int32,
    stride_y: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_zhpmv_strided_batched",
        fn (
            Handle,
            Fill,
            Int32,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int64,
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        uplo,
        n,
        alpha,
        _ap,
        stride__a,
        x,
        incx,
        stride_x,
        beta,
        y,
        incy,
        stride_y,
        batch_count,
    )


fn rocblas_dspr_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    alpha: UnsafePointer[Float64],
    x: UnsafePointer[Float64],
    incx: Int64,
    _ap: UnsafePointer[Float64],
) -> Status:
    return _get_dylib_function[
        "rocblas_dspr_64",
        fn (
            Handle,
            Fill,
            Int64,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int64,
            UnsafePointer[Float64],
        ) -> Status,
    ]()(handle, uplo, n, alpha, x, incx, _ap)


fn rocblas_ssyr2k_strided_batched(
    handle: Handle,
    uplo: Fill,
    trans: Operation,
    n: Int32,
    k: Int32,
    alpha: UnsafePointer[Float32],
    _a: UnsafePointer[Float32],
    lda: Int32,
    stride__a: Int64,
    _b: UnsafePointer[Float32],
    ldb: Int32,
    stride__b: Int64,
    beta: UnsafePointer[Float32],
    _c: UnsafePointer[Float32],
    ldc: Int32,
    stride__c: Int64,
    batch_count: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 3 API </b>.

    \\details
    syr2k_strided_batched performs a batch of the matrix-matrix operations for a symmetric rank-2k update:

        C_i := alpha*(op( A_i )*op( B_i )^T + op( B_i )*op( A_i )^T) + beta*C_i,

        where  alpha and beta are scalars, op(A_i) and op(B_i) are n by k matrix, and
        C_i is a symmetric n x n matrix stored as either upper or lower.

        op( A_i ) = A_i, op( B_i ) = B_i, and A_i and B_i are n by k if trans == rocblas_operation_none
        op( A_i ) = A_i^T, op( B_i ) = B_i^T, and A_i and B_i are k by n if trans == rocblas_operation_transpose
        or for ssyr2k_strided_batched and dsyr2k_strided_batched when trans == rocblas_operation_conjugate_transpose

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.

    @param[in]
    uplo    [rocblas_fill]
            - rocblas_fill_upper:  C_i is an upper triangular matrix
            - rocblas_fill_lower:  C_i is a  lower triangular matrix

    @param[in]
    trans  [rocblas_operation]
            - rocblas_operation_transpose:           op( A_i ) = A_i^T, op( B_i ) = B_i^T
            - rocblas_operation_none:                op( A_i ) = A_i, op( B_i ) = B_i
            - rocblas_operation_conjugate_transpose: op( A_i ) = A_i^T, op( B_i ) = B_i^T

            rocblas_operation_conjugate_transpose is not supported for complex types in csyr2k_strided_batched and zsyr2k_strided_batched.

    @param[in]
    n       [rocblas_int]
            n specifies the number of rows and columns of C_i. n >= 0.

    @param[in]
    k       [rocblas_int]
            k specifies the number of columns of op(A). k >= 0.

    @param[in]
    alpha
            alpha specifies the scalar alpha. When alpha is
            zero then A is not referenced and A need not be set before
            entry.

    @param[in]
    A       Device pointer to the first matrix A_1 on the GPU of dimension (lda, k)
            when trans is rocblas_operation_none, otherwise of dimension (lda, n).

    @param[in]
    lda     [rocblas_int]
            lda specifies the first dimension of A_i.

                if trans = rocblas_operation_none,  lda >= max( 1, n ),
                otherwise lda >= max( 1, k ).

    @param[in]
    stride_A  [rocblas_stride]
              stride from the start of one matrix (A_i) and the next one (A_i+1)

    @param[in]
    B       Device pointer to the first matrix B_1 on the GPU of dimension (ldb, k)
            when trans is rocblas_operation_none, otherwise of dimension (ldb, n)

    @param[in]
    ldb     [rocblas_int]
            ldb specifies the first dimension of B_i.

                if trans = rocblas_operation_none,  ldb >= max( 1, n ),
                otherwise ldb >= max( 1, k ).

    @param[in]
    stride_B  [rocblas_stride]
              stride from the start of one matrix (B_i) and the next one (B_i+1)

    @param[in]
    beta
            beta specifies the scalar beta. When beta is
            zero then C need not be set before entry.

    @param[in]
    C       Device pointer to the first matrix C_1 on the GPU.

    @param[in]
    ldc    [rocblas_int]
           ldc specifies the first dimension of C. ldc >= max( 1, n ).

    @param[in, out]
    stride_C  [rocblas_stride]
              stride from the start of one matrix (C_i) and the next one (C_i+1).

    @param[in]
    batch_count [rocblas_int]
                number of instances in the batch.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_ssyr2k_strided_batched",
        fn (
            Handle,
            Fill,
            Operation,
            Int32,
            Int32,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int32,
            Int64,
            UnsafePointer[Float32],
            Int32,
            Int64,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        uplo,
        trans,
        n,
        k,
        alpha,
        _a,
        lda,
        stride__a,
        _b,
        ldb,
        stride__b,
        beta,
        _c,
        ldc,
        stride__c,
        batch_count,
    )


fn rocblas_stpsv_64(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int64,
    _ap: UnsafePointer[Float32],
    x: UnsafePointer[Float32],
    incx: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_stpsv_64",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int64,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int64,
        ) -> Status,
    ]()(handle, uplo, trans_a, diag, n, _ap, x, incx)


fn rocblas_scasum_batched(
    handle: Handle,
    n: Int32,
    x: OpaquePointer,
    incx: Int32,
    batch_count: Int32,
    results: UnsafePointer[Float32],
) -> Status:
    return _get_dylib_function[
        "rocblas_scasum_batched",
        fn (
            Handle,
            Int32,
            OpaquePointer,
            Int32,
            Int32,
            UnsafePointer[Float32],
        ) -> Status,
    ]()(handle, n, x, incx, batch_count, results)


fn rocblas_ztpsv_strided_batched_64(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int64,
    _ap: UnsafePointer[ComplexFloat64],
    stride__a: Int64,
    x: UnsafePointer[ComplexFloat64],
    incx: Int64,
    stride_x: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_ztpsv_strided_batched_64",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int64,
            UnsafePointer[ComplexFloat64],
            Int64,
            Int64,
            Int64,
        ) -> Status,
    ]()(
        handle,
        uplo,
        trans_a,
        diag,
        n,
        _ap,
        stride__a,
        x,
        incx,
        stride_x,
        batch_count,
    )


fn rocblas_zswap(
    handle: Handle,
    n: Int32,
    x: UnsafePointer[ComplexFloat64],
    incx: Int32,
    y: UnsafePointer[ComplexFloat64],
    incy: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_zswap",
        fn (
            Handle,
            Int32,
            UnsafePointer[ComplexFloat64],
            Int32,
            UnsafePointer[ComplexFloat64],
            Int32,
        ) -> Status,
    ]()(handle, n, x, incx, y, incy)


fn rocblas_scnrm2_64(
    handle: Handle,
    n: Int64,
    x: UnsafePointer[ComplexFloat32],
    incx: Int64,
    result: UnsafePointer[Float32],
) -> Status:
    return _get_dylib_function[
        "rocblas_scnrm2_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int64,
            UnsafePointer[Float32],
        ) -> Status,
    ]()(handle, n, x, incx, result)


fn rocblas_strsv_strided_batched_64(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int64,
    _a: UnsafePointer[Float32],
    lda: Int64,
    stride__a: Int64,
    x: UnsafePointer[Float32],
    incx: Int64,
    stride_x: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_strsv_strided_batched_64",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int64,
            UnsafePointer[Float32],
            Int64,
            Int64,
            UnsafePointer[Float32],
            Int64,
            Int64,
            Int64,
        ) -> Status,
    ]()(
        handle,
        uplo,
        trans_a,
        diag,
        n,
        _a,
        lda,
        stride__a,
        x,
        incx,
        stride_x,
        batch_count,
    )


fn rocblas_dcopy(
    handle: Handle,
    n: Int32,
    x: UnsafePointer[Float64],
    incx: Int32,
    y: UnsafePointer[Float64],
    incy: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_dcopy",
        fn (
            Handle,
            Int32,
            UnsafePointer[Float64],
            Int32,
            UnsafePointer[Float64],
            Int32,
        ) -> Status,
    ]()(handle, n, x, incx, y, incy)


fn rocblas_zdotu_batched_64(
    handle: Handle,
    n: Int64,
    x: OpaquePointer,
    incx: Int64,
    y: OpaquePointer,
    incy: Int64,
    batch_count: Int64,
    result: UnsafePointer[ComplexFloat64],
) -> Status:
    return _get_dylib_function[
        "rocblas_zdotu_batched_64",
        fn (
            Handle,
            Int64,
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            Int64,
            UnsafePointer[ComplexFloat64],
        ) -> Status,
    ]()(handle, n, x, incx, y, incy, batch_count, result)


fn rocblas_bfdot_batched(
    handle: Handle,
    n: Int32,
    x: OpaquePointer,
    incx: Int32,
    y: OpaquePointer,
    incy: Int32,
    batch_count: Int32,
    result: UnsafePointer[BFloat16],
) -> Status:
    return _get_dylib_function[
        "rocblas_bfdot_batched",
        fn (
            Handle,
            Int32,
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            Int32,
            UnsafePointer[BFloat16],
        ) -> Status,
    ]()(handle, n, x, incx, y, incy, batch_count, result)


fn rocblas_stbmv_64(
    handle: Handle,
    uplo: Fill,
    trans: Operation,
    diag: Diagonal,
    n: Int64,
    k: Int64,
    _a: UnsafePointer[Float32],
    lda: Int64,
    x: UnsafePointer[Float32],
    incx: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_stbmv_64",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int64,
            Int64,
            UnsafePointer[Float32],
            Int64,
            UnsafePointer[Float32],
            Int64,
        ) -> Status,
    ]()(handle, uplo, trans, diag, n, k, _a, lda, x, incx)


fn rocblas_saxpy_batched(
    handle: Handle,
    n: Int32,
    alpha: UnsafePointer[Float32],
    x: OpaquePointer,
    incx: Int32,
    y: OpaquePointer,
    incy: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_saxpy_batched",
        fn (
            Handle,
            Int32,
            UnsafePointer[Float32],
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(handle, n, alpha, x, incx, y, incy, batch_count)


fn rocblas_zher_batched_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    alpha: UnsafePointer[Float64],
    x: OpaquePointer,
    incx: Int64,
    _a: OpaquePointer,
    lda: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_zher_batched_64",
        fn (
            Handle,
            Fill,
            Int64,
            UnsafePointer[Float64],
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, uplo, n, alpha, x, incx, _a, lda, batch_count)


fn rocblas_icamin_batched(
    handle: Handle,
    n: Int32,
    x: OpaquePointer,
    incx: Int32,
    batch_count: Int32,
    result: UnsafePointer[Int32],
) -> Status:
    return _get_dylib_function[
        "rocblas_icamin_batched",
        fn (
            Handle,
            Int32,
            OpaquePointer,
            Int32,
            Int32,
            UnsafePointer[Int32],
        ) -> Status,
    ]()(handle, n, x, incx, batch_count, result)


fn rocblas_ztrmv(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int32,
    _a: UnsafePointer[ComplexFloat64],
    lda: Int32,
    x: UnsafePointer[ComplexFloat64],
    incx: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_ztrmv",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int32,
            UnsafePointer[ComplexFloat64],
            Int32,
            UnsafePointer[ComplexFloat64],
            Int32,
        ) -> Status,
    ]()(handle, uplo, trans_a, diag, n, _a, lda, x, incx)


fn rocblas_cher2k(
    handle: Handle,
    uplo: Fill,
    trans: Operation,
    n: Int32,
    k: Int32,
    alpha: UnsafePointer[ComplexFloat32],
    _a: UnsafePointer[ComplexFloat32],
    lda: Int32,
    _b: UnsafePointer[ComplexFloat32],
    ldb: Int32,
    beta: UnsafePointer[Float32],
    _c: UnsafePointer[ComplexFloat32],
    ldc: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 3 API </b>.

    \\details
    her2k performs one of the matrix-matrix operations for a Hermitian rank-2k update:

        C := alpha*op( A )*op( B )^H + conj(alpha)*op( B )*op( A )^H + beta*C,

        where  alpha and beta are scalars, op(A) and op(B) are n by k matrices, and
        C is a n x n Hermitian matrix stored as either upper or lower.

        op( A ) = A, op( B ) = B, and A and B are n by k if trans == rocblas_operation_none
        op( A ) = A^H, op( B ) = B^H,  and A and B are k by n if trans == rocblas_operation_conjugate_transpose

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.

    @param[in]
    uplo    [rocblas_fill]
            - rocblas_fill_upper:  C is an upper triangular matrix
            - rocblas_fill_lower:  C is a  lower triangular matrix

    @param[in]
    trans  [rocblas_operation]
            - rocblas_operation_conjugate_transpose:  op( A ) = A^H, op( B ) = B^H
            - rocblas_operation_none:                 op( A ) = A, op( B ) = B

    @param[in]
    n       [rocblas_int]
            n specifies the number of rows and columns of C. n >= 0.

    @param[in]
    k       [rocblas_int]
            k specifies the number of columns of op(A). k >= 0.

    @param[in]
    alpha
            alpha specifies the scalar alpha. When alpha is
            zero then A is not referenced and A need not be set before
            entry.

    @param[in]
    A       pointer storing matrix A on the GPU.
            Matrix dimension is ( lda, k ) when if trans = rocblas_operation_none, otherwise (lda, n)

    @param[in]
    lda     [rocblas_int]
            lda specifies the first dimension of A.

                if trans = rocblas_operation_none,  lda >= max( 1, n ),
                otherwise lda >= max( 1, k ).

    @param[in]
    B       pointer storing matrix B on the GPU.
            Matrix dimension is ( ldb, k ) when if trans = rocblas_operation_none, otherwise (ldb, n)

    @param[in]
    ldb     [rocblas_int]
            ldb specifies the first dimension of B.

                if trans = rocblas_operation_none,  ldb >= max( 1, n ),
                otherwise ldb >= max( 1, k ).

    @param[in]
    beta
            beta specifies the scalar beta. When beta is
            zero then C need not be set before entry.

    @param[in]
    C       pointer storing matrix C on the GPU.
            The imaginary component of the diagonal elements are not used but are set to zero unless quick return.
            only the upper/lower triangular part is accessed.

    @param[in]
    ldc    [rocblas_int]
           ldc specifies the first dimension of C. ldc >= max( 1, n ).

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_cher2k",
        fn (
            Handle,
            Fill,
            Operation,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int32,
            UnsafePointer[ComplexFloat32],
            Int32,
            UnsafePointer[Float32],
            UnsafePointer[ComplexFloat32],
            Int32,
        ) -> Status,
    ]()(handle, uplo, trans, n, k, alpha, _a, lda, _b, ldb, beta, _c, ldc)


fn rocblas_zspr_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    alpha: UnsafePointer[ComplexFloat64],
    x: UnsafePointer[ComplexFloat64],
    incx: Int64,
    _ap: UnsafePointer[ComplexFloat64],
) -> Status:
    return _get_dylib_function[
        "rocblas_zspr_64",
        fn (
            Handle,
            Fill,
            Int64,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int64,
            UnsafePointer[ComplexFloat64],
        ) -> Status,
    ]()(handle, uplo, n, alpha, x, incx, _ap)


fn rocblas_cgeru_64(
    handle: Handle,
    m: Int64,
    n: Int64,
    alpha: UnsafePointer[ComplexFloat32],
    x: UnsafePointer[ComplexFloat32],
    incx: Int64,
    y: UnsafePointer[ComplexFloat32],
    incy: Int64,
    _a: UnsafePointer[ComplexFloat32],
    lda: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_cgeru_64",
        fn (
            Handle,
            Int64,
            Int64,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int64,
            UnsafePointer[ComplexFloat32],
            Int64,
            UnsafePointer[ComplexFloat32],
            Int64,
        ) -> Status,
    ]()(handle, m, n, alpha, x, incx, y, incy, _a, lda)


fn rocblas_zhpr2_batched_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    alpha: UnsafePointer[ComplexFloat64],
    x: OpaquePointer,
    incx: Int64,
    y: OpaquePointer,
    incy: Int64,
    _ap: OpaquePointer,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_zhpr2_batched_64",
        fn (
            Handle,
            Fill,
            Int64,
            UnsafePointer[ComplexFloat64],
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
        ) -> Status,
    ]()(handle, uplo, n, alpha, x, incx, y, incy, _ap, batch_count)


fn rocblas_caxpy_batched_64(
    handle: Handle,
    n: Int64,
    alpha: UnsafePointer[ComplexFloat32],
    x: OpaquePointer,
    incx: Int64,
    y: OpaquePointer,
    incy: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_caxpy_batched_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[ComplexFloat32],
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, n, alpha, x, incx, y, incy, batch_count)


fn rocblas_zsyrkx(
    handle: Handle,
    uplo: Fill,
    trans: Operation,
    n: Int32,
    k: Int32,
    alpha: UnsafePointer[ComplexFloat64],
    _a: UnsafePointer[ComplexFloat64],
    lda: Int32,
    _b: UnsafePointer[ComplexFloat64],
    ldb: Int32,
    beta: UnsafePointer[ComplexFloat64],
    _c: UnsafePointer[ComplexFloat64],
    ldc: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_zsyrkx",
        fn (
            Handle,
            Fill,
            Operation,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int32,
            UnsafePointer[ComplexFloat64],
            Int32,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int32,
        ) -> Status,
    ]()(handle, uplo, trans, n, k, alpha, _a, lda, _b, ldb, beta, _c, ldc)


fn rocblas_ddgmm(
    handle: Handle,
    side: Side,
    m: Int32,
    n: Int32,
    _a: UnsafePointer[Float64],
    lda: Int32,
    x: UnsafePointer[Float64],
    incx: Int32,
    _c: UnsafePointer[Float64],
    ldc: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_ddgmm",
        fn (
            Handle,
            Side,
            Int32,
            Int32,
            UnsafePointer[Float64],
            Int32,
            UnsafePointer[Float64],
            Int32,
            UnsafePointer[Float64],
            Int32,
        ) -> Status,
    ]()(handle, side, m, n, _a, lda, x, incx, _c, ldc)


fn rocblas_cgemmt_batched(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    trans_b: Operation,
    n: Int32,
    k: Int32,
    alpha: UnsafePointer[ComplexFloat32],
    _a: OpaquePointer,
    lda: Int32,
    _b: OpaquePointer,
    ldb: Int32,
    beta: UnsafePointer[ComplexFloat32],
    _c: OpaquePointer,
    ldc: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_cgemmt_batched",
        fn (
            Handle,
            Fill,
            Operation,
            Operation,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat32],
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            UnsafePointer[ComplexFloat32],
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(
        handle,
        uplo,
        trans_a,
        trans_b,
        n,
        k,
        alpha,
        _a,
        lda,
        _b,
        ldb,
        beta,
        _c,
        ldc,
        batch_count,
    )


fn rocblas_sspmv(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    alpha: UnsafePointer[Float32],
    _a: UnsafePointer[Float32],
    x: UnsafePointer[Float32],
    incx: Int32,
    beta: UnsafePointer[Float32],
    y: UnsafePointer[Float32],
    incy: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 2 API </b>.

    \\details
    spmv performs the matrix-vector operation:

        y := alpha*A*x + beta*y
        where alpha and beta are scalars, x and y are n element vectors and
        A should contain an upper or lower triangular n by n packed symmetric matrix.

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    uplo      rocblas_fill
            specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
            - if rocblas_fill_upper, the lower part of A is not referenced
            - if rocblas_fill_lower, the upper part of A is not referenced
    @param[in]
    n         [rocblas_int]
    @param[in]
    alpha
              specifies the scalar alpha.
    @param[in]
    A         pointer storing matrix A on the GPU.
    @param[in]
    x         pointer storing vector x on the GPU.
    @param[in]
    incx      [rocblas_int]
              specifies the increment for the elements of x.
    @param[in]
    beta      specifies the scalar beta.
    @param[out]
    y         pointer storing vector y on the GPU.
    @param[in]
    incy      [rocblas_int]
              specifies the increment for the elements of y.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_sspmv",
        fn (
            Handle,
            Fill,
            Int32,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int32,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int32,
        ) -> Status,
    ]()(handle, uplo, n, alpha, _a, x, incx, beta, y, incy)


fn rocblas_ctbmv_strided_batched(
    handle: Handle,
    uplo: Fill,
    trans: Operation,
    diag: Diagonal,
    n: Int32,
    k: Int32,
    _a: UnsafePointer[ComplexFloat32],
    lda: Int32,
    stride__a: Int64,
    x: UnsafePointer[ComplexFloat32],
    incx: Int32,
    stride_x: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_ctbmv_strided_batched",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        uplo,
        trans,
        diag,
        n,
        k,
        _a,
        lda,
        stride__a,
        x,
        incx,
        stride_x,
        batch_count,
    )


fn rocblas_chemm_strided_batched(
    handle: Handle,
    side: Side,
    uplo: Fill,
    m: Int32,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat32],
    _a: UnsafePointer[ComplexFloat32],
    lda: Int32,
    stride__a: Int64,
    _b: UnsafePointer[ComplexFloat32],
    ldb: Int32,
    stride__b: Int64,
    beta: UnsafePointer[ComplexFloat32],
    _c: UnsafePointer[ComplexFloat32],
    ldc: Int32,
    stride__c: Int64,
    batch_count: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 3 API </b>.

    \\details
    hemm_strided_batched performs a batch of the matrix-matrix operations:

        C_i := alpha*A_i*B_i + beta*C_i if side == rocblas_side_left,
        C_i := alpha*B_i*A_i + beta*C_i if side == rocblas_side_right,

        where alpha and beta are scalars, B_i and C_i are m by n matrices, and
        A_i is a Hermitian matrix stored as either upper or lower.

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.

    @param[in]
    side  [rocblas_side]
            - rocblas_side_left:      C_i := alpha*A_i*B_i + beta*C_i
            - rocblas_side_right:     C_i := alpha*B_i*A_i + beta*C_i

    @param[in]
    uplo    [rocblas_fill]
            - rocblas_fill_upper:  A_i is an upper triangular matrix
            - rocblas_fill_lower:  A_i is a  lower triangular matrix

    @param[in]
    m       [rocblas_int]
            m specifies the number of rows of B_i and C_i. m >= 0.

    @param[in]
    n       [rocblas_int]
            n specifies the number of columns of B_i and C_i. n >= 0.

    @param[in]
    alpha
            alpha specifies the scalar alpha. When alpha is
            zero then A_i and B_i are not referenced.

    @param[in]
    A       device pointer to first matrix A_1
            - A_i is m by m if side == rocblas_side_left
            - A_i is n by n if side == rocblas_side_right
            Only the upper/lower triangular part is accessed.
            The imaginary component of the diagonal elements is not used.

    @param[in]
    lda     [rocblas_int]
            lda specifies the first dimension of A_i.

                if side = rocblas_side_left,  lda >= max( 1, m ),
                otherwise lda >= max( 1, n ).

    @param[in]
    stride_A  [rocblas_stride]
              stride from the start of one matrix (A_i) and the next one (A_i+1).

    @param[in]
    B       device pointer to first matrix B_1 of dimension (ldb, n) on the GPU

    @param[in]
    ldb     [rocblas_int]
            ldb specifies the first dimension of B_i.

                if side = rocblas_operation_none,  ldb >= max( 1, m ),
                otherwise ldb >= max( 1, n ).

    @param[in]
    stride_B  [rocblas_stride]
              stride from the start of one matrix (B_i) and the next one (B_i+1).

    @param[in]
    beta
            beta specifies the scalar beta. When beta is
            zero then C need not be set before entry.

    @param[in]
    C        device pointer to first matrix C_1 of dimension (ldc, n) on the GPU.

    @param[in]
    ldc    [rocblas_int]
           ldc specifies the first dimension of C. ldc >= max( 1, m ).

    @param[in, out]
    stride_C  [rocblas_stride]
              stride from the start of one matrix (C_i) and the next one (C_i+1).

    @param[in]
    batch_count [rocblas_int]
                number of instances in the batch.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_chemm_strided_batched",
        fn (
            Handle,
            Side,
            Fill,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        side,
        uplo,
        m,
        n,
        alpha,
        _a,
        lda,
        stride__a,
        _b,
        ldb,
        stride__b,
        beta,
        _c,
        ldc,
        stride__c,
        batch_count,
    )


fn rocblas_dtbsv_64(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int64,
    k: Int64,
    _a: UnsafePointer[Float64],
    lda: Int64,
    x: UnsafePointer[Float64],
    incx: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_dtbsv_64",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int64,
            Int64,
            UnsafePointer[Float64],
            Int64,
            UnsafePointer[Float64],
            Int64,
        ) -> Status,
    ]()(handle, uplo, trans_a, diag, n, k, _a, lda, x, incx)


fn rocblas_ztbmv_64(
    handle: Handle,
    uplo: Fill,
    trans: Operation,
    diag: Diagonal,
    n: Int64,
    k: Int64,
    _a: UnsafePointer[ComplexFloat64],
    lda: Int64,
    x: UnsafePointer[ComplexFloat64],
    incx: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_ztbmv_64",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int64,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int64,
            UnsafePointer[ComplexFloat64],
            Int64,
        ) -> Status,
    ]()(handle, uplo, trans, diag, n, k, _a, lda, x, incx)


fn rocblas_chemv_strided_batched(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat32],
    _a: UnsafePointer[ComplexFloat32],
    lda: Int32,
    stride__a: Int64,
    x: UnsafePointer[ComplexFloat32],
    incx: Int32,
    stride_x: Int64,
    beta: UnsafePointer[ComplexFloat32],
    y: UnsafePointer[ComplexFloat32],
    incy: Int32,
    stride_y: Int64,
    batch_count: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 2 API </b>.

    \\details
    hemv_strided_batched performs one of the matrix-vector operations:

        y_i := alpha*A_i*x_i + beta*y_i
        where alpha and beta are scalars, x_i and y_i are n element vectors and A_i is an
        n by n Hermitian matrix, for each batch in i = [1, batch_count].

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    uplo      [rocblas_fill]
            - rocblas_fill_upper: the upper triangular part of the Hermitian matrix A is supplied.
            - rocblas_fill_lower: the lower triangular part of the Hermitian matrix A is supplied.
    @param[in]
    n         [rocblas_int]
              the order of each matrix A_i.
    @param[in]
    alpha     device pointer or host pointer to scalar alpha.
    @param[in]
    A         device array of device pointers storing each matrix A_i of dimension (lda, n).

        if uplo == rocblas_fill_upper:
            The upper triangular part of each A_i must contain
            the upper triangular part of a Hermitian matrix. The lower
            triangular part of each A_i will not be referenced.

        if uplo == rocblas_fill_lower:
            The lower triangular part of each A_i must contain
            the lower triangular part of a Hermitian matrix. The upper
            triangular part of each A_i will not be referenced.
            As a Hermitian matrix, the imaginary part of the main diagonal
            of each A_i will not be referenced and is assumed to be == 0.
    @param[in]
    lda       [rocblas_int]
              specifies the leading dimension of each A_i. must be >= max(1, n).
    @param[in]
    stride_A    [rocblas_stride]
                stride from the start of one (A_i) to the next (A_i+1).
    @param[in]
    x         device array of device pointers storing each vector x_i.
    @param[in]
    incx      [rocblas_int]
              specifies the increment for the elements of each x_i.
    @param[in]
    stride_x  [rocblas_stride]
              stride from the start of one vector (x_i) and the next one (x_i+1).
    @param[in]
    beta      device pointer or host pointer to scalar beta.
    @param[in, out]
    y         device array of device pointers storing each vector y_i.
    @param[in]
    incy      [rocblas_int]
              specifies the increment for the elements of y.
    @param[in]
    stride_y  [rocblas_stride]
              stride from the start of one vector (y_i) and the next one (y_i+1).
    @param[in]
    batch_count [rocblas_int]
                number of instances in the batch.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_chemv_strided_batched",
        fn (
            Handle,
            Fill,
            Int32,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        uplo,
        n,
        alpha,
        _a,
        lda,
        stride__a,
        x,
        incx,
        stride_x,
        beta,
        y,
        incy,
        stride_y,
        batch_count,
    )


fn rocblas_zgemv_batched_64(
    handle: Handle,
    trans: Operation,
    m: Int64,
    n: Int64,
    alpha: UnsafePointer[ComplexFloat64],
    _a: OpaquePointer,
    lda: Int64,
    x: OpaquePointer,
    incx: Int64,
    beta: UnsafePointer[ComplexFloat64],
    y: OpaquePointer,
    incy: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_zgemv_batched_64",
        fn (
            Handle,
            Operation,
            Int64,
            Int64,
            UnsafePointer[ComplexFloat64],
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            UnsafePointer[ComplexFloat64],
            OpaquePointer,
            Int64,
            Int64,
        ) -> Status,
    ]()(
        handle, trans, m, n, alpha, _a, lda, x, incx, beta, y, incy, batch_count
    )


fn rocblas_zgemmt(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    trans_b: Operation,
    n: Int32,
    k: Int32,
    alpha: UnsafePointer[ComplexFloat64],
    _a: UnsafePointer[ComplexFloat64],
    lda: Int32,
    _b: UnsafePointer[ComplexFloat64],
    ldb: Int32,
    beta: UnsafePointer[ComplexFloat64],
    _c: UnsafePointer[ComplexFloat64],
    ldc: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_zgemmt",
        fn (
            Handle,
            Fill,
            Operation,
            Operation,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int32,
            UnsafePointer[ComplexFloat64],
            Int32,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int32,
        ) -> Status,
    ]()(
        handle,
        uplo,
        trans_a,
        trans_b,
        n,
        k,
        alpha,
        _a,
        lda,
        _b,
        ldb,
        beta,
        _c,
        ldc,
    )


fn rocblas_idamin(
    handle: Handle,
    n: Int32,
    x: UnsafePointer[Float64],
    incx: Int32,
    result: UnsafePointer[Int32],
) -> Status:
    return _get_dylib_function[
        "rocblas_idamin",
        fn (
            Handle, Int32, UnsafePointer[Float64], Int32, UnsafePointer[Int32]
        ) -> Status,
    ]()(handle, n, x, incx, result)


fn rocblas_drotm_64(
    handle: Handle,
    n: Int64,
    x: UnsafePointer[Float64],
    incx: Int64,
    y: UnsafePointer[Float64],
    incy: Int64,
    param: UnsafePointer[Float64],
) -> Status:
    return _get_dylib_function[
        "rocblas_drotm_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[Float64],
            Int64,
            UnsafePointer[Float64],
            Int64,
            UnsafePointer[Float64],
        ) -> Status,
    ]()(handle, n, x, incx, y, incy, param)


fn rocblas_cscal_strided_batched_64(
    handle: Handle,
    n: Int64,
    alpha: UnsafePointer[ComplexFloat32],
    x: UnsafePointer[ComplexFloat32],
    incx: Int64,
    stride_x: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_cscal_strided_batched_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int64,
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, n, alpha, x, incx, stride_x, batch_count)


fn rocblas_zsyrk(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    n: Int32,
    k: Int32,
    alpha: UnsafePointer[ComplexFloat64],
    _a: UnsafePointer[ComplexFloat64],
    lda: Int32,
    beta: UnsafePointer[ComplexFloat64],
    _c: UnsafePointer[ComplexFloat64],
    ldc: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_zsyrk",
        fn (
            Handle,
            Fill,
            Operation,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int32,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int32,
        ) -> Status,
    ]()(handle, uplo, trans_a, n, k, alpha, _a, lda, beta, _c, ldc)


fn rocblas_dspr2_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    alpha: UnsafePointer[Float64],
    x: UnsafePointer[Float64],
    incx: Int64,
    y: UnsafePointer[Float64],
    incy: Int64,
    _ap: UnsafePointer[Float64],
) -> Status:
    return _get_dylib_function[
        "rocblas_dspr2_64",
        fn (
            Handle,
            Fill,
            Int64,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int64,
            UnsafePointer[Float64],
            Int64,
            UnsafePointer[Float64],
        ) -> Status,
    ]()(handle, uplo, n, alpha, x, incx, y, incy, _ap)


fn rocblas_icamin_strided_batched(
    handle: Handle,
    n: Int32,
    x: UnsafePointer[ComplexFloat32],
    incx: Int32,
    stridex: Int64,
    batch_count: Int32,
    result: UnsafePointer[Int32],
) -> Status:
    return _get_dylib_function[
        "rocblas_icamin_strided_batched",
        fn (
            Handle,
            Int32,
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            Int32,
            UnsafePointer[Int32],
        ) -> Status,
    ]()(handle, n, x, incx, stridex, batch_count, result)


fn rocblas_dsyr2_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    alpha: UnsafePointer[Float64],
    x: UnsafePointer[Float64],
    incx: Int64,
    y: UnsafePointer[Float64],
    incy: Int64,
    _a: UnsafePointer[Float64],
    lda: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_dsyr2_64",
        fn (
            Handle,
            Fill,
            Int64,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int64,
            UnsafePointer[Float64],
            Int64,
            UnsafePointer[Float64],
            Int64,
        ) -> Status,
    ]()(handle, uplo, n, alpha, x, incx, y, incy, _a, lda)


fn rocblas_cgerc(
    handle: Handle,
    m: Int32,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat32],
    x: UnsafePointer[ComplexFloat32],
    incx: Int32,
    y: UnsafePointer[ComplexFloat32],
    incy: Int32,
    _a: UnsafePointer[ComplexFloat32],
    lda: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_cgerc",
        fn (
            Handle,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int32,
            UnsafePointer[ComplexFloat32],
            Int32,
            UnsafePointer[ComplexFloat32],
            Int32,
        ) -> Status,
    ]()(handle, m, n, alpha, x, incx, y, incy, _a, lda)


fn rocblas_zsyrkx_strided_batched(
    handle: Handle,
    uplo: Fill,
    trans: Operation,
    n: Int32,
    k: Int32,
    alpha: UnsafePointer[ComplexFloat64],
    _a: UnsafePointer[ComplexFloat64],
    lda: Int32,
    stride__a: Int64,
    _b: UnsafePointer[ComplexFloat64],
    ldb: Int32,
    stride__b: Int64,
    beta: UnsafePointer[ComplexFloat64],
    _c: UnsafePointer[ComplexFloat64],
    ldc: Int32,
    stride__c: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_zsyrkx_strided_batched",
        fn (
            Handle,
            Fill,
            Operation,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        uplo,
        trans,
        n,
        k,
        alpha,
        _a,
        lda,
        stride__a,
        _b,
        ldb,
        stride__b,
        beta,
        _c,
        ldc,
        stride__c,
        batch_count,
    )


fn rocblas_cgemmt_strided_batched(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    trans_b: Operation,
    n: Int32,
    k: Int32,
    alpha: UnsafePointer[ComplexFloat32],
    _a: UnsafePointer[ComplexFloat32],
    lda: Int32,
    stride_a: Int64,
    _b: UnsafePointer[ComplexFloat32],
    ldb: Int32,
    stride_b: Int64,
    beta: UnsafePointer[ComplexFloat32],
    _c: UnsafePointer[ComplexFloat32],
    ldc: Int32,
    stride_c: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_cgemmt_strided_batched",
        fn (
            Handle,
            Fill,
            Operation,
            Operation,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        uplo,
        trans_a,
        trans_b,
        n,
        k,
        alpha,
        _a,
        lda,
        stride_a,
        _b,
        ldb,
        stride_b,
        beta,
        _c,
        ldc,
        stride_c,
        batch_count,
    )


fn rocblas_dtrmv_strided_batched_64(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int64,
    _a: UnsafePointer[Float64],
    lda: Int64,
    stride__a: Int64,
    x: UnsafePointer[Float64],
    incx: Int64,
    stride_x: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_dtrmv_strided_batched_64",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int64,
            UnsafePointer[Float64],
            Int64,
            Int64,
            UnsafePointer[Float64],
            Int64,
            Int64,
            Int64,
        ) -> Status,
    ]()(
        handle,
        uplo,
        trans_a,
        diag,
        n,
        _a,
        lda,
        stride__a,
        x,
        incx,
        stride_x,
        batch_count,
    )


fn rocblas_cgbmv_batched(
    handle: Handle,
    trans: Operation,
    m: Int32,
    n: Int32,
    kl: Int32,
    ku: Int32,
    alpha: UnsafePointer[ComplexFloat32],
    _a: OpaquePointer,
    lda: Int32,
    x: OpaquePointer,
    incx: Int32,
    beta: UnsafePointer[ComplexFloat32],
    y: OpaquePointer,
    incy: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_cgbmv_batched",
        fn (
            Handle,
            Operation,
            Int32,
            Int32,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat32],
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            UnsafePointer[ComplexFloat32],
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(
        handle,
        trans,
        m,
        n,
        kl,
        ku,
        alpha,
        _a,
        lda,
        x,
        incx,
        beta,
        y,
        incy,
        batch_count,
    )


fn rocblas_sspr2_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    alpha: UnsafePointer[Float32],
    x: UnsafePointer[Float32],
    incx: Int64,
    y: UnsafePointer[Float32],
    incy: Int64,
    _ap: UnsafePointer[Float32],
) -> Status:
    return _get_dylib_function[
        "rocblas_sspr2_64",
        fn (
            Handle,
            Fill,
            Int64,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int64,
            UnsafePointer[Float32],
            Int64,
            UnsafePointer[Float32],
        ) -> Status,
    ]()(handle, uplo, n, alpha, x, incx, y, incy, _ap)


fn rocblas_zher2_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    alpha: UnsafePointer[ComplexFloat64],
    x: UnsafePointer[ComplexFloat64],
    incx: Int64,
    y: UnsafePointer[ComplexFloat64],
    incy: Int64,
    _a: UnsafePointer[ComplexFloat64],
    lda: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_zher2_64",
        fn (
            Handle,
            Fill,
            Int64,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int64,
            UnsafePointer[ComplexFloat64],
            Int64,
            UnsafePointer[ComplexFloat64],
            Int64,
        ) -> Status,
    ]()(handle, uplo, n, alpha, x, incx, y, incy, _a, lda)


fn rocblas_dsymv_batched(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    alpha: UnsafePointer[Float64],
    _a: OpaquePointer,
    lda: Int32,
    x: OpaquePointer,
    incx: Int32,
    beta: UnsafePointer[Float64],
    y: OpaquePointer,
    incy: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_dsymv_batched",
        fn (
            Handle,
            Fill,
            Int32,
            UnsafePointer[Float64],
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            UnsafePointer[Float64],
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(handle, uplo, n, alpha, _a, lda, x, incx, beta, y, incy, batch_count)


fn rocblas_cher2k_batched(
    handle: Handle,
    uplo: Fill,
    trans: Operation,
    n: Int32,
    k: Int32,
    alpha: UnsafePointer[ComplexFloat32],
    _a: OpaquePointer,
    lda: Int32,
    _b: OpaquePointer,
    ldb: Int32,
    beta: UnsafePointer[Float32],
    _c: OpaquePointer,
    ldc: Int32,
    batch_count: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 3 API </b>.

    \\details
    her2k_batched performs a batch of the matrix-matrix operations for a Hermitian rank-2k update:

        C_i := alpha*op( A_i )*op( B_i )^H + conj(alpha)*op( B_i )*op( A_i )^H + beta*C_i,

        where  alpha and beta are scalars, op(A_i) and op(B_i) are n by k matrices, and
        C_i is a n x n Hermitian matrix stored as either upper or lower.

        op( A_i ) = A_i, op( B_i ) = B_i, and A_i and B_i are n by k if trans == rocblas_operation_none
        op( A_i ) = A_i^H, op( B_i ) = B_i^H,  and A_i and B_i are k by n if trans == rocblas_operation_conjugate_transpose

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.

    @param[in]
    uplo    [rocblas_fill]
            - rocblas_fill_upper:  C_i is an upper triangular matrix
            - rocblas_fill_lower:  C_i is a  lower triangular matrix

    @param[in]
    trans  [rocblas_operation]
            - rocblas_operation_conjugate_transpose: op(A) = A^H
            - rocblas_operation_none:                op(A) = A

    @param[in]
    n       [rocblas_int]
            n specifies the number of rows and columns of C_i. n >= 0.

    @param[in]
    k       [rocblas_int]
            k specifies the number of columns of op(A). k >= 0.

    @param[in]
    alpha
            alpha specifies the scalar alpha. When alpha is
            zero then A is not referenced and A need not be set before
            entry.

    @param[in]
    A       device array of device pointers storing each matrix_i A of dimension (lda, k)
            when trans is rocblas_operation_none, otherwise of dimension (lda, n).

    @param[in]
    lda     [rocblas_int]
            lda specifies the first dimension of A_i.

                if trans = rocblas_operation_none,  lda >= max( 1, n ),
                otherwise lda >= max( 1, k ).
    @param[in]
    B       device array of device pointers storing each matrix_i B of dimension (ldb, k)
            when trans is rocblas_operation_none, otherwise of dimension (ldb, n).

    @param[in]
    ldb     [rocblas_int]
            ldb specifies the first dimension of B_i.

                if trans = rocblas_operation_none,  ldb >= max( 1, n ),
                otherwise ldb >= max( 1, k ).
    @param[in]
    beta
            beta specifies the scalar beta. When beta is
            zero then C need not be set before entry.

    @param[in]
    C       device array of device pointers storing each matrix C_i on the GPU.
            The imaginary component of the diagonal elements are not used but are set to zero unless quick return.
            only the upper/lower triangular part of each C_i is accessed.

    @param[in]
    ldc    [rocblas_int]
           ldc specifies the first dimension of C. ldc >= max( 1, n ).
    @param[in]
    batch_count [rocblas_int]
                number of instances in the batch.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_cher2k_batched",
        fn (
            Handle,
            Fill,
            Operation,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat32],
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            UnsafePointer[Float32],
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(
        handle,
        uplo,
        trans,
        n,
        k,
        alpha,
        _a,
        lda,
        _b,
        ldb,
        beta,
        _c,
        ldc,
        batch_count,
    )


fn rocblas_ztrtri_batched(
    handle: Handle,
    uplo: Fill,
    diag: Diagonal,
    n: Int32,
    _a: OpaquePointer,
    lda: Int32,
    inv_a: OpaquePointer,
    ldinv_a: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_ztrtri_batched",
        fn (
            Handle,
            Fill,
            Diagonal,
            Int32,
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(handle, uplo, diag, n, _a, lda, inv_a, ldinv_a, batch_count)


fn rocblas_ztpmv_strided_batched_64(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int64,
    _a: UnsafePointer[ComplexFloat64],
    stride__a: Int64,
    x: UnsafePointer[ComplexFloat64],
    incx: Int64,
    stride_x: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_ztpmv_strided_batched_64",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int64,
            UnsafePointer[ComplexFloat64],
            Int64,
            Int64,
            Int64,
        ) -> Status,
    ]()(
        handle,
        uplo,
        trans_a,
        diag,
        n,
        _a,
        stride__a,
        x,
        incx,
        stride_x,
        batch_count,
    )


fn rocblas_zsyr2_strided_batched(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat64],
    x: UnsafePointer[ComplexFloat64],
    incx: Int32,
    stridex: Int64,
    y: UnsafePointer[ComplexFloat64],
    incy: Int32,
    stridey: Int64,
    _a: UnsafePointer[ComplexFloat64],
    lda: Int32,
    stride_a: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_zsyr2_strided_batched",
        fn (
            Handle,
            Fill,
            Int32,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        uplo,
        n,
        alpha,
        x,
        incx,
        stridex,
        y,
        incy,
        stridey,
        _a,
        lda,
        stride_a,
        batch_count,
    )


fn rocblas_zsyr2_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    alpha: UnsafePointer[ComplexFloat64],
    x: UnsafePointer[ComplexFloat64],
    incx: Int64,
    y: UnsafePointer[ComplexFloat64],
    incy: Int64,
    _a: UnsafePointer[ComplexFloat64],
    lda: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_zsyr2_64",
        fn (
            Handle,
            Fill,
            Int64,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int64,
            UnsafePointer[ComplexFloat64],
            Int64,
            UnsafePointer[ComplexFloat64],
            Int64,
        ) -> Status,
    ]()(handle, uplo, n, alpha, x, incx, y, incy, _a, lda)


fn rocblas_device_malloc_free(
    ptr: UnsafePointer[MallocBase],
) -> Status:
    return _get_dylib_function[
        "rocblas_device_malloc_free",
        fn (UnsafePointer[MallocBase]) -> Status,
    ]()(ptr)


fn rocblas_zhpr2_strided_batched_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    alpha: UnsafePointer[ComplexFloat64],
    x: UnsafePointer[ComplexFloat64],
    incx: Int64,
    stride_x: Int64,
    y: UnsafePointer[ComplexFloat64],
    incy: Int64,
    stride_y: Int64,
    _ap: UnsafePointer[ComplexFloat64],
    stride__a: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_zhpr2_strided_batched_64",
        fn (
            Handle,
            Fill,
            Int64,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int64,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int64,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int64,
            Int64,
        ) -> Status,
    ]()(
        handle,
        uplo,
        n,
        alpha,
        x,
        incx,
        stride_x,
        y,
        incy,
        stride_y,
        _ap,
        stride__a,
        batch_count,
    )


fn rocblas_icamin_strided_batched_64(
    handle: Handle,
    n: Int64,
    x: UnsafePointer[ComplexFloat32],
    incx: Int64,
    stridex: Int64,
    batch_count: Int64,
    result: UnsafePointer[Int64],
) -> Status:
    return _get_dylib_function[
        "rocblas_icamin_strided_batched_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int64,
            Int64,
            Int64,
            UnsafePointer[Int64],
        ) -> Status,
    ]()(handle, n, x, incx, stridex, batch_count, result)


fn rocblas_idamax(
    handle: Handle,
    n: Int32,
    x: UnsafePointer[Float64],
    incx: Int32,
    result: UnsafePointer[Int32],
) -> Status:
    return _get_dylib_function[
        "rocblas_idamax",
        fn (
            Handle, Int32, UnsafePointer[Float64], Int32, UnsafePointer[Int32]
        ) -> Status,
    ]()(handle, n, x, incx, result)


fn rocblas_ctrsv_batched(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int32,
    _a: OpaquePointer,
    lda: Int32,
    x: OpaquePointer,
    incx: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_ctrsv_batched",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int32,
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(handle, uplo, trans_a, diag, n, _a, lda, x, incx, batch_count)


fn rocblas_zaxpy_strided_batched(
    handle: Handle,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat64],
    x: UnsafePointer[ComplexFloat64],
    incx: Int32,
    stridex: Int64,
    y: UnsafePointer[ComplexFloat64],
    incy: Int32,
    stridey: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_zaxpy_strided_batched",
        fn (
            Handle,
            Int32,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(handle, n, alpha, x, incx, stridex, y, incy, stridey, batch_count)


fn rocblas_cgemm(
    handle: Handle,
    trans_a: Operation,
    trans_b: Operation,
    m: Int32,
    n: Int32,
    k: Int32,
    alpha: UnsafePointer[ComplexFloat32],
    _a: UnsafePointer[ComplexFloat32],
    lda: Int32,
    _b: UnsafePointer[ComplexFloat32],
    ldb: Int32,
    beta: UnsafePointer[ComplexFloat32],
    _c: UnsafePointer[ComplexFloat32],
    ldc: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_cgemm",
        fn (
            Handle,
            Operation,
            Operation,
            Int32,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int32,
            UnsafePointer[ComplexFloat32],
            Int32,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int32,
        ) -> Status,
    ]()(
        handle,
        trans_a,
        trans_b,
        m,
        n,
        k,
        alpha,
        _a,
        lda,
        _b,
        ldb,
        beta,
        _c,
        ldc,
    )


fn rocblas_crotg_64(
    handle: Handle,
    a: UnsafePointer[ComplexFloat32],
    b: UnsafePointer[ComplexFloat32],
    c: UnsafePointer[Float32],
    s: UnsafePointer[ComplexFloat32],
) -> Status:
    return _get_dylib_function[
        "rocblas_crotg_64",
        fn (
            Handle,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            UnsafePointer[Float32],
            UnsafePointer[ComplexFloat32],
        ) -> Status,
    ]()(handle, a, b, c, s)


fn rocblas_srot_strided_batched(
    handle: Handle,
    n: Int32,
    x: UnsafePointer[Float32],
    incx: Int32,
    stride_x: Int64,
    y: UnsafePointer[Float32],
    incy: Int32,
    stride_y: Int64,
    c: UnsafePointer[Float32],
    s: UnsafePointer[Float32],
    batch_count: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 1 API </b>.

    \\details
    rot_strided_batched applies the Givens rotation matrix defined by c=cos(alpha) and s=sin(alpha) to strided batched vectors x_i and y_i, for i = 1, ..., batch_count.
    Scalars c and s may be stored in either host or device memory, location is specified by calling rocblas_set_pointer_mode.

    @param[in]
    handle  [rocblas_handle]
            handle to the rocblas library context queue.
    @param[in]
    n       [rocblas_int]
            number of elements in each x_i and y_i vectors.
    @param[in, out]
    x       device pointer to the first vector x_1.
    @param[in]
    incx    [rocblas_int]
            specifies the increment between elements of each x_i.
    @param[in]
    stride_x [rocblas_stride]
             specifies the increment from the beginning of x_i to the beginning of x_(i+1).
    @param[in, out]
    y       device pointer to the first vector y_1.
    @param[in]
    incy    [rocblas_int]
            specifies the increment between elements of each y_i.
    @param[in]
    stride_y [rocblas_stride]
             specifies the increment from the beginning of y_i to the beginning of y_(i+1)
    @param[in]
    c       device pointer or host pointer to scalar cosine component of the rotation matrix.
    @param[in]
    s       device pointer or host pointer to scalar sine component of the rotation matrix.
    @param[in]
    batch_count [rocblas_int]
            the number of x and y arrays, i.e. the number of batches.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_srot_strided_batched",
        fn (
            Handle,
            Int32,
            UnsafePointer[Float32],
            Int32,
            Int64,
            UnsafePointer[Float32],
            Int32,
            Int64,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int32,
        ) -> Status,
    ]()(handle, n, x, incx, stride_x, y, incy, stride_y, c, s, batch_count)


fn rocblas_srot(
    handle: Handle,
    n: Int32,
    x: UnsafePointer[Float32],
    incx: Int32,
    y: UnsafePointer[Float32],
    incy: Int32,
    c: UnsafePointer[Float32],
    s: UnsafePointer[Float32],
) -> Status:
    """
    \\brief <b> BLAS Level 1 API </b>.

    \\details
    rot applies the Givens rotation matrix defined by c=cos(alpha) and s=sin(alpha) to vectors x and y.
    Scalars c and s may be stored in either host or device memory. Location is specified by calling rocblas_set_pointer_mode.

    @param[in]
    handle  [rocblas_handle]
            handle to the rocblas library context queue.
    @param[in]
    n       [rocblas_int]
            number of elements in the x and y vectors.
    @param[in, out]
    x       device pointer storing vector x.
    @param[in]
    incx    [rocblas_int]
            specifies the increment between elements of x.
    @param[in, out]
    y       device pointer storing vector y.
    @param[in]
    incy    [rocblas_int]
            specifies the increment between elements of y.
    @param[in]
    c       device pointer or host pointer storing scalar cosine component of the rotation matrix.
    @param[in]
    s       device pointer or host pointer storing scalar sine component of the rotation matrix.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_srot",
        fn (
            Handle,
            Int32,
            UnsafePointer[Float32],
            Int32,
            UnsafePointer[Float32],
            Int32,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
        ) -> Status,
    ]()(handle, n, x, incx, y, incy, c, s)


fn rocblas_zdotc_strided_batched_64(
    handle: Handle,
    n: Int64,
    x: UnsafePointer[ComplexFloat64],
    incx: Int64,
    stridex: Int64,
    y: UnsafePointer[ComplexFloat64],
    incy: Int64,
    stridey: Int64,
    batch_count: Int64,
    result: UnsafePointer[ComplexFloat64],
) -> Status:
    return _get_dylib_function[
        "rocblas_zdotc_strided_batched_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int64,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int64,
            Int64,
            Int64,
            UnsafePointer[ComplexFloat64],
        ) -> Status,
    ]()(handle, n, x, incx, stridex, y, incy, stridey, batch_count, result)


fn rocblas_scal_strided_batched_ex(
    handle: Handle,
    n: Int32,
    alpha: OpaquePointer,
    alpha_type: DataType,
    x: OpaquePointer,
    x_type: DataType,
    incx: Int32,
    stridex: Int64,
    batch_count: Int32,
    execution_type: DataType,
) -> Status:
    """
    \\brief <b> BLAS EX API </b>.

    \\details
    scal_strided_batched_ex  scales each element of vector x with scalar alpha over a set
    of strided batched vectors.

        x := alpha * x

    Currently supported datatypes are as follows:

    ----------------------------------------
    | alpha_type | x_type | execution_type |
    |------------|--------|----------------|
    |  f32_r     | bf16_r |     f32_r      |
    |  bf16_r    | bf16_r |     f32_r      |
    |  f16_r     | f16_r  |     f16_r      |
    |  f16_r     | f16_r  |     f32_r      |
    |  f32_r     | f16_r  |     f32_r      |
    |  f32_r     | f32_r  |     f32_r      |
    |  f64_r     | f64_r  |     f64_r      |
    |  f32_c     | f32_c  |     f32_c      |
    |  f64_c     | f64_c  |     f64_c      |
    |  f32_r     | f32_c  |     f32_c      |
    |  f64_r     | f64_c  |     f64_c      |
    ----------------------------------------

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    n         [rocblas_int]
              the number of elements in x.
    @param[in]
    alpha     device pointer or host pointer for the scalar alpha.
    @param[in]
    alpha_type [rocblas_datatype]
               specifies the datatype of alpha.
    @param[in, out]
    x         device pointer to the first vector x_1.
    @param[in]
    x_type [rocblas_datatype]
           specifies the datatype of each vector x_i.
    @param[in]
    incx      [rocblas_int]
              specifies the increment for the elements of each x_i.
    @param[in]
    stridex   [rocblas_stride]
              stride from the start of one vector (x_i) to the next one (x_i+1).
              There are no restrictions placed on stridex. However, ensure that stridex is of appropriate size. For a typical
              case this means stridex >= n * incx.
    @param[in]
    batch_count [rocblas_int]
                number of instances in the batch.
    @param[in]
    execution_type [rocblas_datatype]
                   specifies the datatype of computation.


    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_scal_strided_batched_ex",
        fn (
            Handle,
            Int32,
            OpaquePointer,
            DataType,
            OpaquePointer,
            DataType,
            Int32,
            Int64,
            Int32,
            DataType,
        ) -> Status,
    ]()(
        handle,
        n,
        alpha,
        alpha_type,
        x,
        x_type,
        incx,
        stridex,
        batch_count,
        execution_type,
    )


fn rocblas_cscal_strided_batched(
    handle: Handle,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat32],
    x: UnsafePointer[ComplexFloat32],
    incx: Int32,
    stride_x: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_cscal_strided_batched",
        fn (
            Handle,
            Int32,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(handle, n, alpha, x, incx, stride_x, batch_count)


fn rocblas_dspr2_strided_batched(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    alpha: UnsafePointer[Float64],
    x: UnsafePointer[Float64],
    incx: Int32,
    stride_x: Int64,
    y: UnsafePointer[Float64],
    incy: Int32,
    stride_y: Int64,
    _ap: UnsafePointer[Float64],
    stride__a: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_dspr2_strided_batched",
        fn (
            Handle,
            Fill,
            Int32,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int32,
            Int64,
            UnsafePointer[Float64],
            Int32,
            Int64,
            UnsafePointer[Float64],
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        uplo,
        n,
        alpha,
        x,
        incx,
        stride_x,
        y,
        incy,
        stride_y,
        _ap,
        stride__a,
        batch_count,
    )


fn rocblas_dnrm2_batched(
    handle: Handle,
    n: Int32,
    x: OpaquePointer,
    incx: Int32,
    batch_count: Int32,
    results: UnsafePointer[Float64],
) -> Status:
    return _get_dylib_function[
        "rocblas_dnrm2_batched",
        fn (
            Handle,
            Int32,
            OpaquePointer,
            Int32,
            Int32,
            UnsafePointer[Float64],
        ) -> Status,
    ]()(handle, n, x, incx, batch_count, results)


fn rocblas_ddot_batched(
    handle: Handle,
    n: Int32,
    x: OpaquePointer,
    incx: Int32,
    y: OpaquePointer,
    incy: Int32,
    batch_count: Int32,
    result: UnsafePointer[Float64],
) -> Status:
    return _get_dylib_function[
        "rocblas_ddot_batched",
        fn (
            Handle,
            Int32,
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            Int32,
            UnsafePointer[Float64],
        ) -> Status,
    ]()(handle, n, x, incx, y, incy, batch_count, result)


fn rocblas_idamax_64(
    handle: Handle,
    n: Int64,
    x: UnsafePointer[Float64],
    incx: Int64,
    result: UnsafePointer[Int64],
) -> Status:
    return _get_dylib_function[
        "rocblas_idamax_64",
        fn (
            Handle, Int64, UnsafePointer[Float64], Int64, UnsafePointer[Int64]
        ) -> Status,
    ]()(handle, n, x, incx, result)


fn rocblas_csyr2_strided_batched(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat32],
    x: UnsafePointer[ComplexFloat32],
    incx: Int32,
    stridex: Int64,
    y: UnsafePointer[ComplexFloat32],
    incy: Int32,
    stridey: Int64,
    _a: UnsafePointer[ComplexFloat32],
    lda: Int32,
    stride_a: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_csyr2_strided_batched",
        fn (
            Handle,
            Fill,
            Int32,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        uplo,
        n,
        alpha,
        x,
        incx,
        stridex,
        y,
        incy,
        stridey,
        _a,
        lda,
        stride_a,
        batch_count,
    )


fn rocblas_cdotu_strided_batched_64(
    handle: Handle,
    n: Int64,
    x: UnsafePointer[ComplexFloat32],
    incx: Int64,
    stridex: Int64,
    y: UnsafePointer[ComplexFloat32],
    incy: Int64,
    stridey: Int64,
    batch_count: Int64,
    result: UnsafePointer[ComplexFloat32],
) -> Status:
    return _get_dylib_function[
        "rocblas_cdotu_strided_batched_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int64,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int64,
            Int64,
            Int64,
            UnsafePointer[ComplexFloat32],
        ) -> Status,
    ]()(handle, n, x, incx, stridex, y, incy, stridey, batch_count, result)


fn rocblas_hgemm_strided_batched(
    handle: Handle,
    trans_a: Operation,
    trans_b: Operation,
    m: Int32,
    n: Int32,
    k: Int32,
    alpha: UnsafePointer[Float16],
    _a: UnsafePointer[Float16],
    lda: Int32,
    stride_a: Int64,
    _b: UnsafePointer[Float16],
    ldb: Int32,
    stride_b: Int64,
    beta: UnsafePointer[Float16],
    _c: UnsafePointer[Float16],
    ldc: Int32,
    stride_c: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_hgemm_strided_batched",
        fn (
            Handle,
            Operation,
            Operation,
            Int32,
            Int32,
            Int32,
            UnsafePointer[Float16],
            UnsafePointer[Float16],
            Int32,
            Int64,
            UnsafePointer[Float16],
            Int32,
            Int64,
            UnsafePointer[Float16],
            UnsafePointer[Float16],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        trans_a,
        trans_b,
        m,
        n,
        k,
        alpha,
        _a,
        lda,
        stride_a,
        _b,
        ldb,
        stride_b,
        beta,
        _c,
        ldc,
        stride_c,
        batch_count,
    )


fn rocblas_dot_strided_batched_ex(
    handle: Handle,
    n: Int32,
    x: OpaquePointer,
    x_type: DataType,
    incx: Int32,
    stride_x: Int64,
    y: OpaquePointer,
    y_type: DataType,
    incy: Int32,
    stride_y: Int64,
    batch_count: Int32,
    result: OpaquePointer,
    result_type: DataType,
    execution_type: DataType,
) -> Status:
    """
    \\brief <b> BLAS EX API </b>.

    \\details
    dot_strided_batched_ex  performs a batch of dot products of vectors x and y.

        result_i = x_i * y_i;

    dotc_strided_batched_ex  performs a batch of dot products of the conjugate of complex vector x and complex vector y

        result_i = conjugate (x_i) * y_i;

    where (x_i, y_i) is the i-th instance of the batch.
    x_i and y_i are vectors, for i = 1, ..., batch_count

    Currently supported datatypes are as follows:

    --------------------------------------------------
    | x_type | y_type | result_type | execution_type |
    |--------|--------|-------------|----------------|
    | f16_r  | f16_r  |    f16_r    |     f16_r      |
    | f16_r  | f16_r  |    f16_r    |     f32_r      |
    | bf16_r | bf16_r |    bf16_r   |     f32_r      |
    | f32_r  | f32_r  |    f32_r    |     f32_r      |
    | f32_r  | f32_r  |    f64_r    |     f64_r      |
    | f64_r  | f64_r  |    f64_r    |     f64_r      |
    | f32_c  | f32_c  |    f32_c    |     f32_c      |
    | f64_c  | f64_c  |    f64_c    |     f64_c      |
    --------------------------------------------------

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    n         [rocblas_int]
              the number of elements in each x_i and y_i.
    @param[in]
    x         device pointer to the first vector (x_1) in the batch.
    @param[in]
    x_type [rocblas_datatype]
           specifies the datatype of each vector x_i.
    @param[in]
    incx      [rocblas_int]
              specifies the increment for the elements of each x_i.
    @param[in]
    stride_x    [rocblas_stride]
                stride from the start of one vector (x_i) and the next one (x_i+1)
    @param[in]
    y         device pointer to the first vector (y_1) in the batch.
    @param[in]
    y_type [rocblas_datatype]
          specifies the datatype of each vector y_i.
    @param[in]
    incy      [rocblas_int]
              specifies the increment for the elements of each y_i.
    @param[in]
    stride_y    [rocblas_stride]
                stride from the start of one vector (y_i) and the next one (y_i+1)
    @param[in]
    batch_count [rocblas_int]
                number of instances in the batch.
    @param[in, out]
    result
              device array or host array of batch_count size to store the dot products of each batch.
              return 0.0 for each element if n <= 0.
    @param[in]
    result_type [rocblas_datatype]
                specifies the datatype of the result.
    @param[in]
    execution_type [rocblas_datatype]
                  specifies the datatype of computation.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_dot_strided_batched_ex",
        fn (
            Handle,
            Int32,
            OpaquePointer,
            DataType,
            Int32,
            Int64,
            OpaquePointer,
            DataType,
            Int32,
            Int64,
            Int32,
            OpaquePointer,
            DataType,
            DataType,
        ) -> Status,
    ]()(
        handle,
        n,
        x,
        x_type,
        incx,
        stride_x,
        y,
        y_type,
        incy,
        stride_y,
        batch_count,
        result,
        result_type,
        execution_type,
    )


fn rocblas_ssbmv_strided_batched(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    k: Int32,
    alpha: UnsafePointer[Float32],
    _a: UnsafePointer[Float32],
    lda: Int32,
    stride_a: Int64,
    x: UnsafePointer[Float32],
    incx: Int32,
    stridex: Int64,
    beta: UnsafePointer[Float32],
    y: UnsafePointer[Float32],
    incy: Int32,
    stridey: Int64,
    batch_count: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 2 API </b>.

    \\details
    sbmv_strided_batched performs the matrix-vector operation:

        y_i := alpha*A_i*x_i + beta*y_i
        where (A_i, x_i, y_i) is the i-th instance of the batch.
        alpha and beta are scalars, x_i and y_i are vectors and A_i is an
        n by n symmetric banded matrix, for i = 1, ..., batch_count.
        A should contain an upper or lower triangular n by n symmetric banded matrix.

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    uplo      [rocblas_fill]
            specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
            - if rocblas_fill_upper, the lower part of A is not referenced
            - if rocblas_fill_lower, the upper part of A is not referenced
    @param[in]
    n         [rocblas_int]
              number of rows and columns of each matrix A_i.
    @param[in]
    k         [rocblas_int]
              specifies the number of sub- and super-diagonals.
    @param[in]
    alpha
              device pointer or host pointer to scalar alpha.
    @param[in]
    A         Device pointer to the first matrix A_1 on the GPU.
    @param[in]
    lda       [rocblas_int]
              specifies the leading dimension of each matrix A_i.
    @param[in]
    strideA     [rocblas_stride]
                stride from the start of one matrix (A_i) and the next one (A_i+1).
    @param[in]
    x         Device pointer to the first vector x_1 on the GPU.
    @param[in]
    incx      [rocblas_int]
              specifies the increment for the elements of each vector x_i.
    @param[in]
    stridex     [rocblas_stride]
                stride from the start of one vector (x_i) and the next one (x_i+1).
                There are no restrictions placed on stridex. However, ensure that stridex is of appropriate size.
                This typically means stridex >= n * incx. stridex should be non zero.
    @param[in]
    beta      device pointer or host pointer to scalar beta.
    @param[out]
    y         Device pointer to the first vector y_1 on the GPU.
    @param[in]
    incy      [rocblas_int]
              specifies the increment for the elements of each vector y_i.
    @param[in]
    stridey     [rocblas_stride]
                stride from the start of one vector (y_i) and the next one (y_i+1).
                There are no restrictions placed on stridey. However, ensure that stridey is of appropriate size.
                This typically means stridey >= n * incy. stridey should be non zero.
    @param[in]
    batch_count [rocblas_int]
                number of instances in the batch.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_ssbmv_strided_batched",
        fn (
            Handle,
            Fill,
            Int32,
            Int32,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int32,
            Int64,
            UnsafePointer[Float32],
            Int32,
            Int64,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        uplo,
        n,
        k,
        alpha,
        _a,
        lda,
        stride_a,
        x,
        incx,
        stridex,
        beta,
        y,
        incy,
        stridey,
        batch_count,
    )


fn rocblas_zsymm(
    handle: Handle,
    side: Side,
    uplo: Fill,
    m: Int32,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat64],
    _a: UnsafePointer[ComplexFloat64],
    lda: Int32,
    _b: UnsafePointer[ComplexFloat64],
    ldb: Int32,
    beta: UnsafePointer[ComplexFloat64],
    _c: UnsafePointer[ComplexFloat64],
    ldc: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_zsymm",
        fn (
            Handle,
            Side,
            Fill,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int32,
            UnsafePointer[ComplexFloat64],
            Int32,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int32,
        ) -> Status,
    ]()(handle, side, uplo, m, n, alpha, _a, lda, _b, ldb, beta, _c, ldc)


fn rocblas_dtpmv_strided_batched(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int32,
    _a: UnsafePointer[Float64],
    stride__a: Int64,
    x: UnsafePointer[Float64],
    incx: Int32,
    stride_x: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_dtpmv_strided_batched",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int32,
            UnsafePointer[Float64],
            Int64,
            UnsafePointer[Float64],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        uplo,
        trans_a,
        diag,
        n,
        _a,
        stride__a,
        x,
        incx,
        stride_x,
        batch_count,
    )


fn rocblas_zdscal_batched_64(
    handle: Handle,
    n: Int64,
    alpha: UnsafePointer[Float64],
    x: OpaquePointer,
    incx: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_zdscal_batched_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[Float64],
            OpaquePointer,
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, n, alpha, x, incx, batch_count)


fn rocblas_izamax_batched_64(
    handle: Handle,
    n: Int64,
    x: OpaquePointer,
    incx: Int64,
    batch_count: Int64,
    result: UnsafePointer[Int64],
) -> Status:
    return _get_dylib_function[
        "rocblas_izamax_batched_64",
        fn (
            Handle,
            Int64,
            OpaquePointer,
            Int64,
            Int64,
            UnsafePointer[Int64],
        ) -> Status,
    ]()(handle, n, x, incx, batch_count, result)


fn rocblas_tssgemv_batched_64(
    handle: Handle,
    trans: Operation,
    m: Int64,
    n: Int64,
    alpha: UnsafePointer[Float32],
    _a: OpaquePointer,
    lda: Int64,
    x: OpaquePointer,
    incx: Int64,
    beta: UnsafePointer[Float32],
    y: OpaquePointer,
    incy: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_tssgemv_batched_64",
        fn (
            Handle,
            Operation,
            Int64,
            Int64,
            UnsafePointer[Float32],
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            UnsafePointer[Float32],
            OpaquePointer,
            Int64,
            Int64,
        ) -> Status,
    ]()(
        handle, trans, m, n, alpha, _a, lda, x, incx, beta, y, incy, batch_count
    )


fn rocblas_cgerc_strided_batched(
    handle: Handle,
    m: Int32,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat32],
    x: UnsafePointer[ComplexFloat32],
    incx: Int32,
    stridex: Int64,
    y: UnsafePointer[ComplexFloat32],
    incy: Int32,
    stridey: Int64,
    _a: UnsafePointer[ComplexFloat32],
    lda: Int32,
    stride_a: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_cgerc_strided_batched",
        fn (
            Handle,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        m,
        n,
        alpha,
        x,
        incx,
        stridex,
        y,
        incy,
        stridey,
        _a,
        lda,
        stride_a,
        batch_count,
    )


fn rocblas_dgemv_strided_batched_64(
    handle: Handle,
    trans_a: Operation,
    m: Int64,
    n: Int64,
    alpha: UnsafePointer[Float64],
    _a: UnsafePointer[Float64],
    lda: Int64,
    stride_a: Int64,
    x: UnsafePointer[Float64],
    incx: Int64,
    stridex: Int64,
    beta: UnsafePointer[Float64],
    y: UnsafePointer[Float64],
    incy: Int64,
    stridey: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_dgemv_strided_batched_64",
        fn (
            Handle,
            Operation,
            Int64,
            Int64,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int64,
            Int64,
            UnsafePointer[Float64],
            Int64,
            Int64,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int64,
            Int64,
            Int64,
        ) -> Status,
    ]()(
        handle,
        trans_a,
        m,
        n,
        alpha,
        _a,
        lda,
        stride_a,
        x,
        incx,
        stridex,
        beta,
        y,
        incy,
        stridey,
        batch_count,
    )


fn rocblas_dgemm(
    handle: Handle,
    trans_a: Operation,
    trans_b: Operation,
    m: Int32,
    n: Int32,
    k: Int32,
    alpha: UnsafePointer[Float64],
    _a: UnsafePointer[Float64],
    lda: Int32,
    _b: UnsafePointer[Float64],
    ldb: Int32,
    beta: UnsafePointer[Float64],
    _c: UnsafePointer[Float64],
    ldc: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_dgemm",
        fn (
            Handle,
            Operation,
            Operation,
            Int32,
            Int32,
            Int32,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int32,
            UnsafePointer[Float64],
            Int32,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int32,
        ) -> Status,
    ]()(
        handle,
        trans_a,
        trans_b,
        m,
        n,
        k,
        alpha,
        _a,
        lda,
        _b,
        ldb,
        beta,
        _c,
        ldc,
    )


fn rocblas_zscal_64(
    handle: Handle,
    n: Int64,
    alpha: UnsafePointer[ComplexFloat64],
    x: UnsafePointer[ComplexFloat64],
    incx: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_zscal_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int64,
        ) -> Status,
    ]()(handle, n, alpha, x, incx)


fn rocblas_csyr(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat32],
    x: UnsafePointer[ComplexFloat32],
    incx: Int32,
    _a: UnsafePointer[ComplexFloat32],
    lda: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_csyr",
        fn (
            Handle,
            Fill,
            Int32,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int32,
            UnsafePointer[ComplexFloat32],
            Int32,
        ) -> Status,
    ]()(handle, uplo, n, alpha, x, incx, _a, lda)


fn rocblas_ztrsm_strided_batched_64(
    handle: Handle,
    side: Side,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    m: Int64,
    n: Int64,
    alpha: UnsafePointer[ComplexFloat64],
    _a: UnsafePointer[ComplexFloat64],
    lda: Int64,
    stride_a: Int64,
    _b: UnsafePointer[ComplexFloat64],
    ldb: Int64,
    stride_b: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_ztrsm_strided_batched_64",
        fn (
            Handle,
            Side,
            Fill,
            Operation,
            Diagonal,
            Int64,
            Int64,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int64,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int64,
            Int64,
            Int64,
        ) -> Status,
    ]()(
        handle,
        side,
        uplo,
        trans_a,
        diag,
        m,
        n,
        alpha,
        _a,
        lda,
        stride_a,
        _b,
        ldb,
        stride_b,
        batch_count,
    )


fn rocblas_dsbmv(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    k: Int32,
    alpha: UnsafePointer[Float64],
    _a: UnsafePointer[Float64],
    lda: Int32,
    x: UnsafePointer[Float64],
    incx: Int32,
    beta: UnsafePointer[Float64],
    y: UnsafePointer[Float64],
    incy: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_dsbmv",
        fn (
            Handle,
            Fill,
            Int32,
            Int32,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int32,
            UnsafePointer[Float64],
            Int32,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int32,
        ) -> Status,
    ]()(handle, uplo, n, k, alpha, _a, lda, x, incx, beta, y, incy)


fn rocblas_dger_64(
    handle: Handle,
    m: Int64,
    n: Int64,
    alpha: UnsafePointer[Float64],
    x: UnsafePointer[Float64],
    incx: Int64,
    y: UnsafePointer[Float64],
    incy: Int64,
    _a: UnsafePointer[Float64],
    lda: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_dger_64",
        fn (
            Handle,
            Int64,
            Int64,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int64,
            UnsafePointer[Float64],
            Int64,
            UnsafePointer[Float64],
            Int64,
        ) -> Status,
    ]()(handle, m, n, alpha, x, incx, y, incy, _a, lda)


fn rocblas_ssymm_batched(
    handle: Handle,
    side: Side,
    uplo: Fill,
    m: Int32,
    n: Int32,
    alpha: UnsafePointer[Float32],
    _a: OpaquePointer,
    lda: Int32,
    _b: OpaquePointer,
    ldb: Int32,
    beta: UnsafePointer[Float32],
    _c: OpaquePointer,
    ldc: Int32,
    batch_count: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 3 API </b>.

    \\details
    symm_batched performs a batch of the matrix-matrix operations:

        C_i := alpha*A_i*B_i + beta*C_i if side == rocblas_side_left,
        C_i := alpha*B_i*A_i + beta*C_i if side == rocblas_side_right,

        where alpha and beta are scalars, B_i and C_i are m by n matrices, and
        A_i is a symmetric matrix stored as either upper or lower.

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.

    @param[in]
    side  [rocblas_side]
            - rocblas_side_left:      C_i := alpha*A_i*B_i + beta*C_i
            - rocblas_side_right:     C_i := alpha*B_i*A_i + beta*C_i

    @param[in]
    uplo    [rocblas_fill]
            - rocblas_fill_upper:  A_i is an upper triangular matrix
            - rocblas_fill_lower:  A_i is a  lower triangular matrix

    @param[in]
    m       [rocblas_int]
            m specifies the number of rows of B_i and C_i. m >= 0.

    @param[in]
    n       [rocblas_int]
            n specifies the number of columns of B_i and C_i. n >= 0.

    @param[in]
    alpha
            alpha specifies the scalar alpha. When alpha is
            zero then A_i and B_i are not referenced.

    @param[in]
    A       device array of device pointers storing each matrix A_i on the GPU.
            - A_i is m by m if side == rocblas_side_left
            - A_i is n by n if side == rocblas_side_right
            only the upper/lower triangular part is accessed.

    @param[in]
    lda     [rocblas_int]
            lda specifies the first dimension of A_i.

                if side = rocblas_side_left,  lda >= max( 1, m ),
                otherwise lda >= max( 1, n ).

    @param[in]
    B       device array of device pointers storing each matrix B_i on the GPU.
            Matrix dimension is m by n

    @param[in]
    ldb     [rocblas_int]
            ldb specifies the first dimension of B_i. ldb >= max( 1, m ).

    @param[in]
    beta
            beta specifies the scalar beta. When beta is
            zero then C_i need not be set before entry.

    @param[in]
    C       device array of device pointers storing each matrix C_i on the GPU.
            Matrix dimension is m by n.

    @param[in]
    ldc    [rocblas_int]
           ldc specifies the first dimension of C_i. ldc >= max( 1, m ).

    @param[in]
    batch_count [rocblas_int]
                number of instances in the batch.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_ssymm_batched",
        fn (
            Handle,
            Side,
            Fill,
            Int32,
            Int32,
            UnsafePointer[Float32],
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            UnsafePointer[Float32],
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(
        handle,
        side,
        uplo,
        m,
        n,
        alpha,
        _a,
        lda,
        _b,
        ldb,
        beta,
        _c,
        ldc,
        batch_count,
    )


fn rocblas_cdotc_64(
    handle: Handle,
    n: Int64,
    x: UnsafePointer[ComplexFloat32],
    incx: Int64,
    y: UnsafePointer[ComplexFloat32],
    incy: Int64,
    result: UnsafePointer[ComplexFloat32],
) -> Status:
    return _get_dylib_function[
        "rocblas_cdotc_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int64,
            UnsafePointer[ComplexFloat32],
            Int64,
            UnsafePointer[ComplexFloat32],
        ) -> Status,
    ]()(handle, n, x, incx, y, incy, result)


fn rocblas_stbsv_batched_64(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int64,
    k: Int64,
    _a: OpaquePointer,
    lda: Int64,
    x: OpaquePointer,
    incx: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_stbsv_batched_64",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int64,
            Int64,
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, uplo, trans_a, diag, n, k, _a, lda, x, incx, batch_count)


fn rocblas_start_device_memory_size_query(handle: Handle) -> Status:
    """\\brief
    \\details
    Indicates that subsequent rocBLAS kernel calls should collect the optimal device memory size in bytes for their given kernel arguments
    and keep track of the maximum.
    Each kernel call can reuse temporary device memory on the same stream so the maximum is collected.
    Returns rocblas_status_size_query_mismatch if another size query is already in progress; returns rocblas_status_success otherwise
    @param[in]
    handle          rocblas handle
    ****************************************************************************.
    """
    return _get_dylib_function[
        "rocblas_start_device_memory_size_query", fn (Handle) -> Status
    ]()(handle)


fn rocblas_zher2(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat64],
    x: UnsafePointer[ComplexFloat64],
    incx: Int32,
    y: UnsafePointer[ComplexFloat64],
    incy: Int32,
    _a: UnsafePointer[ComplexFloat64],
    lda: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_zher2",
        fn (
            Handle,
            Fill,
            Int32,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int32,
            UnsafePointer[ComplexFloat64],
            Int32,
            UnsafePointer[ComplexFloat64],
            Int32,
        ) -> Status,
    ]()(handle, uplo, n, alpha, x, incx, y, incy, _a, lda)


fn rocblas_dswap_64(
    handle: Handle,
    n: Int64,
    x: UnsafePointer[Float64],
    incx: Int64,
    y: UnsafePointer[Float64],
    incy: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_dswap_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[Float64],
            Int64,
            UnsafePointer[Float64],
            Int64,
        ) -> Status,
    ]()(handle, n, x, incx, y, incy)


fn rocblas_dsyrk(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    n: Int32,
    k: Int32,
    alpha: UnsafePointer[Float64],
    _a: UnsafePointer[Float64],
    lda: Int32,
    beta: UnsafePointer[Float64],
    _c: UnsafePointer[Float64],
    ldc: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_dsyrk",
        fn (
            Handle,
            Fill,
            Operation,
            Int32,
            Int32,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int32,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int32,
        ) -> Status,
    ]()(handle, uplo, trans_a, n, k, alpha, _a, lda, beta, _c, ldc)


fn rocblas_csrot_strided_batched_64(
    handle: Handle,
    n: Int64,
    x: UnsafePointer[ComplexFloat32],
    incx: Int64,
    stride_x: Int64,
    y: UnsafePointer[ComplexFloat32],
    incy: Int64,
    stride_y: Int64,
    c: UnsafePointer[Float32],
    s: UnsafePointer[Float32],
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_csrot_strided_batched_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int64,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int64,
            Int64,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int64,
        ) -> Status,
    ]()(handle, n, x, incx, stride_x, y, incy, stride_y, c, s, batch_count)


fn rocblas_sswap_64(
    handle: Handle,
    n: Int64,
    x: UnsafePointer[Float32],
    incx: Int64,
    y: UnsafePointer[Float32],
    incy: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_sswap_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[Float32],
            Int64,
            UnsafePointer[Float32],
            Int64,
        ) -> Status,
    ]()(handle, n, x, incx, y, incy)


fn rocblas_saxpy_strided_batched_64(
    handle: Handle,
    n: Int64,
    alpha: UnsafePointer[Float32],
    x: UnsafePointer[Float32],
    incx: Int64,
    stridex: Int64,
    y: UnsafePointer[Float32],
    incy: Int64,
    stridey: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_saxpy_strided_batched_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int64,
            Int64,
            UnsafePointer[Float32],
            Int64,
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, n, alpha, x, incx, stridex, y, incy, stridey, batch_count)


fn rocblas_sswap_batched(
    handle: Handle,
    n: Int32,
    x: OpaquePointer,
    incx: Int32,
    y: OpaquePointer,
    incy: Int32,
    batch_count: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 1 API </b>.

    \\details
    swap_batched interchanges vectors x_i and y_i, for i = 1 , ... , batch_count:

        y_i := x_i;
        x_i := y_i

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    n         [rocblas_int]
              the number of elements in each x_i and y_i.
    @param[in, out]
    x         device array of device pointers storing each vector x_i.
    @param[in]
    incx      [rocblas_int]
              specifies the increment for the elements of each x_i.
    @param[in, out]
    y         device array of device pointers storing each vector y_i.
    @param[in]
    incy      [rocblas_int]
              specifies the increment for the elements of each y_i.
    @param[in]
    batch_count [rocblas_int]
                number of instances in the batch.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_sswap_batched",
        fn (
            Handle,
            Int32,
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(handle, n, x, incx, y, incy, batch_count)


fn rocblas_ctbsv(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int32,
    k: Int32,
    _a: UnsafePointer[ComplexFloat32],
    lda: Int32,
    x: UnsafePointer[ComplexFloat32],
    incx: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_ctbsv",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat32],
            Int32,
            UnsafePointer[ComplexFloat32],
            Int32,
        ) -> Status,
    ]()(handle, uplo, trans_a, diag, n, k, _a, lda, x, incx)


fn rocblas_stop_device_memory_size_query(
    handle: Handle, size: UnsafePointer[Int]
) -> Status:
    """\\brief
    \\details
    Stops collecting optimal device memory size information.
    Returns rocblas_status_size_query_mismatch if a collection is not underway; rocblas_status_invalid_handle if handle is nullptr;
    rocblas_status_invalid_pointer if size is nullptr; rocblas_status_success otherwise
    @param[in]
    handle          rocblas handle
    @param[out]
    size            maximum of the optimal sizes collected
    ****************************************************************************.
    """
    return _get_dylib_function[
        "rocblas_stop_device_memory_size_query",
        fn (Handle, UnsafePointer[Int]) -> Status,
    ]()(handle, size)


fn rocblas_zgerc_batched(
    handle: Handle,
    m: Int32,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat64],
    x: OpaquePointer,
    incx: Int32,
    y: OpaquePointer,
    incy: Int32,
    _a: OpaquePointer,
    lda: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_zgerc_batched",
        fn (
            Handle,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat64],
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(handle, m, n, alpha, x, incx, y, incy, _a, lda, batch_count)


fn rocblas_daxpy_batched(
    handle: Handle,
    n: Int32,
    alpha: UnsafePointer[Float64],
    x: OpaquePointer,
    incx: Int32,
    y: OpaquePointer,
    incy: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_daxpy_batched",
        fn (
            Handle,
            Int32,
            UnsafePointer[Float64],
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(handle, n, alpha, x, incx, y, incy, batch_count)


fn rocblas_dswap(
    handle: Handle,
    n: Int32,
    x: UnsafePointer[Float64],
    incx: Int32,
    y: UnsafePointer[Float64],
    incy: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_dswap",
        fn (
            Handle,
            Int32,
            UnsafePointer[Float64],
            Int32,
            UnsafePointer[Float64],
            Int32,
        ) -> Status,
    ]()(handle, n, x, incx, y, incy)


fn rocblas_chemm_batched(
    handle: Handle,
    side: Side,
    uplo: Fill,
    m: Int32,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat32],
    _a: OpaquePointer,
    lda: Int32,
    _b: OpaquePointer,
    ldb: Int32,
    beta: UnsafePointer[ComplexFloat32],
    _c: OpaquePointer,
    ldc: Int32,
    batch_count: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 3 API </b>.

    \\details
    hemm_batched performs a batch of the matrix-matrix operations:

        C_i := alpha*A_i*B_i + beta*C_i if side == rocblas_side_left,
        C_i := alpha*B_i*A_i + beta*C_i if side == rocblas_side_right,

        where alpha and beta are scalars, B_i and C_i are m by n matrices, and
        A_i is a Hermitian matrix stored as either upper or lower.

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.

    @param[in]
    side  [rocblas_side]
            - rocblas_side_left:      C_i := alpha*A_i*B_i + beta*C_i
            - rocblas_side_right:     C_i := alpha*B_i*A_i + beta*C_i

    @param[in]
    uplo    [rocblas_fill]
            - rocblas_fill_upper:  A_i is an upper triangular matrix
            - rocblas_fill_lower:  A_i is a  lower triangular matrix

    @param[in]
    m       [rocblas_int]
            m specifies the number of rows of B_i and C_i. m >= 0.

    @param[in]
    n       [rocblas_int]
            n specifies the number of columns of B_i and C_i. n >= 0.

    @param[in]
    alpha
            alpha specifies the scalar alpha. When alpha is
            zero then A_i and B_i are not referenced.

    @param[in]
    A       device array of device pointers storing each matrix A_i on the GPU.
            - A_i is m by m if side == rocblas_side_left
            - A_i is n by n if side == rocblas_side_right
            Only the upper/lower triangular part is accessed.
            The imaginary component of the diagonal elements is not used.

    @param[in]
    lda     [rocblas_int]
            lda specifies the first dimension of A_i.

                if side = rocblas_side_left,  lda >= max( 1, m ),
                otherwise lda >= max( 1, n ).

    @param[in]
    B       device array of device pointers storing each matrix B_i on the GPU.
            Matrix dimension is m by n

    @param[in]
    ldb     [rocblas_int]
            ldb specifies the first dimension of B_i. ldb >= max( 1, m ).

    @param[in]
    beta
            beta specifies the scalar beta. When beta is
            zero then C_i need not be set before entry.

    @param[in]
    C       device array of device pointers storing each matrix C_i on the GPU.
            Matrix dimension is m by n

    @param[in]
    ldc    [rocblas_int]
           ldc specifies the first dimension of C_i. ldc >= max( 1, m ).

    @param[in]
    batch_count [rocblas_int]
                number of instances in the batch.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_chemm_batched",
        fn (
            Handle,
            Side,
            Fill,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat32],
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            UnsafePointer[ComplexFloat32],
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(
        handle,
        side,
        uplo,
        m,
        n,
        alpha,
        _a,
        lda,
        _b,
        ldb,
        beta,
        _c,
        ldc,
        batch_count,
    )


fn rocblas_stpmv_strided_batched_64(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int64,
    _a: UnsafePointer[Float32],
    stride__a: Int64,
    x: UnsafePointer[Float32],
    incx: Int64,
    stride_x: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_stpmv_strided_batched_64",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int64,
            UnsafePointer[Float32],
            Int64,
            UnsafePointer[Float32],
            Int64,
            Int64,
            Int64,
        ) -> Status,
    ]()(
        handle,
        uplo,
        trans_a,
        diag,
        n,
        _a,
        stride__a,
        x,
        incx,
        stride_x,
        batch_count,
    )


fn rocblas_ztrtri_strided_batched(
    handle: Handle,
    uplo: Fill,
    diag: Diagonal,
    n: Int32,
    _a: UnsafePointer[ComplexFloat64],
    lda: Int32,
    stride_a: Int64,
    inv_a: UnsafePointer[ComplexFloat64],
    ldinv_a: Int32,
    stride_inv_a: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_ztrtri_strided_batched",
        fn (
            Handle,
            Fill,
            Diagonal,
            Int32,
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        uplo,
        diag,
        n,
        _a,
        lda,
        stride_a,
        inv_a,
        ldinv_a,
        stride_inv_a,
        batch_count,
    )


fn rocblas_dspr_batched_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    alpha: UnsafePointer[Float64],
    x: OpaquePointer,
    incx: Int64,
    _ap: OpaquePointer,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_dspr_batched_64",
        fn (
            Handle,
            Fill,
            Int64,
            UnsafePointer[Float64],
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
        ) -> Status,
    ]()(handle, uplo, n, alpha, x, incx, _ap, batch_count)


fn rocblas_idamin_64(
    handle: Handle,
    n: Int64,
    x: UnsafePointer[Float64],
    incx: Int64,
    result: UnsafePointer[Int64],
) -> Status:
    return _get_dylib_function[
        "rocblas_idamin_64",
        fn (
            Handle, Int64, UnsafePointer[Float64], Int64, UnsafePointer[Int64]
        ) -> Status,
    ]()(handle, n, x, incx, result)


fn rocblas_scal_ex_64(
    handle: Handle,
    n: Int64,
    alpha: OpaquePointer,
    alpha_type: DataType,
    x: OpaquePointer,
    x_type: DataType,
    incx: Int64,
    execution_type: DataType,
) -> Status:
    return _get_dylib_function[
        "rocblas_scal_ex_64",
        fn (
            Handle,
            Int64,
            OpaquePointer,
            DataType,
            OpaquePointer,
            DataType,
            Int64,
            DataType,
        ) -> Status,
    ]()(handle, n, alpha, alpha_type, x, x_type, incx, execution_type)


fn rocblas_ztbsv_64(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int64,
    k: Int64,
    _a: UnsafePointer[ComplexFloat64],
    lda: Int64,
    x: UnsafePointer[ComplexFloat64],
    incx: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_ztbsv_64",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int64,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int64,
            UnsafePointer[ComplexFloat64],
            Int64,
        ) -> Status,
    ]()(handle, uplo, trans_a, diag, n, k, _a, lda, x, incx)


fn rocblas_axpy_strided_batched_ex(
    handle: Handle,
    n: Int32,
    alpha: OpaquePointer,
    alpha_type: DataType,
    x: OpaquePointer,
    x_type: DataType,
    incx: Int32,
    stridex: Int64,
    y: OpaquePointer,
    y_type: DataType,
    incy: Int32,
    stridey: Int64,
    batch_count: Int32,
    execution_type: DataType,
) -> Status:
    """
    \\brief <b> BLAS EX API </b>.

    \\details
    axpy_strided_batched_ex   computes constant alpha multiplied by vector x, plus vector y over
    a set of strided batched vectors.

        y := alpha * x + y

    Currently supported datatypes are as follows:

    -------------------------------------------------
    | alpha_type | x_type | y_type | execution_type |
    |------------|--------|--------|----------------|
    |  bf16_r    | bf16_r |  bf16_r|      f32_r     |
    |  f32_r     | bf16_r |  bf16_r|      f32_r     |
    |  f16_r     | f16_r  |  f16_r |      f16_r     |
    |  f16_r     | f16_r  |  f16_r |      f32_r     |
    |  f32_r     | f16_r  |  f16_r |      f32_r     |
    |  f32_r     | f32_r  |  f32_r |      f32_r     |
    |  f64_r     | f64_r  |  f64_r |      f64_r     |
    |  f32_c     | f32_c  |  f32_c |      f32_c     |
    |  f64_c     | f64_c  |  f64_c |      f64_c     |
    -------------------------------------------------

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    n         [rocblas_int]
              the number of elements in each x_i and y_i.
    @param[in]
    alpha     device pointer or host pointer to specify the scalar alpha.
    @param[in]
    alpha_type [rocblas_datatype]
              specifies the datatype of alpha.
    @param[in]
    x         device pointer to the first vector x_1.
    @param[in]
    x_type [rocblas_datatype]
           specifies the datatype of each vector x_i.
    @param[in]
    incx      [rocblas_int]
              specifies the increment for the elements of each x_i.
    @param[in]
    stridex   [rocblas_stride]
              stride from the start of one vector (x_i) to the next one (x_i+1).
              There are no restrictions placed on stridex. However, ensure that stridex is of appropriate size. For a typical
              case this means stridex >= n * incx.
    @param[in, out]
    y         device pointer to the first vector y_1.
    @param[in]
    y_type [rocblas_datatype]
          specifies the datatype of each vector y_i.
    @param[in]
    incy      [rocblas_int]
              specifies the increment for the elements of each y_i.
    @param[in]
    stridey   [rocblas_stride]
              stride from the start of one vector (y_i) to the next one (y_i+1).
              There are no restrictions placed on stridey. However, ensure that stridey is of appropriate size. For a typical
              case this means stridey >= n * incy.
    @param[in]
    batch_count [rocblas_int]
                number of instances in the batch.
    @param[in]
    execution_type [rocblas_datatype]
                  specifies the datatype of computation.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_axpy_strided_batched_ex",
        fn (
            Handle,
            Int32,
            OpaquePointer,
            DataType,
            OpaquePointer,
            DataType,
            Int32,
            Int64,
            OpaquePointer,
            DataType,
            Int32,
            Int64,
            Int32,
            DataType,
        ) -> Status,
    ]()(
        handle,
        n,
        alpha,
        alpha_type,
        x,
        x_type,
        incx,
        stridex,
        y,
        y_type,
        incy,
        stridey,
        batch_count,
        execution_type,
    )


fn rocblas_cspr(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat32],
    x: UnsafePointer[ComplexFloat32],
    incx: Int32,
    _ap: UnsafePointer[ComplexFloat32],
) -> Status:
    return _get_dylib_function[
        "rocblas_cspr",
        fn (
            Handle,
            Fill,
            Int32,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int32,
            UnsafePointer[ComplexFloat32],
        ) -> Status,
    ]()(handle, uplo, n, alpha, x, incx, _ap)


fn rocblas_ztrsv_64(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int64,
    _a: UnsafePointer[ComplexFloat64],
    lda: Int64,
    x: UnsafePointer[ComplexFloat64],
    incx: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_ztrsv_64",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int64,
            UnsafePointer[ComplexFloat64],
            Int64,
        ) -> Status,
    ]()(handle, uplo, trans_a, diag, n, _a, lda, x, incx)


fn rocblas_chpmv_strided_batched_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    alpha: UnsafePointer[ComplexFloat32],
    _ap: UnsafePointer[ComplexFloat32],
    stride__a: Int64,
    x: UnsafePointer[ComplexFloat32],
    incx: Int64,
    stride_x: Int64,
    beta: UnsafePointer[ComplexFloat32],
    y: UnsafePointer[ComplexFloat32],
    incy: Int64,
    stride_y: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_chpmv_strided_batched_64",
        fn (
            Handle,
            Fill,
            Int64,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int64,
            UnsafePointer[ComplexFloat32],
            Int64,
            Int64,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int64,
            Int64,
            Int64,
        ) -> Status,
    ]()(
        handle,
        uplo,
        n,
        alpha,
        _ap,
        stride__a,
        x,
        incx,
        stride_x,
        beta,
        y,
        incy,
        stride_y,
        batch_count,
    )


fn rocblas_chpr2_strided_batched(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat32],
    x: UnsafePointer[ComplexFloat32],
    incx: Int32,
    stride_x: Int64,
    y: UnsafePointer[ComplexFloat32],
    incy: Int32,
    stride_y: Int64,
    _ap: UnsafePointer[ComplexFloat32],
    stride__a: Int64,
    batch_count: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 2 API </b>.

    \\details
    hpr2_strided_batched performs the matrix-vector operations:

        A_i := A_i + alpha*x_i*y_i**H + conj(alpha)*y_i*x_i**H
        where alpha is a complex scalar, x_i and y_i are vectors, and A_i is an
        n by n symmetric matrix, supplied in packed form, for i = 1, ..., batch_count.

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    uplo      [rocblas_fill]
            specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
            - rocblas_fill_upper: The upper triangular part of each A_i is supplied in AP.
            - rocblas_fill_lower: The lower triangular part of each A_i is supplied in AP.
    @param[in]
    n         [rocblas_int]
              the number of rows and columns of each matrix A_i. Must be at least 0.
    @param[in]
    alpha
              device pointer or host pointer to scalar alpha.
    @param[in]
    x         device pointer pointing to the first vector (x_1).
    @param[in]
    incx      [rocblas_int]
              specifies the increment for the elements of each x_i.
    @param[in]
    stride_x  [rocblas_stride]
              stride from the start of one vector (x_i) and the next one (x_i+1).
    @param[in]
    y         device pointer pointing to the first vector (y_1).
    @param[in]
    incy      [rocblas_int]
              specifies the increment for the elements of each y_i.
    @param[in]
    stride_y  [rocblas_stride]
              stride from the start of one vector (y_i) and the next one (y_i+1).
    @param[in, out]
    AP        device array of device pointers storing the packed version of the specified triangular portion of
              each Hermitian matrix A_i. Points to the first matrix (A_1).

                    if uplo == rocblas_fill_upper:
                        The upper triangular portion of each Hermitian matrix A_i is supplied.
                        The matrix is compacted so that AP contains the triangular portion
                        column-by-column
                        so that:
                        AP(0) = A(0,0)
                        AP(1) = A(0,1)
                        AP(2) = A(1,1), etc.
                        Ex: (rocblas_fill_upper; n = 3)
                            (1, 0) (2, 1) (4,9)
                            (2,-1) (3, 0) (5,3) ---> [(1,0),(2,1),(3,0),(4,9),(5,3),(6,0)]
                            (4,-9) (5,-3) (6,0)

                    if uplo == rocblas_fill_lower:
                        The lower triangular portion of each Hermitian matrix A_i is supplied.
                        The matrix is compacted so that AP contains the triangular portion
                        column-by-column
                        so that:
                        AP(0) = A(0,0)
                        AP(1) = A(1,0)
                        AP(2) = A(2,1), etc.
                            Ex: (rocblas_fill_lower; n = 3)
                                (1, 0) (2, 1) (4,9)
                                (2,-1) (3, 0) (5,3) ---> [(1,0),(2,-1),(4,-9),(3,0),(5,-3),(6,0)]
                                (4,-9) (5,-3) (6,0)
                    Note that the imaginary part of the diagonal elements are not accessed
                    and are assumed to be 0.
    @param[in]
    stride_A    [rocblas_stride]
                stride from the start of one (A_i) and the next (A_i+1).
    @param[in]
    batch_count [rocblas_int]
                number of instances in the batch.
    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_chpr2_strided_batched",
        fn (
            Handle,
            Fill,
            Int32,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        uplo,
        n,
        alpha,
        x,
        incx,
        stride_x,
        y,
        incy,
        stride_y,
        _ap,
        stride__a,
        batch_count,
    )


fn rocblas_dsbmv_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    k: Int64,
    alpha: UnsafePointer[Float64],
    _a: UnsafePointer[Float64],
    lda: Int64,
    x: UnsafePointer[Float64],
    incx: Int64,
    beta: UnsafePointer[Float64],
    y: UnsafePointer[Float64],
    incy: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_dsbmv_64",
        fn (
            Handle,
            Fill,
            Int64,
            Int64,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int64,
            UnsafePointer[Float64],
            Int64,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int64,
        ) -> Status,
    ]()(handle, uplo, n, k, alpha, _a, lda, x, incx, beta, y, incy)


fn rocblas_dasum_batched_64(
    handle: Handle,
    n: Int64,
    x: OpaquePointer,
    incx: Int64,
    batch_count: Int64,
    results: UnsafePointer[Float64],
) -> Status:
    return _get_dylib_function[
        "rocblas_dasum_batched_64",
        fn (
            Handle,
            Int64,
            OpaquePointer,
            Int64,
            Int64,
            UnsafePointer[Float64],
        ) -> Status,
    ]()(handle, n, x, incx, batch_count, results)


fn rocblas_zscal(
    handle: Handle,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat64],
    x: UnsafePointer[ComplexFloat64],
    incx: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_zscal",
        fn (
            Handle,
            Int32,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int32,
        ) -> Status,
    ]()(handle, n, alpha, x, incx)


fn rocblas_ztpsv(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int32,
    _ap: UnsafePointer[ComplexFloat64],
    x: UnsafePointer[ComplexFloat64],
    incx: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_ztpsv",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int32,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int32,
        ) -> Status,
    ]()(handle, uplo, trans_a, diag, n, _ap, x, incx)


fn rocblas_chpr2_batched(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat32],
    x: OpaquePointer,
    incx: Int32,
    y: OpaquePointer,
    incy: Int32,
    _ap: OpaquePointer,
    batch_count: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 2 API </b>.

    \\details
    hpr2_batched performs the matrix-vector operations:

        A_i := A_i + alpha*x_i*y_i**H + conj(alpha)*y_i*x_i**H
        where alpha is a complex scalar, x_i and y_i are vectors, and A_i is an
        n by n symmetric matrix, supplied in packed form, for i = 1, ..., batch_count.

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    uplo      [rocblas_fill]
            specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
            - rocblas_fill_upper: The upper triangular part of each A_i is supplied in AP.
            - rocblas_fill_lower: The lower triangular part of each A_i is supplied in AP.
    @param[in]
    n         [rocblas_int]
              the number of rows and columns of each matrix A_i. Must be at least 0.
    @param[in]
    alpha
              device pointer or host pointer to scalar alpha.
    @param[in]
    x         device array of device pointers storing each vector x_i.
    @param[in]
    incx      [rocblas_int]
              specifies the increment for the elements of each x_i.
    @param[in]
    y         device array of device pointers storing each vector y_i.
    @param[in]
    incy      [rocblas_int]
              specifies the increment for the elements of each y_i.
    @param[in, out]
    AP        device array of device pointers storing the packed version of the specified triangular portion of
              each Hermitian matrix A_i of at least size ((n * (n + 1)) / 2). Array is of at least size batch_count.

                    if uplo == rocblas_fill_upper:
                        The upper triangular portion of each Hermitian matrix A_i is supplied.
                        The matrix is compacted so that AP contains the triangular portion
                        column-by-column
                        so that:
                        AP(0) = A(0,0)
                        AP(1) = A(0,1)
                        AP(2) = A(1,1), etc.
                        Ex: (rocblas_fill_upper; n = 3)
                            (1, 0) (2, 1) (4,9)
                            (2,-1) (3, 0) (5,3) ---> [(1,0),(2,1),(3,0),(4,9),(5,3),(6,0)]
                            (4,-9) (5,-3) (6,0)

                    if uplo == rocblas_fill_lower:
                        The lower triangular portion of each Hermitian matrix A_i is supplied.
                        The matrix is compacted so that AP contains the triangular portion
                        column-by-column
                        so that:
                        AP(0) = A(0,0)
                        AP(1) = A(1,0)
                        AP(2) = A(2,1), etc.
                        Ex: (rocblas_fill_lower; n = 3)
                            (1, 0) (2, 1) (4,9)
                            (2,-1) (3, 0) (5,3) --> [(1,0),(2,-1),(4,-9),(3,0),(5,-3),(6,0)]
                            (4,-9) (5,-3) (6,0)
                    Note that the imaginary part of the diagonal elements are not accessed
                    and are assumed to be 0.
    @param[in]
    batch_count [rocblas_int]
                number of instances in the batch.
    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_chpr2_batched",
        fn (
            Handle,
            Fill,
            Int32,
            UnsafePointer[ComplexFloat32],
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
        ) -> Status,
    ]()(handle, uplo, n, alpha, x, incx, y, incy, _ap, batch_count)


fn rocblas_csyr2_batched_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    alpha: UnsafePointer[ComplexFloat32],
    x: OpaquePointer,
    incx: Int64,
    y: OpaquePointer,
    incy: Int64,
    _a: OpaquePointer,
    lda: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_csyr2_batched_64",
        fn (
            Handle,
            Fill,
            Int64,
            UnsafePointer[ComplexFloat32],
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, uplo, n, alpha, x, incx, y, incy, _a, lda, batch_count)


fn rocblas_ctrmv_64(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int64,
    _a: UnsafePointer[ComplexFloat32],
    lda: Int64,
    x: UnsafePointer[ComplexFloat32],
    incx: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_ctrmv_64",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int64,
            UnsafePointer[ComplexFloat32],
            Int64,
        ) -> Status,
    ]()(handle, uplo, trans_a, diag, n, _a, lda, x, incx)


fn rocblas_zhbmv_strided_batched_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    k: Int64,
    alpha: UnsafePointer[ComplexFloat64],
    _a: UnsafePointer[ComplexFloat64],
    lda: Int64,
    stride__a: Int64,
    x: UnsafePointer[ComplexFloat64],
    incx: Int64,
    stride_x: Int64,
    beta: UnsafePointer[ComplexFloat64],
    y: UnsafePointer[ComplexFloat64],
    incy: Int64,
    stride_y: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_zhbmv_strided_batched_64",
        fn (
            Handle,
            Fill,
            Int64,
            Int64,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int64,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int64,
            Int64,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int64,
            Int64,
            Int64,
        ) -> Status,
    ]()(
        handle,
        uplo,
        n,
        k,
        alpha,
        _a,
        lda,
        stride__a,
        x,
        incx,
        stride_x,
        beta,
        y,
        incy,
        stride_y,
        batch_count,
    )


fn rocblas_csyr2k(
    handle: Handle,
    uplo: Fill,
    trans: Operation,
    n: Int32,
    k: Int32,
    alpha: UnsafePointer[ComplexFloat32],
    _a: UnsafePointer[ComplexFloat32],
    lda: Int32,
    _b: UnsafePointer[ComplexFloat32],
    ldb: Int32,
    beta: UnsafePointer[ComplexFloat32],
    _c: UnsafePointer[ComplexFloat32],
    ldc: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_csyr2k",
        fn (
            Handle,
            Fill,
            Operation,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int32,
            UnsafePointer[ComplexFloat32],
            Int32,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int32,
        ) -> Status,
    ]()(handle, uplo, trans, n, k, alpha, _a, lda, _b, ldb, beta, _c, ldc)


fn rocblas_izamin_strided_batched_64(
    handle: Handle,
    n: Int64,
    x: UnsafePointer[ComplexFloat64],
    incx: Int64,
    stridex: Int64,
    batch_count: Int64,
    result: UnsafePointer[Int64],
) -> Status:
    return _get_dylib_function[
        "rocblas_izamin_strided_batched_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int64,
            Int64,
            Int64,
            UnsafePointer[Int64],
        ) -> Status,
    ]()(handle, n, x, incx, stridex, batch_count, result)


fn rocblas_ctrsv_strided_batched(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int32,
    _a: UnsafePointer[ComplexFloat32],
    lda: Int32,
    stride__a: Int64,
    x: UnsafePointer[ComplexFloat32],
    incx: Int32,
    stride_x: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_ctrsv_strided_batched",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int32,
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        uplo,
        trans_a,
        diag,
        n,
        _a,
        lda,
        stride__a,
        x,
        incx,
        stride_x,
        batch_count,
    )


fn rocblas_ssyr_batched_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    alpha: UnsafePointer[Float32],
    x: OpaquePointer,
    incx: Int64,
    _a: OpaquePointer,
    lda: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_ssyr_batched_64",
        fn (
            Handle,
            Fill,
            Int64,
            UnsafePointer[Float32],
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, uplo, n, alpha, x, incx, _a, lda, batch_count)


fn rocblas_zsyr2(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat64],
    x: UnsafePointer[ComplexFloat64],
    incx: Int32,
    y: UnsafePointer[ComplexFloat64],
    incy: Int32,
    _a: UnsafePointer[ComplexFloat64],
    lda: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_zsyr2",
        fn (
            Handle,
            Fill,
            Int32,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int32,
            UnsafePointer[ComplexFloat64],
            Int32,
            UnsafePointer[ComplexFloat64],
            Int32,
        ) -> Status,
    ]()(handle, uplo, n, alpha, x, incx, y, incy, _a, lda)


fn rocblas_dtbmv_64(
    handle: Handle,
    uplo: Fill,
    trans: Operation,
    diag: Diagonal,
    n: Int64,
    k: Int64,
    _a: UnsafePointer[Float64],
    lda: Int64,
    x: UnsafePointer[Float64],
    incx: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_dtbmv_64",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int64,
            Int64,
            UnsafePointer[Float64],
            Int64,
            UnsafePointer[Float64],
            Int64,
        ) -> Status,
    ]()(handle, uplo, trans, diag, n, k, _a, lda, x, incx)


fn rocblas_sgbmv(
    handle: Handle,
    trans: Operation,
    m: Int32,
    n: Int32,
    kl: Int32,
    ku: Int32,
    alpha: UnsafePointer[Float32],
    _a: UnsafePointer[Float32],
    lda: Int32,
    x: UnsafePointer[Float32],
    incx: Int32,
    beta: UnsafePointer[Float32],
    y: UnsafePointer[Float32],
    incy: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 2 API </b>.

    \\details
    gbmv performs one of the matrix-vector operations:

        y := alpha*A*x    + beta*y,   or
        y := alpha*A**T*x + beta*y,   or
        y := alpha*A**H*x + beta*y,
        where alpha and beta are scalars, x and y are vectors and A is an
        m by n banded matrix with kl sub-diagonals and ku super-diagonals.

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    trans     [rocblas_operation]
              indicates whether matrix A is transposed (conjugated) or not.
    @param[in]
    m         [rocblas_int]
              number of rows of matrix A.
    @param[in]
    n         [rocblas_int]
              number of columns of matrix A.
    @param[in]
    kl        [rocblas_int]
              number of sub-diagonals of A.
    @param[in]
    ku        [rocblas_int]
              number of super-diagonals of A.
    @param[in]
    alpha     device pointer or host pointer to scalar alpha.
    @param[in]
        A     device pointer storing banded matrix A.
              Leading (kl + ku + 1) by n part of the matrix contains the coefficients
              of the banded matrix. The leading diagonal resides in row (ku + 1) with
              the first super-diagonal above on the RHS of row ku. The first sub-diagonal
              resides below on the LHS of row ku + 2. This propagates up and down across
              sub/super-diagonals.

                    Ex: (m = n = 7; ku = 2, kl = 2)
                    1 2 3 0 0 0 0             0 0 3 3 3 3 3
                    4 1 2 3 0 0 0             0 2 2 2 2 2 2
                    5 4 1 2 3 0 0    ---->    1 1 1 1 1 1 1
                    0 5 4 1 2 3 0             4 4 4 4 4 4 0
                    0 0 5 4 1 2 3             5 5 5 5 5 0 0
                    0 0 0 5 4 1 2             0 0 0 0 0 0 0
                    0 0 0 0 5 4 1             0 0 0 0 0 0 0

              Note that the empty elements which do not correspond to data will not
              be referenced.
    @param[in]
    lda       [rocblas_int]
              specifies the leading dimension of A. Must be >= (kl + ku + 1).
    @param[in]
    x         device pointer storing vector x.
    @param[in]
    incx      [rocblas_int]
              specifies the increment for the elements of x.
    @param[in]
    beta      device pointer or host pointer to scalar beta.
    @param[in, out]
    y         device pointer storing vector y.
    @param[in]
    incy      [rocblas_int]
              specifies the increment for the elements of y.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_sgbmv",
        fn (
            Handle,
            Operation,
            Int32,
            Int32,
            Int32,
            Int32,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int32,
            UnsafePointer[Float32],
            Int32,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int32,
        ) -> Status,
    ]()(handle, trans, m, n, kl, ku, alpha, _a, lda, x, incx, beta, y, incy)


fn rocblas_ctrtri(
    handle: Handle,
    uplo: Fill,
    diag: Diagonal,
    n: Int32,
    _a: UnsafePointer[ComplexFloat32],
    lda: Int32,
    inv_a: UnsafePointer[ComplexFloat32],
    ldinv_a: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_ctrtri",
        fn (
            Handle,
            Fill,
            Diagonal,
            Int32,
            UnsafePointer[ComplexFloat32],
            Int32,
            UnsafePointer[ComplexFloat32],
            Int32,
        ) -> Status,
    ]()(handle, uplo, diag, n, _a, lda, inv_a, ldinv_a)


fn rocblas_scnrm2_batched(
    handle: Handle,
    n: Int32,
    x: OpaquePointer,
    incx: Int32,
    batch_count: Int32,
    results: UnsafePointer[Float32],
) -> Status:
    return _get_dylib_function[
        "rocblas_scnrm2_batched",
        fn (
            Handle,
            Int32,
            OpaquePointer,
            Int32,
            Int32,
            UnsafePointer[Float32],
        ) -> Status,
    ]()(handle, n, x, incx, batch_count, results)


fn rocblas_sgbmv_batched_64(
    handle: Handle,
    trans: Operation,
    m: Int64,
    n: Int64,
    kl: Int64,
    ku: Int64,
    alpha: UnsafePointer[Float32],
    _a: OpaquePointer,
    lda: Int64,
    x: OpaquePointer,
    incx: Int64,
    beta: UnsafePointer[Float32],
    y: OpaquePointer,
    incy: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_sgbmv_batched_64",
        fn (
            Handle,
            Operation,
            Int64,
            Int64,
            Int64,
            Int64,
            UnsafePointer[Float32],
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            UnsafePointer[Float32],
            OpaquePointer,
            Int64,
            Int64,
        ) -> Status,
    ]()(
        handle,
        trans,
        m,
        n,
        kl,
        ku,
        alpha,
        _a,
        lda,
        x,
        incx,
        beta,
        y,
        incy,
        batch_count,
    )


fn rocblas_stbmv_batched_64(
    handle: Handle,
    uplo: Fill,
    trans: Operation,
    diag: Diagonal,
    n: Int64,
    k: Int64,
    _a: OpaquePointer,
    lda: Int64,
    x: OpaquePointer,
    incx: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_stbmv_batched_64",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int64,
            Int64,
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, uplo, trans, diag, n, k, _a, lda, x, incx, batch_count)


fn rocblas_cscal_64(
    handle: Handle,
    n: Int64,
    alpha: UnsafePointer[ComplexFloat32],
    x: UnsafePointer[ComplexFloat32],
    incx: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_cscal_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int64,
        ) -> Status,
    ]()(handle, n, alpha, x, incx)


fn rocblas_cswap_strided_batched(
    handle: Handle,
    n: Int32,
    x: UnsafePointer[ComplexFloat32],
    incx: Int32,
    stridex: Int64,
    y: UnsafePointer[ComplexFloat32],
    incy: Int32,
    stridey: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_cswap_strided_batched",
        fn (
            Handle,
            Int32,
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(handle, n, x, incx, stridex, y, incy, stridey, batch_count)


fn rocblas_cher2_strided_batched_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    alpha: UnsafePointer[ComplexFloat32],
    x: UnsafePointer[ComplexFloat32],
    incx: Int64,
    stride_x: Int64,
    y: UnsafePointer[ComplexFloat32],
    incy: Int64,
    stride_y: Int64,
    _a: UnsafePointer[ComplexFloat32],
    lda: Int64,
    stride__a: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_cher2_strided_batched_64",
        fn (
            Handle,
            Fill,
            Int64,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int64,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int64,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int64,
            Int64,
            Int64,
        ) -> Status,
    ]()(
        handle,
        uplo,
        n,
        alpha,
        x,
        incx,
        stride_x,
        y,
        incy,
        stride_y,
        _a,
        lda,
        stride__a,
        batch_count,
    )


fn rocblas_axpy_batched_ex(
    handle: Handle,
    n: Int32,
    alpha: OpaquePointer,
    alpha_type: DataType,
    x: OpaquePointer,
    x_type: DataType,
    incx: Int32,
    y: OpaquePointer,
    y_type: DataType,
    incy: Int32,
    batch_count: Int32,
    execution_type: DataType,
) -> Status:
    """
    \\brief <b> BLAS EX API </b>.

    \\details
    axpy_batched_ex   computes constant alpha multiplied by vector x, plus vector y over
    a set of batched vectors.

        y := alpha * x + y

    Currently supported datatypes are as follows:

    -------------------------------------------------
    | alpha_type | x_type | y_type | execution_type |
    |------------|--------|--------|----------------|
    |  bf16_r    | bf16_r |  bf16_r|      f32_r     |
    |  f32_r     | bf16_r |  bf16_r|      f32_r     |
    |  f16_r     | f16_r  |  f16_r |      f16_r     |
    |  f16_r     | f16_r  |  f16_r |      f32_r     |
    |  f32_r     | f16_r  |  f16_r |      f32_r     |
    |  f32_r     | f32_r  |  f32_r |      f32_r     |
    |  f64_r     | f64_r  |  f64_r |      f64_r     |
    |  f32_c     | f32_c  |  f32_c |      f32_c     |
    |  f64_c     | f64_c  |  f64_c |      f64_c     |
    -------------------------------------------------

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    n         [rocblas_int]
              the number of elements in each x_i and y_i.
    @param[in]
    alpha     device pointer or host pointer to specify the scalar alpha.
    @param[in]
    alpha_type [rocblas_datatype]
              specifies the datatype of alpha.
    @param[in]
    x         device array of device pointers storing each vector x_i.
    @param[in]
    x_type [rocblas_datatype]
           specifies the datatype of each vector x_i.
    @param[in]
    incx      [rocblas_int]
              specifies the increment for the elements of each x_i.
    @param[in, out]
    y         device array of device pointers storing each vector y_i.
    @param[in]
    y_type [rocblas_datatype]
          specifies the datatype of each vector y_i.
    @param[in]
    incy      [rocblas_int]
              specifies the increment for the elements of each y_i.
    @param[in]
    batch_count [rocblas_int]
                number of instances in the batch.
    @param[in]
    execution_type [rocblas_datatype]
                  specifies the datatype of computation.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_axpy_batched_ex",
        fn (
            Handle,
            Int32,
            OpaquePointer,
            DataType,
            OpaquePointer,
            DataType,
            Int32,
            OpaquePointer,
            DataType,
            Int32,
            Int32,
            DataType,
        ) -> Status,
    ]()(
        handle,
        n,
        alpha,
        alpha_type,
        x,
        x_type,
        incx,
        y,
        y_type,
        incy,
        batch_count,
        execution_type,
    )


fn rocblas_ztrmv_strided_batched_64(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int64,
    _a: UnsafePointer[ComplexFloat64],
    lda: Int64,
    stride__a: Int64,
    x: UnsafePointer[ComplexFloat64],
    incx: Int64,
    stride_x: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_ztrmv_strided_batched_64",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int64,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int64,
            Int64,
            Int64,
        ) -> Status,
    ]()(
        handle,
        uplo,
        trans_a,
        diag,
        n,
        _a,
        lda,
        stride__a,
        x,
        incx,
        stride_x,
        batch_count,
    )


fn rocblas_ztpmv_batched(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int32,
    _a: UnsafePointer[UnsafePointer[ComplexFloat64]],
    x: UnsafePointer[UnsafePointer[ComplexFloat64]],
    incx: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_ztpmv_batched",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int32,
            UnsafePointer[UnsafePointer[ComplexFloat64]],
            UnsafePointer[UnsafePointer[ComplexFloat64]],
            Int32,
            Int32,
        ) -> Status,
    ]()(handle, uplo, trans_a, diag, n, _a, x, incx, batch_count)


fn rocblas_dspmv_batched(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    alpha: UnsafePointer[Float64],
    _a: OpaquePointer,
    x: OpaquePointer,
    incx: Int32,
    beta: UnsafePointer[Float64],
    y: OpaquePointer,
    incy: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_dspmv_batched",
        fn (
            Handle,
            Fill,
            Int32,
            UnsafePointer[Float64],
            OpaquePointer,
            OpaquePointer,
            Int32,
            UnsafePointer[Float64],
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(handle, uplo, n, alpha, _a, x, incx, beta, y, incy, batch_count)


fn rocblas_strmm(
    handle: Handle,
    side: Side,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    m: Int32,
    n: Int32,
    alpha: UnsafePointer[Float32],
    _a: UnsafePointer[Float32],
    lda: Int32,
    _b: UnsafePointer[Float32],
    ldb: Int32,
    _c: UnsafePointer[Float32],
    ldc: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 3 API </b>.

    \\details
    trmm performs one of the matrix-matrix operations:

        C := alpha*op( A )*B,   or
        C := alpha*B*op( A ),

    The Legacy BLAS in-place trmm functionality,

        B := alpha*op( A )*B,   or
        B := alpha*B*op( A ),

    is available by setting pointer C equal to pointer B, and ldc equal to ldb.

        alpha  is a scalar,  B  is an m by n matrix, C  is an m by n matrix,  A  is a unit, or
        non-unit,  upper or lower triangular matrix  and  op( A )  is one  of

        op( A ) = A     or
        op( A ) = A^T   or
        op( A ) = A^H.

        When uplo == rocblas_fill_upper the  leading  k by k
        upper triangular part of the array  A must contain the upper
        triangular matrix and the strictly lower triangular part of
        A is not referenced. Here k is m when side == rocblas_side_left
        and is n when side == rocblas_side_right.

        When uplo == rocblas_fill_lower the  leading  k by k
        lower triangular part of the array  A must contain the lower
        triangular matrix  and the strictly upper triangular part of
        A is not referenced. Here k is m when  side == rocblas_side_left
        and is n when side == rocblas_side_right.

        Note that when  diag == rocblas_diagonal_unit  the diagonal elements of
        A  are not referenced either,  but are assumed to be  unity.

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.

    @param[in]
    side    [rocblas_side]
            Specifies whether op(A) multiplies B from the left or right as follows:
            - rocblas_side_left:       C := alpha*op( A )*B
            - rocblas_side_right:      C := alpha*B*op( A )

    @param[in]
    uplo    [rocblas_fill]
            Specifies whether the matrix A is an upper or lower triangular matrix as follows:
            - rocblas_fill_upper:  A is an upper triangular matrix.
            - rocblas_fill_lower:  A is a  lower triangular matrix.

    @param[in]
    transA  [rocblas_operation]
            Specifies the form of op(A) to be used in the matrix multiplication as follows:
            - rocblas_operation_none:    op(A) = A
            - rocblas_operation_transpose:      op(A) = A^T
            - rocblas_operation_conjugate_transpose:  op(A) = A^H

    @param[in]
    diag    [rocblas_diagonal]
            Specifies whether or not A is unit triangular as follows:
            - rocblas_diagonal_unit:      A is assumed to be unit triangular.
            - rocblas_diagonal_non_unit:  A is not assumed to be unit triangular.

    @param[in]
    m       [rocblas_int]
            m specifies the number of rows of B. m >= 0.

    @param[in]
    n       [rocblas_int]
            n specifies the number of columns of B. n >= 0.

    @param[in]
    alpha
            alpha specifies the scalar alpha. When alpha is
            zero then A is not referenced and B need not be set before
            entry.

    @param[in]
    A       Device pointer to matrix A on the GPU.
            A has dimension ( lda, k ), where k is m
            when  side == rocblas_side_left  and
            is  n  when  side == rocblas_side_right.

                When uplo == rocblas_fill_upper the  leading  k by k
                upper triangular part of the array  A must contain the upper
                triangular matrix  and the strictly lower triangular part of
                A is not referenced.

                When uplo == rocblas_fill_lower the  leading  k by k
                lower triangular part of the array  A must contain the lower
                triangular matrix  and the strictly upper triangular part of
                A is not referenced.

        Note that when  diag == rocblas_diagonal_unit  the diagonal elements of
        A  are not referenced either,  but are assumed to be  unity.

    @param[in]
    lda     [rocblas_int]
            lda specifies the first dimension of A.

                if side == rocblas_side_left,  lda >= max( 1, m ),
                if side == rocblas_side_right, lda >= max( 1, n ).

    @param[in]
    B       Device pointer to the matrix B on the GPU.

    @param[in]
    ldb    [rocblas_int]
           ldb specifies the first dimension of B. ldb >= max( 1, m ).

    @param[out]
    C      Device pointer to the matrix C on the GPU.

    @param[in]
    ldc   [rocblas_int]
          ldc specifies the first dimension of C. ldc >= max( 1, m).
          If B and C are pointers to the same matrix then ldc must equal ldb or
          rocblas_status_invalid_value will be returned.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_strmm",
        fn (
            Handle,
            Side,
            Fill,
            Operation,
            Diagonal,
            Int32,
            Int32,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int32,
            UnsafePointer[Float32],
            Int32,
            UnsafePointer[Float32],
            Int32,
        ) -> Status,
    ]()(
        handle,
        side,
        uplo,
        trans_a,
        diag,
        m,
        n,
        alpha,
        _a,
        lda,
        _b,
        ldb,
        _c,
        ldc,
    )


fn rocblas_isamin_batched_64(
    handle: Handle,
    n: Int64,
    x: OpaquePointer,
    incx: Int64,
    batch_count: Int64,
    result: UnsafePointer[Int64],
) -> Status:
    return _get_dylib_function[
        "rocblas_isamin_batched_64",
        fn (
            Handle,
            Int64,
            OpaquePointer,
            Int64,
            Int64,
            UnsafePointer[Int64],
        ) -> Status,
    ]()(handle, n, x, incx, batch_count, result)


fn rocblas_hshgemv_batched(
    handle: Handle,
    trans: Operation,
    m: Int32,
    n: Int32,
    alpha: UnsafePointer[Float32],
    _a: OpaquePointer,
    lda: Int32,
    x: OpaquePointer,
    incx: Int32,
    beta: UnsafePointer[Float32],
    y: OpaquePointer,
    incy: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_hshgemv_batched",
        fn (
            Handle,
            Operation,
            Int32,
            Int32,
            UnsafePointer[Float32],
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            UnsafePointer[Float32],
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(
        handle, trans, m, n, alpha, _a, lda, x, incx, beta, y, incy, batch_count
    )


fn rocblas_scasum_64(
    handle: Handle,
    n: Int64,
    x: UnsafePointer[ComplexFloat32],
    incx: Int64,
    result: UnsafePointer[Float32],
) -> Status:
    return _get_dylib_function[
        "rocblas_scasum_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int64,
            UnsafePointer[Float32],
        ) -> Status,
    ]()(handle, n, x, incx, result)


fn rocblas_dsyrk_batched(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    n: Int32,
    k: Int32,
    alpha: UnsafePointer[Float64],
    _a: OpaquePointer,
    lda: Int32,
    beta: UnsafePointer[Float64],
    _c: OpaquePointer,
    ldc: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_dsyrk_batched",
        fn (
            Handle,
            Fill,
            Operation,
            Int32,
            Int32,
            UnsafePointer[Float64],
            OpaquePointer,
            Int32,
            UnsafePointer[Float64],
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(handle, uplo, trans_a, n, k, alpha, _a, lda, beta, _c, ldc, batch_count)


fn rocblas_ssyrk_strided_batched(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    n: Int32,
    k: Int32,
    alpha: UnsafePointer[Float32],
    _a: UnsafePointer[Float32],
    lda: Int32,
    stride__a: Int64,
    beta: UnsafePointer[Float32],
    _c: UnsafePointer[Float32],
    ldc: Int32,
    stride__c: Int64,
    batch_count: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 3 API </b>.

    \\details
    syrk_strided_batched performs a batch of the matrix-matrix operations for a symmetric rank-k update:

        C_i := alpha*op( A_i )*op( A_i )^T + beta*C_i,

        where  alpha and beta are scalars, op(A_i) is an n by k matrix, and
        C_i is a symmetric n x n matrix stored as either upper or lower.

        op( A_i ) = A_i, and A_i is n by k if transA == rocblas_operation_none
        op( A_i ) = A_i^T and A_i is k by n if transA == rocblas_operation_transpose

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.

    @param[in]
    uplo    [rocblas_fill]
            - rocblas_fill_upper:  C_i is an upper triangular matrix
            - rocblas_fill_lower:  C_i is a  lower triangular matrix

    @param[in]
    transA  [rocblas_operation]
            - rocblas_operation_transpose:           op(A) = A^T
            - rocblas_operation_none:                op(A) = A
            - rocblas_operation_conjugate_transpose: op(A) = A^T

            rocblas_operation_conjugate_transpose is not supported for complex types. See cherk
            and zherk.

    @param[in]
    n       [rocblas_int]
            n specifies the number of rows and columns of C_i. n >= 0.

    @param[in]
    k       [rocblas_int]
            k specifies the number of columns of op(A). k >= 0.

    @param[in]
    alpha
            alpha specifies the scalar alpha. When alpha is
            zero then A is not referenced and A need not be set before
            entry.

    @param[in]
    A       Device pointer to the first matrix A_1 on the GPU of dimension (lda, k)
            when transA is rocblas_operation_none, otherwise of dimension (lda, n).

    @param[in]
    lda     [rocblas_int]
            lda specifies the first dimension of A_i.

                if transA = rocblas_operation_none,  lda >= max( 1, n ),
                otherwise lda >= max( 1, k ).

    @param[in]
    stride_A  [rocblas_stride]
              stride from the start of one matrix (A_i) and the next one (A_i+1).

    @param[in]
    beta
            beta specifies the scalar beta. When beta is
            zero then C need not be set before entry.

    @param[in]
    C       Device pointer to the first matrix C_1 on the GPU. on the GPU.
            only the upper/lower triangular part of each C_i is accessed.

    @param[in]
    ldc    [rocblas_int]
           ldc specifies the first dimension of C. ldc >= max( 1, n ).

    @param[in, out]
    stride_C  [rocblas_stride]
              stride from the start of one matrix (C_i) and the next one (C_i+1)

    @param[in]
    batch_count [rocblas_int]
                number of instances in the batch.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_ssyrk_strided_batched",
        fn (
            Handle,
            Fill,
            Operation,
            Int32,
            Int32,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int32,
            Int64,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        uplo,
        trans_a,
        n,
        k,
        alpha,
        _a,
        lda,
        stride__a,
        beta,
        _c,
        ldc,
        stride__c,
        batch_count,
    )


fn rocblas_dscal_strided_batched_64(
    handle: Handle,
    n: Int64,
    alpha: UnsafePointer[Float64],
    x: UnsafePointer[Float64],
    incx: Int64,
    stride_x: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_dscal_strided_batched_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int64,
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, n, alpha, x, incx, stride_x, batch_count)


fn rocblas_dsymv_strided_batched_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    alpha: UnsafePointer[Float64],
    _a: UnsafePointer[Float64],
    lda: Int64,
    stride_a: Int64,
    x: UnsafePointer[Float64],
    incx: Int64,
    stridex: Int64,
    beta: UnsafePointer[Float64],
    y: UnsafePointer[Float64],
    incy: Int64,
    stridey: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_dsymv_strided_batched_64",
        fn (
            Handle,
            Fill,
            Int64,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int64,
            Int64,
            UnsafePointer[Float64],
            Int64,
            Int64,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int64,
            Int64,
            Int64,
        ) -> Status,
    ]()(
        handle,
        uplo,
        n,
        alpha,
        _a,
        lda,
        stride_a,
        x,
        incx,
        stridex,
        beta,
        y,
        incy,
        stridey,
        batch_count,
    )


fn rocblas_dgemv_batched(
    handle: Handle,
    trans: Operation,
    m: Int32,
    n: Int32,
    alpha: UnsafePointer[Float64],
    _a: OpaquePointer,
    lda: Int32,
    x: OpaquePointer,
    incx: Int32,
    beta: UnsafePointer[Float64],
    y: OpaquePointer,
    incy: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_dgemv_batched",
        fn (
            Handle,
            Operation,
            Int32,
            Int32,
            UnsafePointer[Float64],
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            UnsafePointer[Float64],
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(
        handle, trans, m, n, alpha, _a, lda, x, incx, beta, y, incy, batch_count
    )


fn rocblas_crotg_strided_batched(
    handle: Handle,
    a: UnsafePointer[ComplexFloat32],
    stride_a: Int64,
    b: UnsafePointer[ComplexFloat32],
    stride_b: Int64,
    c: UnsafePointer[Float32],
    stride_c: Int64,
    s: UnsafePointer[ComplexFloat32],
    stride_s: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_crotg_strided_batched",
        fn (
            Handle,
            UnsafePointer[ComplexFloat32],
            Int64,
            UnsafePointer[ComplexFloat32],
            Int64,
            UnsafePointer[Float32],
            Int64,
            UnsafePointer[ComplexFloat32],
            Int64,
            Int32,
        ) -> Status,
    ]()(handle, a, stride_a, b, stride_b, c, stride_c, s, stride_s, batch_count)


fn rocblas_trsm_batched_ex(
    handle: Handle,
    side: Side,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    m: Int32,
    n: Int32,
    alpha: OpaquePointer,
    _a: OpaquePointer,
    lda: Int32,
    _b: OpaquePointer,
    ldb: Int32,
    batch_count: Int32,
    inv_a: OpaquePointer,
    inv_a_size: Int32,
    compute_type: DataType,
) -> Status:
    """
    \\brief <b> BLAS EX API </b>.

    \\details
    trsm_batched_ex solves:

        op(A_i)*X_i = alpha*B_i or X_i*op(A_i) = alpha*B_i,

    for i = 1, ..., batch_count; and where alpha is a scalar, X and B are arrays of m by n matrices,
    A is an array of triangular matrix and each op(A_i) is one of

        op( A_i ) = A_i   or   op( A_i ) = A_i^T   or   op( A_i ) = A_i^H.

    Each matrix X_i is overwritten on B_i.

    This function gives the user the ability to reuse the invA matrix between runs.
    If invA == NULL, rocblas_trsm_batched_ex will automatically calculate each invA_i on every run.

    Setting up invA:
    Each accepted invA_i matrix consists of the packed 128x128 inverses of the diagonal blocks of
    matrix A_i, followed by any smaller diagonal block that remains.
    To set up each invA_i it is recommended that rocblas_trtri_batched be used with matrix A_i as the input.
    invA is an array of pointers of batch_count length holding each invA_i.

    Device memory of size 128 x k should be allocated for each invA_i ahead of time, where k is m when
    rocblas_side_left and is n when rocblas_side_right. The actual number of elements in each invA_i
    should be passed as invA_size.

    To begin, rocblas_trtri_batched must be called on the full 128x128-sized diagonal blocks of each
    matrix A_i. Below are the restricted parameters:
      - n = 128
      - ldinvA = 128
      - stride_invA = 128x128
      - batch_count = k / 128,

    Then any remaining block may be added:
      - n = k % 128
      - invA = invA + stride_invA * previous_batch_count
      - ldinvA = 128
      - batch_count = 1

    @param[in]
    handle  [rocblas_handle]
            handle to the rocblas library context queue.

    @param[in]
    side    [rocblas_side]
            - rocblas_side_left:       op(A)*X = alpha*B
            - rocblas_side_right:      X*op(A) = alpha*B

    @param[in]
    uplo    [rocblas_fill]
            - rocblas_fill_upper:  each A_i is an upper triangular matrix.
            - rocblas_fill_lower:  each A_i is a lower triangular matrix.

    @param[in]
    transA  [rocblas_operation]
            - transB:    op(A) = A.
            - rocblas_operation_transpose:      op(A) = A^T
            - rocblas_operation_conjugate_transpose:  op(A) = A^H

    @param[in]
    diag    [rocblas_diagonal]
            - rocblas_diagonal_unit:     each A_i is assumed to be unit triangular.
            - rocblas_diagonal_non_unit:  each A_i is not assumed to be unit triangular.

    @param[in]
    m       [rocblas_int]
            m specifies the number of rows of each B_i. m >= 0.

    @param[in]
    n       [rocblas_int]
            n specifies the number of columns of each B_i. n >= 0.

    @param[in]
    alpha   [void *]
            device pointer or host pointer alpha specifying the scalar alpha. When alpha is
            &zero then A is not referenced, and B need not be set before
            entry.

    @param[in]
    A       [void *]
            device array of device pointers storing each matrix A_i.
            each A_i is of dimension ( lda, k ), where k is m
            when rocblas_side_left and
            is n when rocblas_side_right
            only the upper/lower triangular part is accessed.

    @param[in]
    lda     [rocblas_int]
            lda specifies the first dimension of each A_i.

                if side = rocblas_side_left,  lda >= max( 1, m ),
                if side = rocblas_side_right, lda >= max( 1, n ).

    @param[in, out]
    B       [void *]
            device array of device pointers storing each matrix B_i.
            each B_i is of dimension ( ldb, n ).
            Before entry, the leading m by n part of the array B_i must
            contain the right-hand side matrix B_i, and on exit is
            overwritten by the solution matrix X_i

    @param[in]
    ldb    [rocblas_int]
           ldb specifies the first dimension of each B_i. ldb >= max( 1, m ).

    @param[in]
    batch_count [rocblas_int]
            specifies how many batches.

    @param[in]
    invA    [void *]
            device array of device pointers storing the inverse diagonal blocks of each A_i.
            each invA_i is of dimension ( ld_invA, k ), where k is m
            when rocblas_side_left and
            is n when rocblas_side_right.
            ld_invA must be equal to 128.

    @param[in]
    invA_size [rocblas_int]
            invA_size specifies the number of elements of device memory in each invA_i.

    @param[in]
    compute_type [rocblas_datatype]
            specifies the datatype of computation.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_trsm_batched_ex",
        fn (
            Handle,
            Side,
            Fill,
            Operation,
            Diagonal,
            Int32,
            Int32,
            OpaquePointer,
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            Int32,
            OpaquePointer,
            Int32,
            DataType,
        ) -> Status,
    ]()(
        handle,
        side,
        uplo,
        trans_a,
        diag,
        m,
        n,
        alpha,
        _a,
        lda,
        _b,
        ldb,
        batch_count,
        inv_a,
        inv_a_size,
        compute_type,
    )


fn rocblas_dswap_strided_batched_64(
    handle: Handle,
    n: Int64,
    x: UnsafePointer[Float64],
    incx: Int64,
    stridex: Int64,
    y: UnsafePointer[Float64],
    incy: Int64,
    stridey: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_dswap_strided_batched_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[Float64],
            Int64,
            Int64,
            UnsafePointer[Float64],
            Int64,
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, n, x, incx, stridex, y, incy, stridey, batch_count)


fn rocblas_zrot_64(
    handle: Handle,
    n: Int64,
    x: UnsafePointer[ComplexFloat64],
    incx: Int64,
    y: UnsafePointer[ComplexFloat64],
    incy: Int64,
    c: UnsafePointer[Float64],
    s: UnsafePointer[ComplexFloat64],
) -> Status:
    return _get_dylib_function[
        "rocblas_zrot_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int64,
            UnsafePointer[ComplexFloat64],
            Int64,
            UnsafePointer[Float64],
            UnsafePointer[ComplexFloat64],
        ) -> Status,
    ]()(handle, n, x, incx, y, incy, c, s)


fn rocblas_scnrm2(
    handle: Handle,
    n: Int32,
    x: UnsafePointer[ComplexFloat32],
    incx: Int32,
    result: UnsafePointer[Float32],
) -> Status:
    return _get_dylib_function[
        "rocblas_scnrm2",
        fn (
            Handle,
            Int32,
            UnsafePointer[ComplexFloat32],
            Int32,
            UnsafePointer[Float32],
        ) -> Status,
    ]()(handle, n, x, incx, result)


fn rocblas_zdotc_batched(
    handle: Handle,
    n: Int32,
    x: OpaquePointer,
    incx: Int32,
    y: OpaquePointer,
    incy: Int32,
    batch_count: Int32,
    result: UnsafePointer[ComplexFloat64],
) -> Status:
    return _get_dylib_function[
        "rocblas_zdotc_batched",
        fn (
            Handle,
            Int32,
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat64],
        ) -> Status,
    ]()(handle, n, x, incx, y, incy, batch_count, result)


fn rocblas_csscal_64(
    handle: Handle,
    n: Int64,
    alpha: UnsafePointer[Float32],
    x: UnsafePointer[ComplexFloat32],
    incx: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_csscal_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[Float32],
            UnsafePointer[ComplexFloat32],
            Int64,
        ) -> Status,
    ]()(handle, n, alpha, x, incx)


fn rocblas_sswap(
    handle: Handle,
    n: Int32,
    x: UnsafePointer[Float32],
    incx: Int32,
    y: UnsafePointer[Float32],
    incy: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 1 API </b>.

    \\details
    swap  interchanges vectors x and y:

        y := x;
        x := y

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    n         [rocblas_int]
              the number of elements in x and y.
    @param[in, out]
    x         device pointer storing vector x.
    @param[in]
    incx      [rocblas_int]
              specifies the increment for the elements of x.
    @param[in, out]
    y         device pointer storing vector y.
    @param[in]
    incy      [rocblas_int]
              specifies the increment for the elements of y.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_sswap",
        fn (
            Handle,
            Int32,
            UnsafePointer[Float32],
            Int32,
            UnsafePointer[Float32],
            Int32,
        ) -> Status,
    ]()(handle, n, x, incx, y, incy)


fn rocblas_dtpsv_64(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int64,
    _ap: UnsafePointer[Float64],
    x: UnsafePointer[Float64],
    incx: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_dtpsv_64",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int64,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int64,
        ) -> Status,
    ]()(handle, uplo, trans_a, diag, n, _ap, x, incx)


fn rocblas_icamax_64(
    handle: Handle,
    n: Int64,
    x: UnsafePointer[ComplexFloat32],
    incx: Int64,
    result: UnsafePointer[Int64],
) -> Status:
    return _get_dylib_function[
        "rocblas_icamax_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int64,
            UnsafePointer[Int64],
        ) -> Status,
    ]()(handle, n, x, incx, result)


fn rocblas_sgemv_batched_64(
    handle: Handle,
    trans: Operation,
    m: Int64,
    n: Int64,
    alpha: UnsafePointer[Float32],
    _a: OpaquePointer,
    lda: Int64,
    x: OpaquePointer,
    incx: Int64,
    beta: UnsafePointer[Float32],
    y: OpaquePointer,
    incy: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_sgemv_batched_64",
        fn (
            Handle,
            Operation,
            Int64,
            Int64,
            UnsafePointer[Float32],
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            UnsafePointer[Float32],
            OpaquePointer,
            Int64,
            Int64,
        ) -> Status,
    ]()(
        handle, trans, m, n, alpha, _a, lda, x, incx, beta, y, incy, batch_count
    )


fn rocblas_sdot_strided_batched(
    handle: Handle,
    n: Int32,
    x: UnsafePointer[Float32],
    incx: Int32,
    stridex: Int64,
    y: UnsafePointer[Float32],
    incy: Int32,
    stridey: Int64,
    batch_count: Int32,
    result: UnsafePointer[Float32],
) -> Status:
    """
    \\brief <b> BLAS Level 1 API </b>.

    \\details
    dot_strided_batched(u)  performs a batch of dot products of vectors x and y:

        result_i = x_i * y_i;

    dotc_strided_batched  performs a batch of dot products of the conjugate of complex vector x and complex vector y

        result_i = conjugate (x_i) * y_i;
        where (x_i, y_i) is the i-th instance of the batch.
        x_i and y_i are vectors, for i = 1, ..., batch_count.

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    n         [rocblas_int]
              the number of elements in each x_i and y_i.
    @param[in]
    x         device pointer to the first vector (x_1) in the batch.
    @param[in]
    incx      [rocblas_int]
              specifies the increment for the elements of each x_i.
    @param[in]
    stridex     [rocblas_stride]
                stride from the start of one vector (x_i) and the next one (x_i+1).
    @param[in]
    y         device pointer to the first vector (y_1) in the batch.
    @param[in]
    incy      [rocblas_int]
              specifies the increment for the elements of each y_i.
    @param[in]
    stridey     [rocblas_stride]
                stride from the start of one vector (y_i) and the next one (y_i+1).
    @param[in]
    batch_count [rocblas_int]
                number of instances in the batch.
    @param[in, out]
    result
              device array or host array of batch_count size to store the dot products of each batch.
              return 0.0 for each element if n <= 0.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_sdot_strided_batched",
        fn (
            Handle,
            Int32,
            UnsafePointer[Float32],
            Int32,
            Int64,
            UnsafePointer[Float32],
            Int32,
            Int64,
            Int32,
            UnsafePointer[Float32],
        ) -> Status,
    ]()(handle, n, x, incx, stridex, y, incy, stridey, batch_count, result)


fn rocblas_dgbmv(
    handle: Handle,
    trans: Operation,
    m: Int32,
    n: Int32,
    kl: Int32,
    ku: Int32,
    alpha: UnsafePointer[Float64],
    _a: UnsafePointer[Float64],
    lda: Int32,
    x: UnsafePointer[Float64],
    incx: Int32,
    beta: UnsafePointer[Float64],
    y: UnsafePointer[Float64],
    incy: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_dgbmv",
        fn (
            Handle,
            Operation,
            Int32,
            Int32,
            Int32,
            Int32,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int32,
            UnsafePointer[Float64],
            Int32,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int32,
        ) -> Status,
    ]()(handle, trans, m, n, kl, ku, alpha, _a, lda, x, incx, beta, y, incy)


fn rocblas_stpmv_strided_batched(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int32,
    _a: UnsafePointer[Float32],
    stride__a: Int64,
    x: UnsafePointer[Float32],
    incx: Int32,
    stride_x: Int64,
    batch_count: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 2 API </b>.

    \\details
    tpmv_strided_batched performs one of the matrix-vector operations:

        x_i = A_i*x_i or
        x_i = A_i**T*x_i or
        x_i = A_i**H*x_i, 0 < i < batch_count
        where x_i is an n element vector and A_i is an n by n (unit, or non-unit, upper or lower triangular matrix)
        with strides specifying how to retrieve $x_i$ (resp. $A_i$) from $x_{i-1}$ (resp. $A_i$).
        The vectors x_i are overwritten.

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.

    @param[in]
    uplo    [rocblas_fill]
            - rocblas_fill_upper:  A_i is an upper triangular matrix.
            - rocblas_fill_lower:  A_i is a  lower triangular matrix.

    @param[in]
    transA     [rocblas_operation]
            - rocblas_operation_none:    op(A) = A.
            - rocblas_operation_transpose:   op(A) = A^T
            - rocblas_operation_conjugate_transpose:  op(A) = A^H

    @param[in]
    diag    [rocblas_diagonal]
            - rocblas_diagonal_unit:     A_i is assumed to be unit triangular.
            - rocblas_diagonal_non_unit:  A_i is not assumed to be unit triangular.

    @param[in]
    n         [rocblas_int]
            n specifies the number of rows of matrices A_i. n >= 0.

    @param[in]
    A       device pointer to the matrix A_1 of the batch, of dimension ( lda, n ). If uplo == rocblas_fill_upper, the upper triangular part of the leading n-by-n array contains the matrix A_i, otherwise the lower triangular part of the leading n-by-n array contains the matrix A_i.

    @param[in]
    stride_A  [rocblas_stride]
            stride from the start of one A_i matrix to the next A_{i + 1}.

    @param[in, out]
    x       device pointer to the vector x_1 of the batch. On exit, each x_i is overwritten with the transformed vector x_i.

    @param[in]
    incx      [rocblas_int]
            specifies the increment for the elements of one vector x.

    @param[in]
    stride_x  [rocblas_stride]
            stride from the start of one x_i vector to the next x_{i + 1}.

    @param[in]
    batch_count [rocblas_int]
            The number of batched matrices/vectors.


    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_stpmv_strided_batched",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int32,
            UnsafePointer[Float32],
            Int64,
            UnsafePointer[Float32],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        uplo,
        trans_a,
        diag,
        n,
        _a,
        stride__a,
        x,
        incx,
        stride_x,
        batch_count,
    )


fn rocblas_dsymv_strided_batched(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    alpha: UnsafePointer[Float64],
    _a: UnsafePointer[Float64],
    lda: Int32,
    stride_a: Int64,
    x: UnsafePointer[Float64],
    incx: Int32,
    stridex: Int64,
    beta: UnsafePointer[Float64],
    y: UnsafePointer[Float64],
    incy: Int32,
    stridey: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_dsymv_strided_batched",
        fn (
            Handle,
            Fill,
            Int32,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int32,
            Int64,
            UnsafePointer[Float64],
            Int32,
            Int64,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        uplo,
        n,
        alpha,
        _a,
        lda,
        stride_a,
        x,
        incx,
        stridex,
        beta,
        y,
        incy,
        stridey,
        batch_count,
    )


fn rocblas_dotc_batched_ex_64(
    handle: Handle,
    n: Int64,
    x: OpaquePointer,
    x_type: DataType,
    incx: Int64,
    y: OpaquePointer,
    y_type: DataType,
    incy: Int64,
    batch_count: Int64,
    result: OpaquePointer,
    result_type: DataType,
    execution_type: DataType,
) -> Status:
    return _get_dylib_function[
        "rocblas_dotc_batched_ex_64",
        fn (
            Handle,
            Int64,
            OpaquePointer,
            DataType,
            Int64,
            OpaquePointer,
            DataType,
            Int64,
            Int64,
            OpaquePointer,
            DataType,
            DataType,
        ) -> Status,
    ]()(
        handle,
        n,
        x,
        x_type,
        incx,
        y,
        y_type,
        incy,
        batch_count,
        result,
        result_type,
        execution_type,
    )


fn rocblas_cdgmm(
    handle: Handle,
    side: Side,
    m: Int32,
    n: Int32,
    _a: UnsafePointer[ComplexFloat32],
    lda: Int32,
    x: UnsafePointer[ComplexFloat32],
    incx: Int32,
    _c: UnsafePointer[ComplexFloat32],
    ldc: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_cdgmm",
        fn (
            Handle,
            Side,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat32],
            Int32,
            UnsafePointer[ComplexFloat32],
            Int32,
            UnsafePointer[ComplexFloat32],
            Int32,
        ) -> Status,
    ]()(handle, side, m, n, _a, lda, x, incx, _c, ldc)


fn rocblas_haxpy_batched_64(
    handle: Handle,
    n: Int64,
    alpha: UnsafePointer[Float16],
    x: OpaquePointer,
    incx: Int64,
    y: OpaquePointer,
    incy: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_haxpy_batched_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[Float16],
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, n, alpha, x, incx, y, incy, batch_count)


fn rocblas_dgbmv_strided_batched_64(
    handle: Handle,
    trans: Operation,
    m: Int64,
    n: Int64,
    kl: Int64,
    ku: Int64,
    alpha: UnsafePointer[Float64],
    _a: UnsafePointer[Float64],
    lda: Int64,
    stride__a: Int64,
    x: UnsafePointer[Float64],
    incx: Int64,
    stride_x: Int64,
    beta: UnsafePointer[Float64],
    y: UnsafePointer[Float64],
    incy: Int64,
    stride_y: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_dgbmv_strided_batched_64",
        fn (
            Handle,
            Operation,
            Int64,
            Int64,
            Int64,
            Int64,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int64,
            Int64,
            UnsafePointer[Float64],
            Int64,
            Int64,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int64,
            Int64,
            Int64,
        ) -> Status,
    ]()(
        handle,
        trans,
        m,
        n,
        kl,
        ku,
        alpha,
        _a,
        lda,
        stride__a,
        x,
        incx,
        stride_x,
        beta,
        y,
        incy,
        stride_y,
        batch_count,
    )


fn rocblas_zsyr_batched_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    alpha: UnsafePointer[ComplexFloat64],
    x: OpaquePointer,
    incx: Int64,
    _a: OpaquePointer,
    lda: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_zsyr_batched_64",
        fn (
            Handle,
            Fill,
            Int64,
            UnsafePointer[ComplexFloat64],
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, uplo, n, alpha, x, incx, _a, lda, batch_count)


fn rocblas_sdot_64(
    handle: Handle,
    n: Int64,
    x: UnsafePointer[Float32],
    incx: Int64,
    y: UnsafePointer[Float32],
    incy: Int64,
    result: UnsafePointer[Float32],
) -> Status:
    return _get_dylib_function[
        "rocblas_sdot_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[Float32],
            Int64,
            UnsafePointer[Float32],
            Int64,
            UnsafePointer[Float32],
        ) -> Status,
    ]()(handle, n, x, incx, y, incy, result)


fn rocblas_rot_batched_ex(
    handle: Handle,
    n: Int32,
    x: OpaquePointer,
    x_type: DataType,
    incx: Int32,
    y: OpaquePointer,
    y_type: DataType,
    incy: Int32,
    c: OpaquePointer,
    s: OpaquePointer,
    cs_type: DataType,
    batch_count: Int32,
    execution_type: DataType,
) -> Status:
    """
    \\brief <b> BLAS EX API </b>.

    \\details
    rot_batched_ex applies the Givens rotation matrix defined by c=cos(alpha) and s=sin(alpha) to batched vectors x_i and y_i, for i = 1, ..., batch_count.
        Scalars c and s may be stored in either host or device memory. Location is specified by calling rocblas_set_pointer_mode.

    In the case where cs_type is real:

        x := c * x + s * y
        y := c * y - s * x

    In the case where cs_type is complex, the imaginary part of c is ignored:

        x := real(c) * x + s * y
        y := real(c) * y - conj(s) * x

    Currently supported datatypes are as follows:

    ------------------------------------------------
    |  x_type | y_type  | cs_type | execution_type |
    |---------|---------|---------|----------------|
    |  bf16_r |  bf16_r | bf16_r  |  f32_r         |
    |  f16_r  |  f16_r  | f16_r   |  f32_r         |
    |  f32_r  |  f32_r  | f32_r   |  f32_r         |
    |  f64_r  |  f64_r  | f64_r   |  f64_r         |
    |  f32_c  |  f32_c  | f32_c   |  f32_c         |
    |  f32_c  |  f32_c  | f32_r   |  f32_c         |
    |  f64_c  |  f64_c  | f64_c   |  f64_c         |
    |  f64_c  |  f64_c  | f64_r   |  f64_c         |
    ------------------------------------------------

    @param[in]
    handle  [rocblas_handle]
            handle to the rocblas library context queue.
    @param[in]
    n       [rocblas_int]
            number of elements in each x_i and y_i vectors.
    @param[in, out]
    x       device array of device pointers storing each vector x_i.
    @param[in]
    x_type [rocblas_datatype]
           specifies the datatype of each vector x_i.
    @param[in]
    incx    [rocblas_int]
            specifies the increment between elements of each x_i.
    @param[in, out]
    y       device array of device pointers storing each vector y_i.
    @param[in]
    y_type [rocblas_datatype]
           specifies the datatype of each vector y_i.
    @param[in]
    incy    [rocblas_int]
            specifies the increment between elements of each y_i.
    @param[in]
    c       device pointer or host pointer to scalar cosine component of the rotation matrix.
    @param[in]
    s       device pointer or host pointer to scalar sine component of the rotation matrix.
    @param[in]
    cs_type [rocblas_datatype]
            specifies the datatype of c and s.
    @param[in]
    batch_count [rocblas_int]
                the number of x and y arrays, the number of batches.
    @param[in]
    execution_type [rocblas_datatype]
                   specifies the datatype of computation.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_rot_batched_ex",
        fn (
            Handle,
            Int32,
            OpaquePointer,
            DataType,
            Int32,
            OpaquePointer,
            DataType,
            Int32,
            OpaquePointer,
            OpaquePointer,
            DataType,
            Int32,
            DataType,
        ) -> Status,
    ]()(
        handle,
        n,
        x,
        x_type,
        incx,
        y,
        y_type,
        incy,
        c,
        s,
        cs_type,
        batch_count,
        execution_type,
    )


fn rocblas_tstgemv_strided_batched_64(
    handle: Handle,
    trans_a: Operation,
    m: Int64,
    n: Int64,
    alpha: UnsafePointer[Float32],
    _a: UnsafePointer[BFloat16],
    lda: Int64,
    stride_a: Int64,
    x: UnsafePointer[BFloat16],
    incx: Int64,
    stridex: Int64,
    beta: UnsafePointer[Float32],
    y: UnsafePointer[BFloat16],
    incy: Int64,
    stridey: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_tstgemv_strided_batched_64",
        fn (
            Handle,
            Operation,
            Int64,
            Int64,
            UnsafePointer[Float32],
            UnsafePointer[BFloat16],
            Int64,
            Int64,
            UnsafePointer[BFloat16],
            Int64,
            Int64,
            UnsafePointer[Float32],
            UnsafePointer[BFloat16],
            Int64,
            Int64,
            Int64,
        ) -> Status,
    ]()(
        handle,
        trans_a,
        m,
        n,
        alpha,
        _a,
        lda,
        stride_a,
        x,
        incx,
        stridex,
        beta,
        y,
        incy,
        stridey,
        batch_count,
    )


fn rocblas_srotm_strided_batched_64(
    handle: Handle,
    n: Int64,
    x: UnsafePointer[Float32],
    incx: Int64,
    stride_x: Int64,
    y: UnsafePointer[Float32],
    incy: Int64,
    stride_y: Int64,
    param: UnsafePointer[Float32],
    stride_param: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_srotm_strided_batched_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[Float32],
            Int64,
            Int64,
            UnsafePointer[Float32],
            Int64,
            Int64,
            UnsafePointer[Float32],
            Int64,
            Int64,
        ) -> Status,
    ]()(
        handle,
        n,
        x,
        incx,
        stride_x,
        y,
        incy,
        stride_y,
        param,
        stride_param,
        batch_count,
    )


fn rocblas_zswap_batched(
    handle: Handle,
    n: Int32,
    x: OpaquePointer,
    incx: Int32,
    y: OpaquePointer,
    incy: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_zswap_batched",
        fn (
            Handle,
            Int32,
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(handle, n, x, incx, y, incy, batch_count)


fn rocblas_dsyrkx(
    handle: Handle,
    uplo: Fill,
    trans: Operation,
    n: Int32,
    k: Int32,
    alpha: UnsafePointer[Float64],
    _a: UnsafePointer[Float64],
    lda: Int32,
    _b: UnsafePointer[Float64],
    ldb: Int32,
    beta: UnsafePointer[Float64],
    _c: UnsafePointer[Float64],
    ldc: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_dsyrkx",
        fn (
            Handle,
            Fill,
            Operation,
            Int32,
            Int32,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int32,
            UnsafePointer[Float64],
            Int32,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int32,
        ) -> Status,
    ]()(handle, uplo, trans, n, k, alpha, _a, lda, _b, ldb, beta, _c, ldc)


fn rocblas_zswap_strided_batched_64(
    handle: Handle,
    n: Int64,
    x: UnsafePointer[ComplexFloat64],
    incx: Int64,
    stridex: Int64,
    y: UnsafePointer[ComplexFloat64],
    incy: Int64,
    stridey: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_zswap_strided_batched_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int64,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int64,
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, n, x, incx, stridex, y, incy, stridey, batch_count)


fn rocblas_axpy_strided_batched_ex_64(
    handle: Handle,
    n: Int64,
    alpha: OpaquePointer,
    alpha_type: DataType,
    x: OpaquePointer,
    x_type: DataType,
    incx: Int64,
    stridex: Int64,
    y: OpaquePointer,
    y_type: DataType,
    incy: Int64,
    stridey: Int64,
    batch_count: Int64,
    execution_type: DataType,
) -> Status:
    return _get_dylib_function[
        "rocblas_axpy_strided_batched_ex_64",
        fn (
            Handle,
            Int64,
            OpaquePointer,
            DataType,
            OpaquePointer,
            DataType,
            Int64,
            Int64,
            OpaquePointer,
            DataType,
            Int64,
            Int64,
            Int64,
            DataType,
        ) -> Status,
    ]()(
        handle,
        n,
        alpha,
        alpha_type,
        x,
        x_type,
        incx,
        stridex,
        y,
        y_type,
        incy,
        stridey,
        batch_count,
        execution_type,
    )


fn rocblas_cgeru_strided_batched_64(
    handle: Handle,
    m: Int64,
    n: Int64,
    alpha: UnsafePointer[ComplexFloat32],
    x: UnsafePointer[ComplexFloat32],
    incx: Int64,
    stridex: Int64,
    y: UnsafePointer[ComplexFloat32],
    incy: Int64,
    stridey: Int64,
    _a: UnsafePointer[ComplexFloat32],
    lda: Int64,
    stride_a: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_cgeru_strided_batched_64",
        fn (
            Handle,
            Int64,
            Int64,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int64,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int64,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int64,
            Int64,
            Int64,
        ) -> Status,
    ]()(
        handle,
        m,
        n,
        alpha,
        x,
        incx,
        stridex,
        y,
        incy,
        stridey,
        _a,
        lda,
        stride_a,
        batch_count,
    )


fn rocblas_zdgmm(
    handle: Handle,
    side: Side,
    m: Int32,
    n: Int32,
    _a: UnsafePointer[ComplexFloat64],
    lda: Int32,
    x: UnsafePointer[ComplexFloat64],
    incx: Int32,
    _c: UnsafePointer[ComplexFloat64],
    ldc: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_zdgmm",
        fn (
            Handle,
            Side,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat64],
            Int32,
            UnsafePointer[ComplexFloat64],
            Int32,
            UnsafePointer[ComplexFloat64],
            Int32,
        ) -> Status,
    ]()(handle, side, m, n, _a, lda, x, incx, _c, ldc)


fn rocblas_ssyrkx_batched(
    handle: Handle,
    uplo: Fill,
    trans: Operation,
    n: Int32,
    k: Int32,
    alpha: UnsafePointer[Float32],
    _a: OpaquePointer,
    lda: Int32,
    _b: OpaquePointer,
    ldb: Int32,
    beta: UnsafePointer[Float32],
    _c: OpaquePointer,
    ldc: Int32,
    batch_count: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 3 API </b>.

    \\details
    syrkx_batched performs a batch of the matrix-matrix operations for a symmetric rank-k update:

        C_i := alpha*op( A_i )*op( B_i )^T + beta*C_i,

        where  alpha and beta are scalars, op(A_i) and op(B_i) are n by k matrix, and
        C_i is a symmetric n x n matrix stored as either upper or lower.

    This routine should only be used when the caller can guarantee that the result of op( A_i )*op( B_i )^T will be symmetric.

        op( A_i ) = A_i, op( B_i ) = B_i, and A_i and B_i are n by k if trans == rocblas_operation_none
        op( A_i ) = A_i^T, op( B_i ) = B_i^T,  and A_i and B_i are k by n if trans == rocblas_operation_transpose
        or for ssyrkx_batched and dsyrkx_batched when trans == rocblas_operation_conjugate_transpose

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.

    @param[in]
    uplo    [rocblas_fill]
            - rocblas_fill_upper:  C_i is an upper triangular matrix
            - rocblas_fill_lower:  C_i is a  lower triangular matrix

    @param[in]
    trans  [rocblas_operation]
            - rocblas_operation_transpose:           op( A_i ) = A_i^T, op( B_i ) = B_i^T
            - rocblas_operation_none:                op( A_i ) = A_i, op( B_i ) = B_i
            - rocblas_operation_conjugate_transpose: op( A_i ) = A_i^T, op( B_i ) = B_i^T

            rocblas_operation_conjugate_transpose is not supported for complex types in csyrkx_batched and zsyrkx_batched.

    @param[in]
    n       [rocblas_int]
            n specifies the number of rows and columns of C_i. n >= 0.

    @param[in]
    k       [rocblas_int]
            k specifies the number of columns of op(A). k >= 0.

    @param[in]
    alpha
            alpha specifies the scalar alpha. When alpha is
            zero then A is not referenced and A need not be set before
            entry.

    @param[in]
    A       device array of device pointers storing each matrix_i A of dimension (lda, k)
            when trans is rocblas_operation_none, otherwise of dimension (lda, n)

    @param[in]
    lda     [rocblas_int]
            lda specifies the first dimension of A_i.

                if trans = rocblas_operation_none,  lda >= max( 1, n ),
                otherwise lda >= max( 1, k ).

    @param[in]
    B       device array of device pointers storing each matrix_i B of dimension (ldb, k)
            when trans is rocblas_operation_none, otherwise of dimension (ldb, n)

    @param[in]
    ldb     [rocblas_int]
            ldb specifies the first dimension of B.

                if trans = rocblas_operation_none,  ldb >= max( 1, n ),
                otherwise ldb >= max( 1, k ).

    @param[in]
    beta
            beta specifies the scalar beta. When beta is
            zero then C need not be set before entry.

    @param[in]
    C       device array of device pointers storing each matrix C_i on the GPU.
            only the upper/lower triangular part of each C_i is accessed.

    @param[in]
    ldc    [rocblas_int]
           ldc specifies the first dimension of C. ldc >= max( 1, n ).

    @param[in]
    batch_count [rocblas_int]
            number of instances in the batch.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_ssyrkx_batched",
        fn (
            Handle,
            Fill,
            Operation,
            Int32,
            Int32,
            UnsafePointer[Float32],
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            UnsafePointer[Float32],
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(
        handle,
        uplo,
        trans,
        n,
        k,
        alpha,
        _a,
        lda,
        _b,
        ldb,
        beta,
        _c,
        ldc,
        batch_count,
    )


fn rocblas_chemv(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat32],
    _a: UnsafePointer[ComplexFloat32],
    lda: Int32,
    x: UnsafePointer[ComplexFloat32],
    incx: Int32,
    beta: UnsafePointer[ComplexFloat32],
    y: UnsafePointer[ComplexFloat32],
    incy: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 2 API </b>.

    \\details
    hemv performs one of the matrix-vector operations:

        y := alpha*A*x + beta*y
        where alpha and beta are scalars, x and y are n element vectors and A is an
        n by n Hermitian matrix.

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    uplo      [rocblas_fill]
            - rocblas_fill_upper: the upper triangular part of the Hermitian matrix A is supplied.
            - rocblas_fill_lower: the lower triangular part of the Hermitian matrix A is supplied.
    @param[in]
    n         [rocblas_int]
              the order of the matrix A.
    @param[in]
    alpha     device pointer or host pointer to scalar alpha.
    @param[in]
    A         device pointer storing matrix A. Of dimension (lda, n).

        if uplo == rocblas_fill_upper:
            The upper triangular part of A must contain
            the upper triangular part of a Hermitian matrix. The lower
            triangular part of A will not be referenced.

        if uplo == rocblas_fill_lower:
            The lower triangular part of A must contain
            the lower triangular part of a Hermitian matrix. The upper
            triangular part of A will not be referenced.
            As a Hermitian matrix, the imaginary part of the main diagonal
            of A will not be referenced and is assumed to be == 0.
    @param[in]
    lda       [rocblas_int]
              specifies the leading dimension of A. must be >= max(1, n).
    @param[in]
    x         device pointer storing vector x.
    @param[in]
    incx      [rocblas_int]
              specifies the increment for the elements of x.
    @param[in]
    beta      device pointer or host pointer to scalar beta.
    @param[in, out]
    y         device pointer storing vector y.
    @param[in]
    incy      [rocblas_int]
              specifies the increment for the elements of y.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_chemv",
        fn (
            Handle,
            Fill,
            Int32,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int32,
            UnsafePointer[ComplexFloat32],
            Int32,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int32,
        ) -> Status,
    ]()(handle, uplo, n, alpha, _a, lda, x, incx, beta, y, incy)


fn rocblas_ztrsv_strided_batched_64(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int64,
    _a: UnsafePointer[ComplexFloat64],
    lda: Int64,
    stride__a: Int64,
    x: UnsafePointer[ComplexFloat64],
    incx: Int64,
    stride_x: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_ztrsv_strided_batched_64",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int64,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int64,
            Int64,
            Int64,
        ) -> Status,
    ]()(
        handle,
        uplo,
        trans_a,
        diag,
        n,
        _a,
        lda,
        stride__a,
        x,
        incx,
        stride_x,
        batch_count,
    )


fn rocblas_ssyr2k_batched(
    handle: Handle,
    uplo: Fill,
    trans: Operation,
    n: Int32,
    k: Int32,
    alpha: UnsafePointer[Float32],
    _a: OpaquePointer,
    lda: Int32,
    _b: OpaquePointer,
    ldb: Int32,
    beta: UnsafePointer[Float32],
    _c: OpaquePointer,
    ldc: Int32,
    batch_count: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 3 API </b>.

    \\details
    syr2k_batched performs a batch of the matrix-matrix operations for a symmetric rank-2k update:

        C_i := alpha*(op( A_i )*op( B_i )^T + op( B_i )*op( A_i )^T) + beta*C_i,

        where  alpha and beta are scalars, op(A_i) and op(B_i) are n by k matrix, and
        C_i is a symmetric n x n matrix stored as either upper or lower.

        op( A_i ) = A_i, op( B_i ) = B_i, and A_i and B_i are n by k if trans == rocblas_operation_none
        op( A_i ) = A_i^T, op( B_i ) = B_i^T, and A_i and B_i are k by n if trans == rocblas_operation_transpose
        or for ssyr2k_batched and dsyr2k_batched when trans == rocblas_operation_conjugate_transpose

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.

    @param[in]
    uplo    [rocblas_fill]
            - rocblas_fill_upper:  C_i is an upper triangular matrix
            - rocblas_fill_lower:  C_i is a  lower triangular matrix

    @param[in]
    trans  [rocblas_operation]
            - rocblas_operation_transpose:           op( A_i ) = A_i^T, op( B_i ) = B_i^T
            - rocblas_operation_none:                op( A_i ) = A_i, op( B_i ) = B_i
            - rocblas_operation_conjugate_transpose: op( A_i ) = A_i^T, op( B_i ) = B_i^T

            rocblas_operation_conjugate_transpose is not supported for complex types in csyr2k_batched and zsyr2k_batched.

    @param[in]
    n       [rocblas_int]
            n specifies the number of rows and columns of C_i. n >= 0.

    @param[in]
    k       [rocblas_int]
            k specifies the number of columns of op(A). k >= 0.

    @param[in]
    alpha
            alpha specifies the scalar alpha. When alpha is
            zero then A is not referenced and A need not be set before
            entry.

    @param[in]
    A       device array of device pointers storing each matrix_i A of dimension (lda, k)
            when trans is rocblas_operation_none, otherwise of dimension (lda, n).

    @param[in]
    lda     [rocblas_int]
            lda specifies the first dimension of A_i.
                if trans = rocblas_operation_none,  lda >= max( 1, n ),
                otherwise lda >= max( 1, k ).
    @param[in]
    B       device array of device pointers storing each matrix_i B of dimension (ldb, k)
            when trans is rocblas_operation_none, otherwise of dimension (ldb, n).
    @param[in]
    ldb     [rocblas_int]
            ldb specifies the first dimension of B.

                if trans = rocblas_operation_none,  ldb >= max( 1, n ),
                otherwise ldb >= max( 1, k ).
    @param[in]
    beta
            beta specifies the scalar beta. When beta is
            zero then C need not be set before entry.

    @param[in]
    C       device array of device pointers storing each matrix C_i on the GPU.

    @param[in]
    ldc    [rocblas_int]
           ldc specifies the first dimension of C. ldc >= max( 1, n ).
    @param[in]
    batch_count [rocblas_int]
                number of instances in the batch.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_ssyr2k_batched",
        fn (
            Handle,
            Fill,
            Operation,
            Int32,
            Int32,
            UnsafePointer[Float32],
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            UnsafePointer[Float32],
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(
        handle,
        uplo,
        trans,
        n,
        k,
        alpha,
        _a,
        lda,
        _b,
        ldb,
        beta,
        _c,
        ldc,
        batch_count,
    )


fn rocblas_srotg_64(
    handle: Handle,
    a: UnsafePointer[Float32],
    b: UnsafePointer[Float32],
    c: UnsafePointer[Float32],
    s: UnsafePointer[Float32],
) -> Status:
    return _get_dylib_function[
        "rocblas_srotg_64",
        fn (
            Handle,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            UnsafePointer[Float32],
        ) -> Status,
    ]()(handle, a, b, c, s)


fn rocblas_snrm2_strided_batched_64(
    handle: Handle,
    n: Int64,
    x: UnsafePointer[Float32],
    incx: Int64,
    stridex: Int64,
    batch_count: Int64,
    results: UnsafePointer[Float32],
) -> Status:
    return _get_dylib_function[
        "rocblas_snrm2_strided_batched_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[Float32],
            Int64,
            Int64,
            Int64,
            UnsafePointer[Float32],
        ) -> Status,
    ]()(handle, n, x, incx, stridex, batch_count, results)


fn rocblas_snrm2_batched(
    handle: Handle,
    n: Int32,
    x: OpaquePointer,
    incx: Int32,
    batch_count: Int32,
    results: UnsafePointer[Float32],
) -> Status:
    """
    \\brief <b> BLAS Level 1 API </b>.

    \\details
    nrm2_batched computes the euclidean norm over a batch of real or complex vectors:

        result := sqrt( x_i'*x_i ) for real vectors x, for i = 1, ..., batch_count
        result := sqrt( x_i**H*x_i ) for complex vectors x, for i = 1, ..., batch_count

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    n         [rocblas_int]
              number of elements in each x_i.
    @param[in]
    x         device array of device pointers storing each vector x_i.
    @param[in]
    incx      [rocblas_int]
              specifies the increment for the elements of each x_i. incx must be > 0.
    @param[in]
    batch_count [rocblas_int]
              number of instances in the batch.
    @param[out]
    results
              device pointer or host pointer to array of batch_count size for nrm2 results.
              return is 0.0 for each element if n <= 0, incx<=0.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_snrm2_batched",
        fn (
            Handle,
            Int32,
            OpaquePointer,
            Int32,
            Int32,
            UnsafePointer[Float32],
        ) -> Status,
    ]()(handle, n, x, incx, batch_count, results)


fn rocblas_zhpr_strided_batched(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    alpha: UnsafePointer[Float64],
    x: UnsafePointer[ComplexFloat64],
    incx: Int32,
    stride_x: Int64,
    _ap: UnsafePointer[ComplexFloat64],
    stride__a: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_zhpr_strided_batched",
        fn (
            Handle,
            Fill,
            Int32,
            UnsafePointer[Float64],
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int64,
            Int32,
        ) -> Status,
    ]()(handle, uplo, n, alpha, x, incx, stride_x, _ap, stride__a, batch_count)


fn rocblas_caxpy_strided_batched_64(
    handle: Handle,
    n: Int64,
    alpha: UnsafePointer[ComplexFloat32],
    x: UnsafePointer[ComplexFloat32],
    incx: Int64,
    stridex: Int64,
    y: UnsafePointer[ComplexFloat32],
    incy: Int64,
    stridey: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_caxpy_strided_batched_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int64,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int64,
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, n, alpha, x, incx, stridex, y, incy, stridey, batch_count)


fn rocblas_srotm(
    handle: Handle,
    n: Int32,
    x: UnsafePointer[Float32],
    incx: Int32,
    y: UnsafePointer[Float32],
    incy: Int32,
    param: UnsafePointer[Float32],
) -> Status:
    """
    \\brief <b> BLAS Level 1 API </b>.

    \\details
    rotm applies the modified Givens rotation matrix defined by param to vectors x and y.

    @param[in]
    handle  [rocblas_handle]
            handle to the rocblas library context queue.
    @param[in]
    n       [rocblas_int]
            number of elements in the x and y vectors.
    @param[in, out]
    x       device pointer storing vector x.
    @param[in]
    incx    [rocblas_int]
            specifies the increment between elements of x.
    @param[in, out]
    y       device pointer storing vector y.
    @param[in]
    incy    [rocblas_int]
            specifies the increment between elements of y.
    @param[in]
    param   device vector or host vector of 5 elements defining the rotation.

        param[0] = flag
        param[1] = H11
        param[2] = H21
        param[3] = H12
        param[4] = H22

        The flag parameter defines the form of H:

        flag = -1 => H = ( H11 H12 H21 H22 )
        flag =  0 => H = ( 1.0 H12 H21 1.0 )
        flag =  1 => H = ( H11 1.0 -1.0 H22 )
        flag = -2 => H = ( 1.0 0.0 0.0 1.0 )

        param may be stored in either host or device memory,
        location is specified by calling rocblas_set_pointer_mode.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_srotm",
        fn (
            Handle,
            Int32,
            UnsafePointer[Float32],
            Int32,
            UnsafePointer[Float32],
            Int32,
            UnsafePointer[Float32],
        ) -> Status,
    ]()(handle, n, x, incx, y, incy, param)


fn rocblas_dgbmv_batched_64(
    handle: Handle,
    trans: Operation,
    m: Int64,
    n: Int64,
    kl: Int64,
    ku: Int64,
    alpha: UnsafePointer[Float64],
    _a: OpaquePointer,
    lda: Int64,
    x: OpaquePointer,
    incx: Int64,
    beta: UnsafePointer[Float64],
    y: OpaquePointer,
    incy: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_dgbmv_batched_64",
        fn (
            Handle,
            Operation,
            Int64,
            Int64,
            Int64,
            Int64,
            UnsafePointer[Float64],
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            UnsafePointer[Float64],
            OpaquePointer,
            Int64,
            Int64,
        ) -> Status,
    ]()(
        handle,
        trans,
        m,
        n,
        kl,
        ku,
        alpha,
        _a,
        lda,
        x,
        incx,
        beta,
        y,
        incy,
        batch_count,
    )


fn rocblas_ddot_strided_batched_64(
    handle: Handle,
    n: Int64,
    x: UnsafePointer[Float64],
    incx: Int64,
    stridex: Int64,
    y: UnsafePointer[Float64],
    incy: Int64,
    stridey: Int64,
    batch_count: Int64,
    result: UnsafePointer[Float64],
) -> Status:
    return _get_dylib_function[
        "rocblas_ddot_strided_batched_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[Float64],
            Int64,
            Int64,
            UnsafePointer[Float64],
            Int64,
            Int64,
            Int64,
            UnsafePointer[Float64],
        ) -> Status,
    ]()(handle, n, x, incx, stridex, y, incy, stridey, batch_count, result)


fn rocblas_zhemv_batched(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat64],
    _a: OpaquePointer,
    lda: Int32,
    x: OpaquePointer,
    incx: Int32,
    beta: UnsafePointer[ComplexFloat64],
    y: OpaquePointer,
    incy: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_zhemv_batched",
        fn (
            Handle,
            Fill,
            Int32,
            UnsafePointer[ComplexFloat64],
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            UnsafePointer[ComplexFloat64],
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(handle, uplo, n, alpha, _a, lda, x, incx, beta, y, incy, batch_count)


fn rocblas_dger(
    handle: Handle,
    m: Int32,
    n: Int32,
    alpha: UnsafePointer[Float64],
    x: UnsafePointer[Float64],
    incx: Int32,
    y: UnsafePointer[Float64],
    incy: Int32,
    _a: UnsafePointer[Float64],
    lda: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_dger",
        fn (
            Handle,
            Int32,
            Int32,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int32,
            UnsafePointer[Float64],
            Int32,
            UnsafePointer[Float64],
            Int32,
        ) -> Status,
    ]()(handle, m, n, alpha, x, incx, y, incy, _a, lda)


fn rocblas_chpr2_batched_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    alpha: UnsafePointer[ComplexFloat32],
    x: OpaquePointer,
    incx: Int64,
    y: OpaquePointer,
    incy: Int64,
    _ap: OpaquePointer,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_chpr2_batched_64",
        fn (
            Handle,
            Fill,
            Int64,
            UnsafePointer[ComplexFloat32],
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
        ) -> Status,
    ]()(handle, uplo, n, alpha, x, incx, y, incy, _ap, batch_count)


fn rocblas_zaxpy_batched_64(
    handle: Handle,
    n: Int64,
    alpha: UnsafePointer[ComplexFloat64],
    x: OpaquePointer,
    incx: Int64,
    y: OpaquePointer,
    incy: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_zaxpy_batched_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[ComplexFloat64],
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, n, alpha, x, incx, y, incy, batch_count)


fn rocblas_ztrmv_batched_64(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int64,
    _a: UnsafePointer[UnsafePointer[ComplexFloat64]],
    lda: Int64,
    x: UnsafePointer[UnsafePointer[ComplexFloat64]],
    incx: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_ztrmv_batched_64",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int64,
            UnsafePointer[UnsafePointer[ComplexFloat64]],
            Int64,
            UnsafePointer[UnsafePointer[ComplexFloat64]],
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, uplo, trans_a, diag, n, _a, lda, x, incx, batch_count)


fn rocblas_sscal_64(
    handle: Handle,
    n: Int64,
    alpha: UnsafePointer[Float32],
    x: UnsafePointer[Float32],
    incx: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_sscal_64",
        fn (
            Handle, Int64, UnsafePointer[Float32], UnsafePointer[Float32], Int64
        ) -> Status,
    ]()(handle, n, alpha, x, incx)


fn rocblas_zgeam_batched(
    handle: Handle,
    trans_a: Operation,
    trans_b: Operation,
    m: Int32,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat64],
    _a: OpaquePointer,
    lda: Int32,
    beta: UnsafePointer[ComplexFloat64],
    _b: OpaquePointer,
    ldb: Int32,
    _c: OpaquePointer,
    ldc: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_zgeam_batched",
        fn (
            Handle,
            Operation,
            Operation,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat64],
            OpaquePointer,
            Int32,
            UnsafePointer[ComplexFloat64],
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(
        handle,
        trans_a,
        trans_b,
        m,
        n,
        alpha,
        _a,
        lda,
        beta,
        _b,
        ldb,
        _c,
        ldc,
        batch_count,
    )


fn rocblas_ctrsv_batched_64(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int64,
    _a: OpaquePointer,
    lda: Int64,
    x: OpaquePointer,
    incx: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_ctrsv_batched_64",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int64,
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, uplo, trans_a, diag, n, _a, lda, x, incx, batch_count)


fn rocblas_csyrk_batched(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    n: Int32,
    k: Int32,
    alpha: UnsafePointer[ComplexFloat32],
    _a: OpaquePointer,
    lda: Int32,
    beta: UnsafePointer[ComplexFloat32],
    _c: OpaquePointer,
    ldc: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_csyrk_batched",
        fn (
            Handle,
            Fill,
            Operation,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat32],
            OpaquePointer,
            Int32,
            UnsafePointer[ComplexFloat32],
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(handle, uplo, trans_a, n, k, alpha, _a, lda, beta, _c, ldc, batch_count)


fn rocblas_zhpr2_batched(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat64],
    x: OpaquePointer,
    incx: Int32,
    y: OpaquePointer,
    incy: Int32,
    _ap: OpaquePointer,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_zhpr2_batched",
        fn (
            Handle,
            Fill,
            Int32,
            UnsafePointer[ComplexFloat64],
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
        ) -> Status,
    ]()(handle, uplo, n, alpha, x, incx, y, incy, _ap, batch_count)


fn rocblas_saxpy_batched_64(
    handle: Handle,
    n: Int64,
    alpha: UnsafePointer[Float32],
    x: OpaquePointer,
    incx: Int64,
    y: OpaquePointer,
    incy: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_saxpy_batched_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[Float32],
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, n, alpha, x, incx, y, incy, batch_count)


fn rocblas_ssymv_batched(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    alpha: UnsafePointer[Float32],
    _a: OpaquePointer,
    lda: Int32,
    x: OpaquePointer,
    incx: Int32,
    beta: UnsafePointer[Float32],
    y: OpaquePointer,
    incy: Int32,
    batch_count: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 2 API </b>.

    \\details
    symv_batched performs the matrix-vector operation:

        y_i := alpha*A_i*x_i + beta*y_i
        where (A_i, x_i, y_i) is the i-th instance of the batch.
        alpha and beta are scalars, x_i and y_i are vectors and A_i is an
        n by n symmetric matrix, for i = 1, ..., batch_count.
        A a should contain an upper or lower triangular symmetric matrix
        and the opposing triangular part of A is not referenced.

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue
    @param[in]
    uplo      [rocblas_fill]
            specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
            - if rocblas_fill_upper, the lower part of A is not referenced.
            - if rocblas_fill_lower, the upper part of A is not referenced.
    @param[in]
    n         [rocblas_int]
              number of rows and columns of each matrix A_i.
    @param[in]
    alpha
              device pointer or host pointer to scalar alpha.
    @param[in]
    A         device array of device pointers storing each matrix A_i.
    @param[in]
    lda       [rocblas_int]
              specifies the leading dimension of each matrix A_i.
    @param[in]
    x         device array of device pointers storing each vector x_i.
    @param[in]
    incx      [rocblas_int]
              specifies the increment for the elements of each vector x_i.
    @param[in]
    beta      device pointer or host pointer to scalar beta.
    @param[out]
    y         device array of device pointers storing each vector y_i.
    @param[in]
    incy      [rocblas_int]
              specifies the increment for the elements of each vector y_i.
    @param[in]
    batch_count [rocblas_int]
                number of instances in the batch.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_ssymv_batched",
        fn (
            Handle,
            Fill,
            Int32,
            UnsafePointer[Float32],
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            UnsafePointer[Float32],
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(handle, uplo, n, alpha, _a, lda, x, incx, beta, y, incy, batch_count)


fn rocblas_dtbmv_strided_batched_64(
    handle: Handle,
    uplo: Fill,
    trans: Operation,
    diag: Diagonal,
    n: Int64,
    k: Int64,
    _a: UnsafePointer[Float64],
    lda: Int64,
    stride__a: Int64,
    x: UnsafePointer[Float64],
    incx: Int64,
    stride_x: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_dtbmv_strided_batched_64",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int64,
            Int64,
            UnsafePointer[Float64],
            Int64,
            Int64,
            UnsafePointer[Float64],
            Int64,
            Int64,
            Int64,
        ) -> Status,
    ]()(
        handle,
        uplo,
        trans,
        diag,
        n,
        k,
        _a,
        lda,
        stride__a,
        x,
        incx,
        stride_x,
        batch_count,
    )


fn rocblas_dgemv(
    handle: Handle,
    trans: Operation,
    m: Int32,
    n: Int32,
    alpha: UnsafePointer[Float64],
    _a: UnsafePointer[Float64],
    lda: Int32,
    x: UnsafePointer[Float64],
    incx: Int32,
    beta: UnsafePointer[Float64],
    y: UnsafePointer[Float64],
    incy: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_dgemv",
        fn (
            Handle,
            Operation,
            Int32,
            Int32,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int32,
            UnsafePointer[Float64],
            Int32,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int32,
        ) -> Status,
    ]()(handle, trans, m, n, alpha, _a, lda, x, incx, beta, y, incy)


fn rocblas_chpmv(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat32],
    _ap: UnsafePointer[ComplexFloat32],
    x: UnsafePointer[ComplexFloat32],
    incx: Int32,
    beta: UnsafePointer[ComplexFloat32],
    y: UnsafePointer[ComplexFloat32],
    incy: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 2 API </b>.

    \\details
    hpmv performs the matrix-vector operation:

        y := alpha*A*x + beta*y
        where alpha and beta are scalars, x and y are n element vectors and A is an
        n by n Hermitian matrix, supplied in packed form (see description below).

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    uplo      [rocblas_fill]
            - rocblas_fill_upper: the upper triangular part of the Hermitian matrix A is supplied in AP.
            - rocblas_fill_lower: the lower triangular part of the Hermitian matrix A is supplied in AP.
    @param[in]
    n         [rocblas_int]
              the order of the matrix A. Must be >= 0.
    @param[in]
    alpha     device pointer or host pointer to scalar alpha.
    @param[in]
    AP        device pointer storing the packed version of the specified triangular portion of
              the Hermitian matrix A. Of at least size ((n * (n + 1)) / 2).

                    if uplo == rocblas_fill_upper:
                        The upper triangular portion of the Hermitian matrix A is supplied.
                        The matrix is compacted so that AP contains the triangular portion
                        column-by-column
                        so that:
                        AP(0) = A(0,0)
                        AP(1) = A(0,1)
                        AP(2) = A(1,1), etc.
                        Ex: (rocblas_fill_upper; n = 3)
                            (1, 0) (2, 1) (3, 2)
                            (2,-1) (4, 0) (5,-1) ---> [(1,0),(2,1),(4,0),(3,2),(5,-1),(6,0)]
                            (3,-2) (5, 1) (6, 0)

                    if uplo == rocblas_fill_lower:
                        The lower triangular portion of the Hermitian matrix A is supplied.
                        The matrix is compacted so that AP contains the triangular portion
                        column-by-column
                        so that:
                        AP(0) = A(0,0)
                        AP(1) = A(1,0)
                        AP(2) = A(2,1), etc.
                        Ex: (rocblas_fill_lower; n = 3)
                            (1, 0) (2, 1) (3, 2)
                            (2,-1) (4, 0) (5,-1) ---> [(1,0),(2,-1),(3,-2),(4,0),(5,1),(6,0)]
                            (3,-2) (5, 1) (6, 0)
                Note that the imaginary part of the diagonal elements are not accessed
                and are assumed to be 0.
    @param[in]
    x         device pointer storing vector x.
    @param[in]
    incx      [rocblas_int]
              specifies the increment for the elements of x.
    @param[in]
    beta      device pointer or host pointer to scalar beta.
    @param[in, out]
    y         device pointer storing vector y.
    @param[in]
    incy      [rocblas_int]
              specifies the increment for the elements of y.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_chpmv",
        fn (
            Handle,
            Fill,
            Int32,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int32,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int32,
        ) -> Status,
    ]()(handle, uplo, n, alpha, _ap, x, incx, beta, y, incy)


fn rocblas_dgeam(
    handle: Handle,
    trans_a: Operation,
    trans_b: Operation,
    m: Int32,
    n: Int32,
    alpha: UnsafePointer[Float64],
    _a: UnsafePointer[Float64],
    lda: Int32,
    beta: UnsafePointer[Float64],
    _b: UnsafePointer[Float64],
    ldb: Int32,
    _c: UnsafePointer[Float64],
    ldc: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_dgeam",
        fn (
            Handle,
            Operation,
            Operation,
            Int32,
            Int32,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int32,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int32,
            UnsafePointer[Float64],
            Int32,
        ) -> Status,
    ]()(handle, trans_a, trans_b, m, n, alpha, _a, lda, beta, _b, ldb, _c, ldc)


fn rocblas_zhemv_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    alpha: UnsafePointer[ComplexFloat64],
    _a: UnsafePointer[ComplexFloat64],
    lda: Int64,
    x: UnsafePointer[ComplexFloat64],
    incx: Int64,
    beta: UnsafePointer[ComplexFloat64],
    y: UnsafePointer[ComplexFloat64],
    incy: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_zhemv_64",
        fn (
            Handle,
            Fill,
            Int64,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int64,
            UnsafePointer[ComplexFloat64],
            Int64,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int64,
        ) -> Status,
    ]()(handle, uplo, n, alpha, _a, lda, x, incx, beta, y, incy)


fn rocblas_sspr2_strided_batched_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    alpha: UnsafePointer[Float32],
    x: UnsafePointer[Float32],
    incx: Int64,
    stride_x: Int64,
    y: UnsafePointer[Float32],
    incy: Int64,
    stride_y: Int64,
    _ap: UnsafePointer[Float32],
    stride__a: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_sspr2_strided_batched_64",
        fn (
            Handle,
            Fill,
            Int64,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int64,
            Int64,
            UnsafePointer[Float32],
            Int64,
            Int64,
            UnsafePointer[Float32],
            Int64,
            Int64,
        ) -> Status,
    ]()(
        handle,
        uplo,
        n,
        alpha,
        x,
        incx,
        stride_x,
        y,
        incy,
        stride_y,
        _ap,
        stride__a,
        batch_count,
    )


fn rocblas_srotmg_64(
    handle: Handle,
    d1: UnsafePointer[Float32],
    d2: UnsafePointer[Float32],
    x1: UnsafePointer[Float32],
    y1: UnsafePointer[Float32],
    param: UnsafePointer[Float32],
) -> Status:
    return _get_dylib_function[
        "rocblas_srotmg_64",
        fn (
            Handle,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            UnsafePointer[Float32],
        ) -> Status,
    ]()(handle, d1, d2, x1, y1, param)


fn rocblas_zsyr2_strided_batched_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    alpha: UnsafePointer[ComplexFloat64],
    x: UnsafePointer[ComplexFloat64],
    incx: Int64,
    stridex: Int64,
    y: UnsafePointer[ComplexFloat64],
    incy: Int64,
    stridey: Int64,
    _a: UnsafePointer[ComplexFloat64],
    lda: Int64,
    stride_a: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_zsyr2_strided_batched_64",
        fn (
            Handle,
            Fill,
            Int64,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int64,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int64,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int64,
            Int64,
            Int64,
        ) -> Status,
    ]()(
        handle,
        uplo,
        n,
        alpha,
        x,
        incx,
        stridex,
        y,
        incy,
        stridey,
        _a,
        lda,
        stride_a,
        batch_count,
    )


fn rocblas_zgerc_strided_batched(
    handle: Handle,
    m: Int32,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat64],
    x: UnsafePointer[ComplexFloat64],
    incx: Int32,
    stridex: Int64,
    y: UnsafePointer[ComplexFloat64],
    incy: Int32,
    stridey: Int64,
    _a: UnsafePointer[ComplexFloat64],
    lda: Int32,
    stride_a: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_zgerc_strided_batched",
        fn (
            Handle,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        m,
        n,
        alpha,
        x,
        incx,
        stridex,
        y,
        incy,
        stridey,
        _a,
        lda,
        stride_a,
        batch_count,
    )


fn rocblas_izamin_strided_batched(
    handle: Handle,
    n: Int32,
    x: UnsafePointer[ComplexFloat64],
    incx: Int32,
    stridex: Int64,
    batch_count: Int32,
    result: UnsafePointer[Int32],
) -> Status:
    return _get_dylib_function[
        "rocblas_izamin_strided_batched",
        fn (
            Handle,
            Int32,
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            Int32,
            UnsafePointer[Int32],
        ) -> Status,
    ]()(handle, n, x, incx, stridex, batch_count, result)


fn rocblas_bfdot(
    handle: Handle,
    n: Int32,
    x: UnsafePointer[BFloat16],
    incx: Int32,
    y: UnsafePointer[BFloat16],
    incy: Int32,
    result: UnsafePointer[BFloat16],
) -> Status:
    return _get_dylib_function[
        "rocblas_bfdot",
        fn (
            Handle,
            Int32,
            UnsafePointer[BFloat16],
            Int32,
            UnsafePointer[BFloat16],
            Int32,
            UnsafePointer[BFloat16],
        ) -> Status,
    ]()(handle, n, x, incx, y, incy, result)


fn rocblas_drotg_batched_64(
    handle: Handle,
    a: OpaquePointer,
    b: OpaquePointer,
    c: OpaquePointer,
    s: OpaquePointer,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_drotg_batched_64",
        fn (
            Handle,
            OpaquePointer,
            OpaquePointer,
            OpaquePointer,
            OpaquePointer,
            Int64,
        ) -> Status,
    ]()(handle, a, b, c, s, batch_count)


fn rocblas_ssyrkx_strided_batched(
    handle: Handle,
    uplo: Fill,
    trans: Operation,
    n: Int32,
    k: Int32,
    alpha: UnsafePointer[Float32],
    _a: UnsafePointer[Float32],
    lda: Int32,
    stride__a: Int64,
    _b: UnsafePointer[Float32],
    ldb: Int32,
    stride__b: Int64,
    beta: UnsafePointer[Float32],
    _c: UnsafePointer[Float32],
    ldc: Int32,
    stride__c: Int64,
    batch_count: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 3 API </b>.

    \\details
    syrkx_strided_batched performs a batch of the matrix-matrix operations for a symmetric rank-k update:

        C_i := alpha*op( A_i )*op( B_i )^T + beta*C_i,

        where  alpha and beta are scalars, op(A_i) and op(B_i) are n by k matrix, and
        C_i is a symmetric n x n matrix stored as either upper or lower.

    This routine should only be used when the caller can guarantee that the result of op( A_i )*op( B_i )^T will be symmetric.

        op( A_i ) = A_i, op( B_i ) = B_i, and A_i and B_i are n by k if trans == rocblas_operation_none
        op( A_i ) = A_i^T, op( B_i ) = B_i^T,  and A_i and B_i are k by n if trans == rocblas_operation_transpose
        or for ssyrkx_strided_batched and dsyrkx_strided_batched when trans == rocblas_operation_conjugate_transpose

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.

    @param[in]
    uplo    [rocblas_fill]
            - rocblas_fill_upper:  C_i is an upper triangular matrix
            - rocblas_fill_lower:  C_i is a  lower triangular matrix

    @param[in]
    trans  [rocblas_operation]
            - rocblas_operation_transpose:           op( A_i ) = A_i^T, op( B_i ) = B_i^T
            - rocblas_operation_none:                op( A_i ) = A_i, op( B_i ) = B_i
            - rocblas_operation_conjugate_transpose: op( A_i ) = A_i^T, op( B_i ) = B_i^T

            rocblas_operation_conjugate_transpose is not supported for complex types in csyrkx_strided_batched and zsyrkx_strided_batched.

    @param[in]
    n       [rocblas_int]
            n specifies the number of rows and columns of C_i. n >= 0.

    @param[in]
    k       [rocblas_int]
            k specifies the number of columns of op(A). k >= 0.

    @param[in]
    alpha
            alpha specifies the scalar alpha. When alpha is
            zero then A is not referenced and A need not be set before
            entry.

    @param[in]
    A       Device pointer to the first matrix A_1 on the GPU of dimension (lda, k)
            when trans is rocblas_operation_none, otherwise of dimension (lda, n)

    @param[in]
    lda     [rocblas_int]
            lda specifies the first dimension of A_i.

                if trans = rocblas_operation_none,  lda >= max( 1, n ),
                otherwise lda >= max( 1, k ).

    @param[in]
    stride_A  [rocblas_stride]
              stride from the start of one matrix (A_i) and the next one (A_i+1).

    @param[in]
    B       Device pointer to the first matrix B_1 on the GPU of dimension (ldb, k)
            when trans is rocblas_operation_none, otherwise of dimension (ldb, n).

    @param[in]
    ldb     [rocblas_int]
            ldb specifies the first dimension of B_i.

                if trans = rocblas_operation_none,  ldb >= max( 1, n ),
                otherwise ldb >= max( 1, k ).

    @param[in]
    stride_B  [rocblas_stride]
              stride from the start of one matrix (B_i) and the next one (B_i+1).

    @param[in]
    beta
            beta specifies the scalar beta. When beta is
            zero then C need not be set before entry.

    @param[in]
    C       Device pointer to the first matrix C_1 on the GPU.
            only the upper/lower triangular part of each C_i is accessed.

    @param[in]
    ldc    [rocblas_int]
           ldc specifies the first dimension of C. ldc >= max( 1, n ).

    @param[in, out]
    stride_C  [rocblas_stride]
              stride from the start of one matrix (C_i) and the next one (C_i+1).

    @param[in]
    batch_count [rocblas_int]
                number of instances in the batch.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_ssyrkx_strided_batched",
        fn (
            Handle,
            Fill,
            Operation,
            Int32,
            Int32,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int32,
            Int64,
            UnsafePointer[Float32],
            Int32,
            Int64,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        uplo,
        trans,
        n,
        k,
        alpha,
        _a,
        lda,
        stride__a,
        _b,
        ldb,
        stride__b,
        beta,
        _c,
        ldc,
        stride__c,
        batch_count,
    )


fn rocblas_stpmv(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int32,
    _a: UnsafePointer[Float32],
    x: UnsafePointer[Float32],
    incx: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 2 API </b>.

    \\details
    tpmv performs one of the matrix-vector operations:

        x = A*x or
        x = A**T*x or
        x = A**H*x
        where x is an n element vector and A is an n by n unit, or non-unit,
        upper or lower triangular matrix, supplied in the pack form.
        The vector x is overwritten.

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.

    @param[in]
    uplo    [rocblas_fill]
            - rocblas_fill_upper:  A is an upper triangular matrix.
            - rocblas_fill_lower:  A is a  lower triangular matrix.

    @param[in]
    transA     [rocblas_operation]
            - rocblas_operation_none:    op(A) = A.
            - rocblas_operation_transpose:   op(A) = A^T
            - rocblas_operation_conjugate_transpose:  op(A) = A^H

    @param[in]
    diag    [rocblas_diagonal]
            - rocblas_diagonal_unit:     A is assumed to be unit triangular.
            - rocblas_diagonal_non_unit:  A is not assumed to be unit triangular.

    @param[in]
    n       [rocblas_int]
            n specifies the number of rows of A. n >= 0.

    @param[in]
    A       device pointer storing matrix A,
            of dimension at least ( n * ( n + 1 ) / 2 ).
        - Before entry with uplo = rocblas_fill_upper, the array A
            must contain the upper triangular matrix packed sequentially,
            column by column, so that
            A[0] contains a_{0,0}, A[1] and A[2] contain
            a_{0,1} and a_{1, 1}, respectively, and so on.

        - Before entry with uplo = rocblas_fill_lower, the array A
            must contain the lower triangular matrix packed sequentially,
            column by column, so that
            A[0] contains a_{0,0}, A[1] and A[2] contain
            a_{1,0} and a_{2,0}, respectively, and so on.

          Note that when DIAG = rocblas_diagonal_unit, the diagonal elements of A are
          not referenced, but are assumed to be unity.

    @param[in, out]
    x      device pointer storing vector x. On exit, x is overwritten with the transformed vector x.

    @param[in]
    incx    [rocblas_int]
            specifies the increment for the elements of x. incx must not be zero.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_stpmv",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int32,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int32,
        ) -> Status,
    ]()(handle, uplo, trans_a, diag, n, _a, x, incx)


fn rocblas_cgeru(
    handle: Handle,
    m: Int32,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat32],
    x: UnsafePointer[ComplexFloat32],
    incx: Int32,
    y: UnsafePointer[ComplexFloat32],
    incy: Int32,
    _a: UnsafePointer[ComplexFloat32],
    lda: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_cgeru",
        fn (
            Handle,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int32,
            UnsafePointer[ComplexFloat32],
            Int32,
            UnsafePointer[ComplexFloat32],
            Int32,
        ) -> Status,
    ]()(handle, m, n, alpha, x, incx, y, incy, _a, lda)


fn rocblas_dtrsm_strided_batched(
    handle: Handle,
    side: Side,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    m: Int32,
    n: Int32,
    alpha: UnsafePointer[Float64],
    _a: UnsafePointer[Float64],
    lda: Int32,
    stride_a: Int64,
    _b: UnsafePointer[Float64],
    ldb: Int32,
    stride_b: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_dtrsm_strided_batched",
        fn (
            Handle,
            Side,
            Fill,
            Operation,
            Diagonal,
            Int32,
            Int32,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int32,
            Int64,
            UnsafePointer[Float64],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        side,
        uplo,
        trans_a,
        diag,
        m,
        n,
        alpha,
        _a,
        lda,
        stride_a,
        _b,
        ldb,
        stride_b,
        batch_count,
    )


fn rocblas_ddot_batched_64(
    handle: Handle,
    n: Int64,
    x: OpaquePointer,
    incx: Int64,
    y: OpaquePointer,
    incy: Int64,
    batch_count: Int64,
    result: UnsafePointer[Float64],
) -> Status:
    return _get_dylib_function[
        "rocblas_ddot_batched_64",
        fn (
            Handle,
            Int64,
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            Int64,
            UnsafePointer[Float64],
        ) -> Status,
    ]()(handle, n, x, incx, y, incy, batch_count, result)


fn rocblas_zdrot_64(
    handle: Handle,
    n: Int64,
    x: UnsafePointer[ComplexFloat64],
    incx: Int64,
    y: UnsafePointer[ComplexFloat64],
    incy: Int64,
    c: UnsafePointer[Float64],
    s: UnsafePointer[Float64],
) -> Status:
    return _get_dylib_function[
        "rocblas_zdrot_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int64,
            UnsafePointer[ComplexFloat64],
            Int64,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
        ) -> Status,
    ]()(handle, n, x, incx, y, incy, c, s)


fn rocblas_ztpsv_strided_batched(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int32,
    _ap: UnsafePointer[ComplexFloat64],
    stride__a: Int64,
    x: UnsafePointer[ComplexFloat64],
    incx: Int32,
    stride_x: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_ztpsv_strided_batched",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int32,
            UnsafePointer[ComplexFloat64],
            Int64,
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        uplo,
        trans_a,
        diag,
        n,
        _ap,
        stride__a,
        x,
        incx,
        stride_x,
        batch_count,
    )


fn rocblas_cspr_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    alpha: UnsafePointer[ComplexFloat32],
    x: UnsafePointer[ComplexFloat32],
    incx: Int64,
    _ap: UnsafePointer[ComplexFloat32],
) -> Status:
    return _get_dylib_function[
        "rocblas_cspr_64",
        fn (
            Handle,
            Fill,
            Int64,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int64,
            UnsafePointer[ComplexFloat32],
        ) -> Status,
    ]()(handle, uplo, n, alpha, x, incx, _ap)


fn rocblas_dtrsm_64(
    handle: Handle,
    side: Side,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    m: Int64,
    n: Int64,
    alpha: UnsafePointer[Float64],
    _a: UnsafePointer[Float64],
    lda: Int64,
    _b: UnsafePointer[Float64],
    ldb: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_dtrsm_64",
        fn (
            Handle,
            Side,
            Fill,
            Operation,
            Diagonal,
            Int64,
            Int64,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int64,
            UnsafePointer[Float64],
            Int64,
        ) -> Status,
    ]()(handle, side, uplo, trans_a, diag, m, n, alpha, _a, lda, _b, ldb)


fn rocblas_dgemv_strided_batched(
    handle: Handle,
    trans_a: Operation,
    m: Int32,
    n: Int32,
    alpha: UnsafePointer[Float64],
    _a: UnsafePointer[Float64],
    lda: Int32,
    stride_a: Int64,
    x: UnsafePointer[Float64],
    incx: Int32,
    stridex: Int64,
    beta: UnsafePointer[Float64],
    y: UnsafePointer[Float64],
    incy: Int32,
    stridey: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_dgemv_strided_batched",
        fn (
            Handle,
            Operation,
            Int32,
            Int32,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int32,
            Int64,
            UnsafePointer[Float64],
            Int32,
            Int64,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        trans_a,
        m,
        n,
        alpha,
        _a,
        lda,
        stride_a,
        x,
        incx,
        stridex,
        beta,
        y,
        incy,
        stridey,
        batch_count,
    )


fn rocblas_izamax_64(
    handle: Handle,
    n: Int64,
    x: UnsafePointer[ComplexFloat64],
    incx: Int64,
    result: UnsafePointer[Int64],
) -> Status:
    return _get_dylib_function[
        "rocblas_izamax_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int64,
            UnsafePointer[Int64],
        ) -> Status,
    ]()(handle, n, x, incx, result)


fn rocblas_sspr2_strided_batched(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    alpha: UnsafePointer[Float32],
    x: UnsafePointer[Float32],
    incx: Int32,
    stride_x: Int64,
    y: UnsafePointer[Float32],
    incy: Int32,
    stride_y: Int64,
    _ap: UnsafePointer[Float32],
    stride__a: Int64,
    batch_count: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 2 API </b>.

    \\details
    spr2_strided_batched performs the matrix-vector operation:

        A_i := A_i + alpha*x_i*y_i**T + alpha*y_i*x_i**T
        where alpha is a scalar, x_i and y_i are vectors, and A_i is an
        n by n symmetric matrix, supplied in packed form, for i = 1, ..., batch_count.

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    uplo      [rocblas_fill]
            specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
            - rocblas_fill_upper: The upper triangular part of each A_i is supplied in AP.
            - rocblas_fill_lower: The lower triangular part of each A_i is supplied in AP.
    @param[in]
    n         [rocblas_int]
            the number of rows and columns of each matrix A_i. Must be at least 0.
    @param[in]
    alpha
              device pointer or host pointer to scalar alpha.
    @param[in]
    x         device pointer pointing to the first vector (x_1).
    @param[in]
    incx      [rocblas_int]
              specifies the increment for the elements of each x_i.
    @param[in]
    stride_x  [rocblas_stride]
              stride from the start of one vector (x_i) and the next one (x_i+1).
    @param[in]
    y         device pointer pointing to the first vector (y_1).
    @param[in]
    incy      [rocblas_int]
              specifies the increment for the elements of each y_i.
    @param[in]
    stride_y  [rocblas_stride]
              stride from the start of one vector (y_i) and the next one (y_i+1).
    @param[in, out]
    AP        device pointer storing the packed version of the specified triangular portion of
              each symmetric matrix A_i. Points to the first A_1.

                    if uplo == rocblas_fill_upper:
                        The upper triangular portion of each symmetric matrix A_i is supplied.
                        The matrix is compacted so that AP contains the triangular portion
                        column-by-column
                        so that:
                        AP(0) = A(0,0)
                        AP(1) = A(0,1)
                        AP(2) = A(1,1), etc.
                            Ex: (rocblas_fill_upper; n = 4)
                                1 2 4 7
                                2 3 5 8   -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
                                4 5 6 9
                                7 8 9 0

                    if uplo == rocblas_fill_lower:
                        The lower triangular portion of each symmetric matrix A_i is supplied.
                        The matrix is compacted so that AP contains the triangular portion
                        column-by-column
                        so that:
                        AP(0) = A(0,0)
                        AP(1) = A(1,0)
                        AP(n) = A(2,1), etc.
                            Ex: (rocblas_fill_lower; n = 4)
                                1 2 3 4
                                2 5 6 7    -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
                                3 6 8 9
                                4 7 9 0
    @param[in]
    stride_A    [rocblas_stride]
                stride from the start of one (A_i) and the next (A_i+1).
    @param[in]
    batch_count [rocblas_int]
                number of instances in the batch.
    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_sspr2_strided_batched",
        fn (
            Handle,
            Fill,
            Int32,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int32,
            Int64,
            UnsafePointer[Float32],
            Int32,
            Int64,
            UnsafePointer[Float32],
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        uplo,
        n,
        alpha,
        x,
        incx,
        stride_x,
        y,
        incy,
        stride_y,
        _ap,
        stride__a,
        batch_count,
    )


fn rocblas_zdrot(
    handle: Handle,
    n: Int32,
    x: UnsafePointer[ComplexFloat64],
    incx: Int32,
    y: UnsafePointer[ComplexFloat64],
    incy: Int32,
    c: UnsafePointer[Float64],
    s: UnsafePointer[Float64],
) -> Status:
    return _get_dylib_function[
        "rocblas_zdrot",
        fn (
            Handle,
            Int32,
            UnsafePointer[ComplexFloat64],
            Int32,
            UnsafePointer[ComplexFloat64],
            Int32,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
        ) -> Status,
    ]()(handle, n, x, incx, y, incy, c, s)


fn rocblas_zdscal(
    handle: Handle,
    n: Int32,
    alpha: UnsafePointer[Float64],
    x: UnsafePointer[ComplexFloat64],
    incx: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_zdscal",
        fn (
            Handle,
            Int32,
            UnsafePointer[Float64],
            UnsafePointer[ComplexFloat64],
            Int32,
        ) -> Status,
    ]()(handle, n, alpha, x, incx)


fn rocblas_sgemm_batched(
    handle: Handle,
    trans_a: Operation,
    trans_b: Operation,
    m: Int32,
    n: Int32,
    k: Int32,
    alpha: UnsafePointer[Float32],
    _a: OpaquePointer,
    lda: Int32,
    _b: OpaquePointer,
    ldb: Int32,
    beta: UnsafePointer[Float32],
    _c: OpaquePointer,
    ldc: Int32,
    batch_count: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 3 API </b>.

    \\details
    gemm_batched performs one of the batched matrix-matrix operations:

        C_i = alpha*op( A_i )*op( B_i ) + beta*C_i, for i = 1, ..., batch_count,

        where op( X ) is one of

        op( X ) = X      or
        op( X ) = X**T   or
        op( X ) = X**H,

        alpha and beta are scalars, and A, B and C are strided batched matrices, with

        op( A ) an m by k by batch_count matrices,
        op( B ) an k by n by batch_count matrices and
        C an m by n by batch_count matrices.

    @param[in]
    handle    [rocblas_handle
              handle to the rocblas library context queue.
    @param[in]
    transA    [rocblas_operation]
              specifies the form of op( A ).
    @param[in]
    transB    [rocblas_operation]
              specifies the form of op( B ).
    @param[in]
    m         [rocblas_int]
              matrix dimension m.
    @param[in]
    n         [rocblas_int]
              matrix dimension n.
    @param[in]
    k         [rocblas_int]
              matrix dimension k.
    @param[in]
    alpha     device pointer or host pointer specifying the scalar alpha.
    @param[in]
    A         device array of device pointers storing each matrix A_i.
    @param[in]
    lda       [rocblas_int]
              specifies the leading dimension of each A_i.
    @param[in]
    B         device array of device pointers storing each matrix B_i.
    @param[in]
    ldb       [rocblas_int]
              specifies the leading dimension of each B_i.
    @param[in]
    beta      device pointer or host pointer specifying the scalar beta.
    @param[in, out]
    C         device array of device pointers storing each matrix C_i.
    @param[in]
    ldc       [rocblas_int]
              specifies the leading dimension of each C_i.
    @param[in]
    batch_count
              [rocblas_int]
              number of gemm operations in the batch.
    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_sgemm_batched",
        fn (
            Handle,
            Operation,
            Operation,
            Int32,
            Int32,
            Int32,
            UnsafePointer[Float32],
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            UnsafePointer[Float32],
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(
        handle,
        trans_a,
        trans_b,
        m,
        n,
        k,
        alpha,
        _a,
        lda,
        _b,
        ldb,
        beta,
        _c,
        ldc,
        batch_count,
    )


fn rocblas_stbmv_batched(
    handle: Handle,
    uplo: Fill,
    trans: Operation,
    diag: Diagonal,
    n: Int32,
    k: Int32,
    _a: OpaquePointer,
    lda: Int32,
    x: OpaquePointer,
    incx: Int32,
    batch_count: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 2 API </b>.

    \\details
    tbmv_batched performs one of the matrix-vector operations:

        x_i := A_i*x_i      or
        x_i := A_i**T*x_i   or
        x_i := A_i**H*x_i,
        where (A_i, x_i) is the i-th instance of the batch.
        x_i is a vector and A_i is an n by n matrix, for i = 1, ..., batch_count.

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    uplo      [rocblas_fill]
            - rocblas_fill_upper: each A_i is an upper banded triangular matrix.
            - rocblas_fill_lower: each A_i is a  lower banded triangular matrix.
    @param[in]
    trans     [rocblas_operation]
              indicates whether each matrix A_i is transposed (conjugated) or not.
    @param[in]
    diag      [rocblas_diagonal]
            - rocblas_diagonal_unit: The main diagonal of each A_i is assumed to consist of only
                                     1's and is not referenced.
            - rocblas_diagonal_non_unit: No assumptions are made of each A_i's main diagonal.
    @param[in]
    n         [rocblas_int]
              the number of rows and columns of the matrix represented by each A_i.
    @param[in]
    k         [rocblas_int]

            if uplo == rocblas_fill_upper, k specifies the number of super-diagonals
            of each matrix A_i.

            if uplo == rocblas_fill_lower, k specifies the number of sub-diagonals
            of each matrix A_i.
            k must satisfy k > 0 && k < lda.
    @param[in]
    A         device array of device pointers storing each banded triangular matrix A_i.

            if uplo == rocblas_fill_upper:
                The matrix represented is an upper banded triangular matrix
                with the main diagonal and k super-diagonals, everything
                else can be assumed to be 0.
                The matrix is compacted so that the main diagonal resides on the k'th
                row, the first super diagonal resides on the RHS of the k-1'th row, etc,
                with the k'th diagonal on the RHS of the 0'th row.
                   Ex: (rocblas_fill_upper; n = 5; k = 2)
                      1 6 9 0 0              0 0 9 8 7
                      0 2 7 8 0              0 6 7 8 9
                      0 0 3 8 7     ---->    1 2 3 4 5
                      0 0 0 4 9              0 0 0 0 0
                      0 0 0 0 5              0 0 0 0 0

            if uplo == rocblas_fill_lower:
                The matrix represented is a lower banded triangular matrix
                with the main diagonal and k sub-diagonals, everything else can be
                assumed to be 0.
                The matrix is compacted so that the main diagonal resides on the 0'th row,
                working up to the k'th diagonal residing on the LHS of the k'th row.
                   Ex: (rocblas_fill_lower; n = 5; k = 2)
                      1 0 0 0 0              1 2 3 4 5
                      6 2 0 0 0              6 7 8 9 0
                      9 7 3 0 0     ---->    9 8 7 0 0
                      0 8 8 4 0              0 0 0 0 0
                      0 0 7 9 5              0 0 0 0 0
    @param[in]
    lda       [rocblas_int]
              specifies the leading dimension of each A_i. lda must satisfy lda > k.
    @param[in, out]
    x         device array of device pointer storing each vector x_i.
    @param[in]
    incx      [rocblas_int]
              specifies the increment for the elements of each x_i.
    @param[in]
    batch_count [rocblas_int]
                number of instances in the batch.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_stbmv_batched",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int32,
            Int32,
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(handle, uplo, trans, diag, n, k, _a, lda, x, incx, batch_count)


fn rocblas_csyr_strided_batched(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat32],
    x: UnsafePointer[ComplexFloat32],
    incx: Int32,
    stridex: Int64,
    _a: UnsafePointer[ComplexFloat32],
    lda: Int32,
    stride_a: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_csyr_strided_batched",
        fn (
            Handle,
            Fill,
            Int32,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle, uplo, n, alpha, x, incx, stridex, _a, lda, stride_a, batch_count
    )


fn rocblas_dsyr2k_strided_batched(
    handle: Handle,
    uplo: Fill,
    trans: Operation,
    n: Int32,
    k: Int32,
    alpha: UnsafePointer[Float64],
    _a: UnsafePointer[Float64],
    lda: Int32,
    stride__a: Int64,
    _b: UnsafePointer[Float64],
    ldb: Int32,
    stride__b: Int64,
    beta: UnsafePointer[Float64],
    _c: UnsafePointer[Float64],
    ldc: Int32,
    stride__c: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_dsyr2k_strided_batched",
        fn (
            Handle,
            Fill,
            Operation,
            Int32,
            Int32,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int32,
            Int64,
            UnsafePointer[Float64],
            Int32,
            Int64,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        uplo,
        trans,
        n,
        k,
        alpha,
        _a,
        lda,
        stride__a,
        _b,
        ldb,
        stride__b,
        beta,
        _c,
        ldc,
        stride__c,
        batch_count,
    )


fn rocblas_dtpmv_64(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int64,
    _a: UnsafePointer[Float64],
    x: UnsafePointer[Float64],
    incx: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_dtpmv_64",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int64,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int64,
        ) -> Status,
    ]()(handle, uplo, trans_a, diag, n, _a, x, incx)


fn rocblas_dgemmt_strided_batched(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    trans_b: Operation,
    n: Int32,
    k: Int32,
    alpha: UnsafePointer[Float64],
    _a: UnsafePointer[Float64],
    lda: Int32,
    stride_a: Int64,
    _b: UnsafePointer[Float64],
    ldb: Int32,
    stride_b: Int64,
    beta: UnsafePointer[Float64],
    _c: UnsafePointer[Float64],
    ldc: Int32,
    stride_c: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_dgemmt_strided_batched",
        fn (
            Handle,
            Fill,
            Operation,
            Operation,
            Int32,
            Int32,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int32,
            Int64,
            UnsafePointer[Float64],
            Int32,
            Int64,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        uplo,
        trans_a,
        trans_b,
        n,
        k,
        alpha,
        _a,
        lda,
        stride_a,
        _b,
        ldb,
        stride_b,
        beta,
        _c,
        ldc,
        stride_c,
        batch_count,
    )


fn rocblas_dtpmv_strided_batched_64(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int64,
    _a: UnsafePointer[Float64],
    stride__a: Int64,
    x: UnsafePointer[Float64],
    incx: Int64,
    stride_x: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_dtpmv_strided_batched_64",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int64,
            UnsafePointer[Float64],
            Int64,
            UnsafePointer[Float64],
            Int64,
            Int64,
            Int64,
        ) -> Status,
    ]()(
        handle,
        uplo,
        trans_a,
        diag,
        n,
        _a,
        stride__a,
        x,
        incx,
        stride_x,
        batch_count,
    )


fn rocblas_sspmv_strided_batched_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    alpha: UnsafePointer[Float32],
    _a: UnsafePointer[Float32],
    stride_a: Int64,
    x: UnsafePointer[Float32],
    incx: Int64,
    stridex: Int64,
    beta: UnsafePointer[Float32],
    y: UnsafePointer[Float32],
    incy: Int64,
    stridey: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_sspmv_strided_batched_64",
        fn (
            Handle,
            Fill,
            Int64,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int64,
            UnsafePointer[Float32],
            Int64,
            Int64,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int64,
            Int64,
            Int64,
        ) -> Status,
    ]()(
        handle,
        uplo,
        n,
        alpha,
        _a,
        stride_a,
        x,
        incx,
        stridex,
        beta,
        y,
        incy,
        stridey,
        batch_count,
    )


fn rocblas_dgemv_64(
    handle: Handle,
    trans: Operation,
    m: Int64,
    n: Int64,
    alpha: UnsafePointer[Float64],
    _a: UnsafePointer[Float64],
    lda: Int64,
    x: UnsafePointer[Float64],
    incx: Int64,
    beta: UnsafePointer[Float64],
    y: UnsafePointer[Float64],
    incy: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_dgemv_64",
        fn (
            Handle,
            Operation,
            Int64,
            Int64,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int64,
            UnsafePointer[Float64],
            Int64,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int64,
        ) -> Status,
    ]()(handle, trans, m, n, alpha, _a, lda, x, incx, beta, y, incy)


fn rocblas_zher2_strided_batched_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    alpha: UnsafePointer[ComplexFloat64],
    x: UnsafePointer[ComplexFloat64],
    incx: Int64,
    stride_x: Int64,
    y: UnsafePointer[ComplexFloat64],
    incy: Int64,
    stride_y: Int64,
    _a: UnsafePointer[ComplexFloat64],
    lda: Int64,
    stride__a: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_zher2_strided_batched_64",
        fn (
            Handle,
            Fill,
            Int64,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int64,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int64,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int64,
            Int64,
            Int64,
        ) -> Status,
    ]()(
        handle,
        uplo,
        n,
        alpha,
        x,
        incx,
        stride_x,
        y,
        incy,
        stride_y,
        _a,
        lda,
        stride__a,
        batch_count,
    )


fn rocblas_strsv(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int32,
    _a: UnsafePointer[Float32],
    lda: Int32,
    x: UnsafePointer[Float32],
    incx: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 2 API </b>.

    \\details
    trsv solves:

         A*x = b or
         A**T*x = b or
         A**H*x = b,
         where x and b are vectors and A is a triangular matrix.
         The vector x is overwritten on b.

    Although not widespread, some gemm kernels used by trsv may use atomic operations.
    See Atomic Operations in the API Reference Guide for more information.

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.

    @param[in]
    uplo    [rocblas_fill]
            - rocblas_fill_upper:  A is an upper triangular matrix.
            - rocblas_fill_lower:  A is a  lower triangular matrix.

    @param[in]
    transA     [rocblas_operation]
            - rocblas_operation_none:    op(A) = A.
            - rocblas_operation_transpose:   op(A) = A^T
            - rocblas_operation_conjugate_transpose:  op(A) = A^H

    @param[in]
    diag    [rocblas_diagonal]
            - rocblas_diagonal_unit:     A is assumed to be unit triangular.
            - rocblas_diagonal_non_unit:  A is not assumed to be unit triangular.

    @param[in]
    n         [rocblas_int]
              n specifies the number of rows of b. n >= 0.

    @param[in]
    A         device pointer storing matrix A, of dimension ( lda, n ). If uplo == rocblas_fill_upper, the upper triangular part of the leading n-by-n array contains the matrix A, otherwise the lower triangular part of the leading n-by-n array contains the matrix A.

    @param[in]
    lda       [rocblas_int]
              specifies the leading dimension of A. lda must be at least max( 1, n ).

    @param[in, out]
    x         device pointer storing vector x. On exit, x is overwritten with the transformed vector x.

    @param[in]
    incx      [rocblas_int]
              specifies the increment for the elements of x.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_strsv",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int32,
            UnsafePointer[Float32],
            Int32,
            UnsafePointer[Float32],
            Int32,
        ) -> Status,
    ]()(handle, uplo, trans_a, diag, n, _a, lda, x, incx)


fn rocblas_hdot_strided_batched(
    handle: Handle,
    n: Int32,
    x: UnsafePointer[Float16],
    incx: Int32,
    stridex: Int64,
    y: UnsafePointer[Float16],
    incy: Int32,
    stridey: Int64,
    batch_count: Int32,
    result: UnsafePointer[Float16],
) -> Status:
    return _get_dylib_function[
        "rocblas_hdot_strided_batched",
        fn (
            Handle,
            Int32,
            UnsafePointer[Float16],
            Int32,
            Int64,
            UnsafePointer[Float16],
            Int32,
            Int64,
            Int32,
            UnsafePointer[Float16],
        ) -> Status,
    ]()(handle, n, x, incx, stridex, y, incy, stridey, batch_count, result)


fn rocblas_ctpsv_strided_batched_64(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int64,
    _ap: UnsafePointer[ComplexFloat32],
    stride__a: Int64,
    x: UnsafePointer[ComplexFloat32],
    incx: Int64,
    stride_x: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_ctpsv_strided_batched_64",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int64,
            UnsafePointer[ComplexFloat32],
            Int64,
            Int64,
            Int64,
        ) -> Status,
    ]()(
        handle,
        uplo,
        trans_a,
        diag,
        n,
        _ap,
        stride__a,
        x,
        incx,
        stride_x,
        batch_count,
    )


fn rocblas_daxpy_64(
    handle: Handle,
    n: Int64,
    alpha: UnsafePointer[Float64],
    x: UnsafePointer[Float64],
    incx: Int64,
    y: UnsafePointer[Float64],
    incy: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_daxpy_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int64,
            UnsafePointer[Float64],
            Int64,
        ) -> Status,
    ]()(handle, n, alpha, x, incx, y, incy)


fn rocblas_dcopy_64(
    handle: Handle,
    n: Int64,
    x: UnsafePointer[Float64],
    incx: Int64,
    y: UnsafePointer[Float64],
    incy: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_dcopy_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[Float64],
            Int64,
            UnsafePointer[Float64],
            Int64,
        ) -> Status,
    ]()(handle, n, x, incx, y, incy)


fn rocblas_ccopy_batched_64(
    handle: Handle,
    n: Int64,
    x: OpaquePointer,
    incx: Int64,
    y: OpaquePointer,
    incy: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_ccopy_batched_64",
        fn (
            Handle,
            Int64,
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, n, x, incx, y, incy, batch_count)


fn rocblas_zrotg_strided_batched_64(
    handle: Handle,
    a: UnsafePointer[ComplexFloat64],
    stride_a: Int64,
    b: UnsafePointer[ComplexFloat64],
    stride_b: Int64,
    c: UnsafePointer[Float64],
    stride_c: Int64,
    s: UnsafePointer[ComplexFloat64],
    stride_s: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_zrotg_strided_batched_64",
        fn (
            Handle,
            UnsafePointer[ComplexFloat64],
            Int64,
            UnsafePointer[ComplexFloat64],
            Int64,
            UnsafePointer[Float64],
            Int64,
            UnsafePointer[ComplexFloat64],
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, a, stride_a, b, stride_b, c, stride_c, s, stride_s, batch_count)


fn rocblas_dznrm2_batched_64(
    handle: Handle,
    n: Int64,
    x: OpaquePointer,
    incx: Int64,
    batch_count: Int64,
    results: UnsafePointer[Float64],
) -> Status:
    return _get_dylib_function[
        "rocblas_dznrm2_batched_64",
        fn (
            Handle,
            Int64,
            OpaquePointer,
            Int64,
            Int64,
            UnsafePointer[Float64],
        ) -> Status,
    ]()(handle, n, x, incx, batch_count, results)


fn rocblas_dzasum_batched(
    handle: Handle,
    n: Int32,
    x: OpaquePointer,
    incx: Int32,
    batch_count: Int32,
    results: UnsafePointer[Float64],
) -> Status:
    return _get_dylib_function[
        "rocblas_dzasum_batched",
        fn (
            Handle,
            Int32,
            OpaquePointer,
            Int32,
            Int32,
            UnsafePointer[Float64],
        ) -> Status,
    ]()(handle, n, x, incx, batch_count, results)


fn rocblas_ztpsv_batched(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int32,
    _ap: OpaquePointer,
    x: OpaquePointer,
    incx: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_ztpsv_batched",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int32,
            OpaquePointer,
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(handle, uplo, trans_a, diag, n, _ap, x, incx, batch_count)


fn rocblas_sspmv_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    alpha: UnsafePointer[Float32],
    _a: UnsafePointer[Float32],
    x: UnsafePointer[Float32],
    incx: Int64,
    beta: UnsafePointer[Float32],
    y: UnsafePointer[Float32],
    incy: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_sspmv_64",
        fn (
            Handle,
            Fill,
            Int64,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int64,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int64,
        ) -> Status,
    ]()(handle, uplo, n, alpha, _a, x, incx, beta, y, incy)


fn rocblas_dgemm_kernel_name(
    handle: Handle,
    trans_a: Operation,
    trans_b: Operation,
    m: Int32,
    n: Int32,
    k: Int32,
    alpha: UnsafePointer[Float64],
    _a: UnsafePointer[Float64],
    lda: Int32,
    stride_a: Int64,
    _b: UnsafePointer[Float64],
    ldb: Int32,
    stride_b: Int64,
    beta: UnsafePointer[Float64],
    _c: UnsafePointer[Float64],
    ldc: Int32,
    stride_c: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_dgemm_kernel_name",
        fn (
            Handle,
            Operation,
            Operation,
            Int32,
            Int32,
            Int32,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int32,
            Int64,
            UnsafePointer[Float64],
            Int32,
            Int64,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        trans_a,
        trans_b,
        m,
        n,
        k,
        alpha,
        _a,
        lda,
        stride_a,
        _b,
        ldb,
        stride_b,
        beta,
        _c,
        ldc,
        stride_c,
        batch_count,
    )


fn rocblas_tssgemv_batched(
    handle: Handle,
    trans: Operation,
    m: Int32,
    n: Int32,
    alpha: UnsafePointer[Float32],
    _a: OpaquePointer,
    lda: Int32,
    x: OpaquePointer,
    incx: Int32,
    beta: UnsafePointer[Float32],
    y: OpaquePointer,
    incy: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_tssgemv_batched",
        fn (
            Handle,
            Operation,
            Int32,
            Int32,
            UnsafePointer[Float32],
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            UnsafePointer[Float32],
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(
        handle, trans, m, n, alpha, _a, lda, x, incx, beta, y, incy, batch_count
    )


fn rocblas_rot_strided_batched_ex(
    handle: Handle,
    n: Int32,
    x: OpaquePointer,
    x_type: DataType,
    incx: Int32,
    stride_x: Int64,
    y: OpaquePointer,
    y_type: DataType,
    incy: Int32,
    stride_y: Int64,
    c: OpaquePointer,
    s: OpaquePointer,
    cs_type: DataType,
    batch_count: Int32,
    execution_type: DataType,
) -> Status:
    """
    \\brief <b> BLAS Level 1 API </b>.

    \\details
    rot_strided_batched_ex applies the Givens rotation matrix defined by c=cos(alpha) and s=sin(alpha) to strided batched vectors x_i and y_i, for i = 1, ..., batch_count.
        Scalars c and s may be stored in either host or device memory. Location is specified by calling rocblas_set_pointer_mode.

    In the case where cs_type is real:

        x := c * x + s * y
        y := c * y - s * x

    In the case where cs_type is complex, the imaginary part of c is ignored:

        x := real(c) * x + s * y
        y := real(c) * y - conj(s) * x

    Currently supported datatypes are as follows:

    ------------------------------------------------
    |  x_type | y_type  | cs_type | execution_type |
    |---------|---------|---------|----------------|
    |  bf16_r |  bf16_r | bf16_r  |  f32_r         |
    |  f16_r  |  f16_r  | f16_r   |  f32_r         |
    |  f32_r  |  f32_r  | f32_r   |  f32_r         |
    |  f64_r  |  f64_r  | f64_r   |  f64_r         |
    |  f32_c  |  f32_c  | f32_c   |  f32_c         |
    |  f32_c  |  f32_c  | f32_r   |  f32_c         |
    |  f64_c  |  f64_c  | f64_c   |  f64_c         |
    |  f64_c  |  f64_c  | f64_r   |  f64_c         |
    ------------------------------------------------

    @param[in]
    handle  [rocblas_handle]
            handle to the rocblas library context queue.
    @param[in]
    n       [rocblas_int]
            number of elements in each x_i and y_i vectors.
    @param[in, out]
    x       device pointer to the first vector x_1.
    @param[in]
    x_type [rocblas_datatype]
           specifies the datatype of each vector x_i.
    @param[in]
    incx    [rocblas_int]
            specifies the increment between elements of each x_i.
    @param[in]
    stride_x [rocblas_stride]
             specifies the increment from the beginning of x_i to the beginning of x_(i+1)
    @param[in, out]
    y       device pointer to the first vector y_1.
    @param[in]
    y_type [rocblas_datatype]
           specifies the datatype of each vector y_i.
    @param[in]
    incy    [rocblas_int]
            specifies the increment between elements of each y_i.
    @param[in]
    stride_y [rocblas_stride]
             specifies the increment from the beginning of y_i to the beginning of y_(i+1)
    @param[in]
    c       device pointer or host pointer to scalar cosine component of the rotation matrix.
    @param[in]
    s       device pointer or host pointer to scalar sine component of the rotation matrix.
    @param[in]
    cs_type [rocblas_datatype]
            specifies the datatype of c and s.
    @param[in]
    batch_count [rocblas_int]
            the number of x and y arrays, the number of batches.
    @param[in]
    execution_type [rocblas_datatype]
                   specifies the datatype of computation.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_rot_strided_batched_ex",
        fn (
            Handle,
            Int32,
            OpaquePointer,
            DataType,
            Int32,
            Int64,
            OpaquePointer,
            DataType,
            Int32,
            Int64,
            OpaquePointer,
            OpaquePointer,
            DataType,
            Int32,
            DataType,
        ) -> Status,
    ]()(
        handle,
        n,
        x,
        x_type,
        incx,
        stride_x,
        y,
        y_type,
        incy,
        stride_y,
        c,
        s,
        cs_type,
        batch_count,
        execution_type,
    )


fn rocblas_csyrkx_batched(
    handle: Handle,
    uplo: Fill,
    trans: Operation,
    n: Int32,
    k: Int32,
    alpha: UnsafePointer[ComplexFloat32],
    _a: OpaquePointer,
    lda: Int32,
    _b: OpaquePointer,
    ldb: Int32,
    beta: UnsafePointer[ComplexFloat32],
    _c: OpaquePointer,
    ldc: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_csyrkx_batched",
        fn (
            Handle,
            Fill,
            Operation,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat32],
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            UnsafePointer[ComplexFloat32],
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(
        handle,
        uplo,
        trans,
        n,
        k,
        alpha,
        _a,
        lda,
        _b,
        ldb,
        beta,
        _c,
        ldc,
        batch_count,
    )


fn rocblas_zhemm(
    handle: Handle,
    side: Side,
    uplo: Fill,
    m: Int32,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat64],
    _a: UnsafePointer[ComplexFloat64],
    lda: Int32,
    _b: UnsafePointer[ComplexFloat64],
    ldb: Int32,
    beta: UnsafePointer[ComplexFloat64],
    _c: UnsafePointer[ComplexFloat64],
    ldc: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_zhemm",
        fn (
            Handle,
            Side,
            Fill,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int32,
            UnsafePointer[ComplexFloat64],
            Int32,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int32,
        ) -> Status,
    ]()(handle, side, uplo, m, n, alpha, _a, lda, _b, ldb, beta, _c, ldc)


fn rocblas_csyr2_batched(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat32],
    x: OpaquePointer,
    incx: Int32,
    y: OpaquePointer,
    incy: Int32,
    _a: OpaquePointer,
    lda: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_csyr2_batched",
        fn (
            Handle,
            Fill,
            Int32,
            UnsafePointer[ComplexFloat32],
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(handle, uplo, n, alpha, x, incx, y, incy, _a, lda, batch_count)


fn rocblas_zsymm_strided_batched(
    handle: Handle,
    side: Side,
    uplo: Fill,
    m: Int32,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat64],
    _a: UnsafePointer[ComplexFloat64],
    lda: Int32,
    stride__a: Int64,
    _b: UnsafePointer[ComplexFloat64],
    ldb: Int32,
    stride__b: Int64,
    beta: UnsafePointer[ComplexFloat64],
    _c: UnsafePointer[ComplexFloat64],
    ldc: Int32,
    stride__c: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_zsymm_strided_batched",
        fn (
            Handle,
            Side,
            Fill,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        side,
        uplo,
        m,
        n,
        alpha,
        _a,
        lda,
        stride__a,
        _b,
        ldb,
        stride__b,
        beta,
        _c,
        ldc,
        stride__c,
        batch_count,
    )


fn rocblas_stbsv_strided_batched(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int32,
    k: Int32,
    _a: UnsafePointer[Float32],
    lda: Int32,
    stride__a: Int64,
    x: UnsafePointer[Float32],
    incx: Int32,
    stride_x: Int64,
    batch_count: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 2 API </b>.

    \\details
    tbsv_strided_batched solves:

         A_i*x_i = b_i or
         A_i**T*x_i = b_i or
         A_i**H*x_i = b_i
         where x_i and b_i are vectors and A_i is a banded triangular matrix,
        for i = [1, batch_count].

    The input vectors b_i are overwritten by the output vectors x_i.

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.

    @param[in]
    uplo    [rocblas_fill]
            - rocblas_fill_upper:  A_i is an upper triangular matrix.
            - rocblas_fill_lower:  A_i is a  lower triangular matrix.

    @param[in]
    transA     [rocblas_operation]
            - rocblas_operation_none: Solves A_i*x_i = b_i
            - rocblas_operation_transpose: Solves A_i**T*x_i = b_i
            - rocblas_operation_conjugate_transpose: Solves A_i**H*x_i = b_i

    @param[in]
    diag    [rocblas_diagonal]
            - rocblas_diagonal_unit:     each A_i is assumed to be unit triangular (i.e. the diagonal elements
            of each A_i are not used in computations).
            - rocblas_diagonal_non_unit: each A_i is not assumed to be unit triangular.

    @param[in]
    n         [rocblas_int]
              n specifies the number of rows of each b_i. n >= 0.
    @param[in]
    k         [rocblas_int]

            if(uplo == rocblas_fill_upper)
                k specifies the number of super-diagonals of each A_i.
            if(uplo == rocblas_fill_lower)
                k specifies the number of sub-diagonals of each A_i.
            k >= 0.

    @param[in]
    A         device pointer pointing to the first banded matrix A_1.

    @param[in]
    lda       [rocblas_int]
              specifies the leading dimension of each A_i.
              lda >= (k + 1).
    @param[in]
    stride_A  [rocblas_stride]
              specifies the distance between the start of one matrix (A_i) and the next (A_i+1).

    @param[in, out]
    x         device pointer pointing to the first input vector b_1. Overwritten by output vectors x.
    @param[in]
    incx      [rocblas_int]
              specifies the increment for the elements of each x_i.
    @param[in]
    stride_x  [rocblas_stride]
              specifies the distance between the start of one vector (x_i) and the next (x_i+1).
    @param[in]
    batch_count [rocblas_int]
                number of instances in the batch.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_stbsv_strided_batched",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int32,
            Int32,
            UnsafePointer[Float32],
            Int32,
            Int64,
            UnsafePointer[Float32],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        uplo,
        trans_a,
        diag,
        n,
        k,
        _a,
        lda,
        stride__a,
        x,
        incx,
        stride_x,
        batch_count,
    )


fn rocblas_stpsv_batched(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int32,
    _ap: OpaquePointer,
    x: OpaquePointer,
    incx: Int32,
    batch_count: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 2 API </b>.

    \\details
    tpsv_batched solves:

         A_i*x_i = b_i or
         A_i**T*x_i = b_i or
         A_i**H*x_i = b_i
        where x_i and b_i are vectors and A_i is a triangular matrix stored in the packed format,
        for i in [1, batch_count].

    The input vectors b_i are overwritten by the output vectors x_i.

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.

    @param[in]
    uplo    [rocblas_fill]
            - rocblas_fill_upper:  each A_i is an upper triangular matrix.
            - rocblas_fill_lower:  each A_i is a  lower triangular matrix.

    @param[in]
    transA  [rocblas_operation]
            - rocblas_operation_none: Solves A*x = b
            - rocblas_operation_transpose: Solves A**T*x = b
            - rocblas_operation_conjugate_transpose: Solves A**H*x = b

    @param[in]
    diag    [rocblas_diagonal]
            - rocblas_diagonal_unit: Each A_i is assumed to be unit triangular (i.e. the diagonal elements
            of each A_i are not used in computations).
            - rocblas_diagonal_non_unit: each A_i is not assumed to be unit triangular.

    @param[in]
    n         [rocblas_int]
              n specifies the number of rows of each b_i. n >= 0.

    @param[in]
    AP        device array of device pointers storing the packed versions of each matrix A_i,
              of dimension >= (n * (n + 1) / 2).

    @param[in, out]
    x         device array of device pointers storing each input vector b_i, overwritten by x_i on output.

    @param[in]
    incx      [rocblas_int]
              specifies the increment for the elements of each x_i.
    @param[in]
    batch_count [rocblas_int]
                specifies the number of instances in the batch.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_stpsv_batched",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int32,
            OpaquePointer,
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(handle, uplo, trans_a, diag, n, _ap, x, incx, batch_count)


fn rocblas_dasum_strided_batched_64(
    handle: Handle,
    n: Int64,
    x: UnsafePointer[Float64],
    incx: Int64,
    stridex: Int64,
    batch_count: Int64,
    results: UnsafePointer[Float64],
) -> Status:
    return _get_dylib_function[
        "rocblas_dasum_strided_batched_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[Float64],
            Int64,
            Int64,
            Int64,
            UnsafePointer[Float64],
        ) -> Status,
    ]()(handle, n, x, incx, stridex, batch_count, results)


fn rocblas_sgbmv_strided_batched(
    handle: Handle,
    trans: Operation,
    m: Int32,
    n: Int32,
    kl: Int32,
    ku: Int32,
    alpha: UnsafePointer[Float32],
    _a: UnsafePointer[Float32],
    lda: Int32,
    stride__a: Int64,
    x: UnsafePointer[Float32],
    incx: Int32,
    stride_x: Int64,
    beta: UnsafePointer[Float32],
    y: UnsafePointer[Float32],
    incy: Int32,
    stride_y: Int64,
    batch_count: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 2 API </b>.

    \\details
    gbmv_strided_batched performs one of the matrix-vector operations:

        y_i := alpha*A_i*x_i    + beta*y_i,   or
        y_i := alpha*A_i**T*x_i + beta*y_i,   or
        y_i := alpha*A_i**H*x_i + beta*y_i,
        where (A_i, x_i, y_i) is the i-th instance of the batch.
        alpha and beta are scalars, x_i and y_i are vectors and A_i is an
        m by n banded matrix with kl sub-diagonals and ku super-diagonals,
        for i = 1, ..., batch_count.

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    trans     [rocblas_operation]
              indicates whether matrix A is transposed (conjugated) or not.
    @param[in]
    m         [rocblas_int]
              number of rows of matrix A.
    @param[in]
    n         [rocblas_int]
              number of columns of matrix A.
    @param[in]
    kl        [rocblas_int]
              number of sub-diagonals of A.
    @param[in]
    ku        [rocblas_int]
              number of super-diagonals of A.
    @param[in]
    alpha     device pointer or host pointer to scalar alpha.
    @param[in]
        A     device pointer to first banded matrix (A_1).
              Leading (kl + ku + 1) by n part of the matrix contains the coefficients
              of the banded matrix. The leading diagonal resides in row (ku + 1) with
              the first super-diagonal above on the RHS of row ku. The first sub-diagonal
              resides below on the LHS of row ku + 2. This propagates up and down across
              sub/super-diagonals.

                    Ex: (m = n = 7; ku = 2, kl = 2)
                    1 2 3 0 0 0 0             0 0 3 3 3 3 3
                    4 1 2 3 0 0 0             0 2 2 2 2 2 2
                    5 4 1 2 3 0 0    ---->    1 1 1 1 1 1 1
                    0 5 4 1 2 3 0             4 4 4 4 4 4 0
                    0 0 5 4 1 2 3             5 5 5 5 5 0 0
                    0 0 0 5 4 1 2             0 0 0 0 0 0 0
                    0 0 0 0 5 4 1             0 0 0 0 0 0 0

              Note that the empty elements which do not correspond to data will not
              be referenced.
    @param[in]
    lda       [rocblas_int]
              specifies the leading dimension of A. Must be >= (kl + ku + 1).
    @param[in]
    stride_A  [rocblas_stride]
              stride from the start of one matrix (A_i) and the next one (A_i+1).
    @param[in]
    x         device pointer to first vector (x_1).
    @param[in]
    incx      [rocblas_int]
              specifies the increment for the elements of x.
    @param[in]
    stride_x  [rocblas_stride]
              stride from the start of one vector (x_i) and the next one (x_i+1).
    @param[in]
    beta      device pointer or host pointer to scalar beta.
    @param[in, out]
    y         device pointer to first vector (y_1).
    @param[in]
    incy      [rocblas_int]
              specifies the increment for the elements of y.
    @param[in]
    stride_y  [rocblas_stride]
              stride from the start of one vector (y_i) and the next one (x_i+1).
    @param[in]
    batch_count [rocblas_int]
                specifies the number of instances in the batch.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_sgbmv_strided_batched",
        fn (
            Handle,
            Operation,
            Int32,
            Int32,
            Int32,
            Int32,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int32,
            Int64,
            UnsafePointer[Float32],
            Int32,
            Int64,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        trans,
        m,
        n,
        kl,
        ku,
        alpha,
        _a,
        lda,
        stride__a,
        x,
        incx,
        stride_x,
        beta,
        y,
        incy,
        stride_y,
        batch_count,
    )


fn rocblas_cdotc_batched(
    handle: Handle,
    n: Int32,
    x: OpaquePointer,
    incx: Int32,
    y: OpaquePointer,
    incy: Int32,
    batch_count: Int32,
    result: UnsafePointer[ComplexFloat32],
) -> Status:
    return _get_dylib_function[
        "rocblas_cdotc_batched",
        fn (
            Handle,
            Int32,
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat32],
        ) -> Status,
    ]()(handle, n, x, incx, y, incy, batch_count, result)


fn rocblas_chpr2_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    alpha: UnsafePointer[ComplexFloat32],
    x: UnsafePointer[ComplexFloat32],
    incx: Int64,
    y: UnsafePointer[ComplexFloat32],
    incy: Int64,
    _ap: UnsafePointer[ComplexFloat32],
) -> Status:
    return _get_dylib_function[
        "rocblas_chpr2_64",
        fn (
            Handle,
            Fill,
            Int64,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int64,
            UnsafePointer[ComplexFloat32],
            Int64,
            UnsafePointer[ComplexFloat32],
        ) -> Status,
    ]()(handle, uplo, n, alpha, x, incx, y, incy, _ap)


fn rocblas_drot_batched_64(
    handle: Handle,
    n: Int64,
    x: OpaquePointer,
    incx: Int64,
    y: OpaquePointer,
    incy: Int64,
    c: UnsafePointer[Float64],
    s: UnsafePointer[Float64],
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_drot_batched_64",
        fn (
            Handle,
            Int64,
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int64,
        ) -> Status,
    ]()(handle, n, x, incx, y, incy, c, s, batch_count)


fn rocblas_dtpsv_strided_batched_64(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int64,
    _ap: UnsafePointer[Float64],
    stride__a: Int64,
    x: UnsafePointer[Float64],
    incx: Int64,
    stride_x: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_dtpsv_strided_batched_64",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int64,
            UnsafePointer[Float64],
            Int64,
            UnsafePointer[Float64],
            Int64,
            Int64,
            Int64,
        ) -> Status,
    ]()(
        handle,
        uplo,
        trans_a,
        diag,
        n,
        _ap,
        stride__a,
        x,
        incx,
        stride_x,
        batch_count,
    )


fn rocblas_strtri(
    handle: Handle,
    uplo: Fill,
    diag: Diagonal,
    n: Int32,
    _a: UnsafePointer[Float32],
    lda: Int32,
    inv_a: UnsafePointer[Float32],
    ldinv_a: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 3 API </b>.

    \\details
    trtri  compute the inverse of a matrix A, namely, invA
    and write the result into invA;

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    uplo      [rocblas_fill]
              specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'

                if rocblas_fill_upper, the lower part of A is not referenced
                if rocblas_fill_lower, the upper part of A is not referenced
    @param[in]
    diag      [rocblas_diagonal]
              - 'rocblas_diagonal_non_unit', A is non-unit triangular;
              - 'rocblas_diagonal_unit', A is unit triangular;
    @param[in]
    n         [rocblas_int]
              size of matrix A and invA.
    @param[in]
    A         device pointer storing matrix A.
    @param[in]
    lda       [rocblas_int]
              specifies the leading dimension of A.
    @param[out]
    invA      device pointer storing matrix invA.
    Partial inplace operation is supported. See below:
            -If UPLO = 'U', the leading N-by-N upper triangular part of the invA will store
                the inverse of the upper triangular matrix, and the strictly lower
                triangular part of invA may be cleared.
            - If UPLO = 'L', the leading N-by-N lower triangular part of the invA will store
                the inverse of the lower triangular matrix, and the strictly upper
                triangular part of invA may be cleared.
    @param[in]
    ldinvA    [rocblas_int]
              specifies the leading dimension of invA.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_strtri",
        fn (
            Handle,
            Fill,
            Diagonal,
            Int32,
            UnsafePointer[Float32],
            Int32,
            UnsafePointer[Float32],
            Int32,
        ) -> Status,
    ]()(handle, uplo, diag, n, _a, lda, inv_a, ldinv_a)


fn rocblas_dot_batched_ex(
    handle: Handle,
    n: Int32,
    x: OpaquePointer,
    x_type: DataType,
    incx: Int32,
    y: OpaquePointer,
    y_type: DataType,
    incy: Int32,
    batch_count: Int32,
    result: OpaquePointer,
    result_type: DataType,
    execution_type: DataType,
) -> Status:
    """
    \\brief <b> BLAS EX API </b>.

    \\details
    dot_batched_ex performs a batch of dot products of vectors x and y.

        result_i = x_i * y_i;

    dotc_batched_ex  performs a batch of dot products of the conjugate of complex vector x and complex vector y

        result_i = conjugate (x_i) * y_i;

    where (x_i, y_i) is the i-th instance of the batch.
    x_i and y_i are vectors, for i = 1, ..., batch_count

    Currently supported datatypes are as follows:

    --------------------------------------------------
    | x_type | y_type | result_type | execution_type |
    |--------|--------|-------------|----------------|
    | f16_r  | f16_r  |    f16_r    |     f16_r      |
    | f16_r  | f16_r  |    f16_r    |     f32_r      |
    | bf16_r | bf16_r |    bf16_r   |     f32_r      |
    | f32_r  | f32_r  |    f32_r    |     f32_r      |
    | f32_r  | f32_r  |    f64_r    |     f64_r      |
    | f64_r  | f64_r  |    f64_r    |     f64_r      |
    | f32_c  | f32_c  |    f32_c    |     f32_c      |
    | f64_c  | f64_c  |    f64_c    |     f64_c      |
    --------------------------------------------------

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    n         [rocblas_int]
              the number of elements in each x_i and y_i.
    @param[in]
    x         device array of device pointers storing each vector x_i.
    @param[in]
    x_type [rocblas_datatype]
           specifies the datatype of each vector x_i.
    @param[in]
    incx      [rocblas_int]
              specifies the increment for the elements of each x_i.
    @param[in]
    y         device array of device pointers storing each vector y_i.
    @param[in]
    y_type [rocblas_datatype]
          specifies the datatype of each vector y_i.
    @param[in]
    incy      [rocblas_int]
              specifies the increment for the elements of each y_i.
    @param[in]
    batch_count [rocblas_int]
                number of instances in the batch.
    @param[in, out]
    result
              device array or host array of batch_count size to store the dot products of each batch.
              return 0.0 for each element if n <= 0.
    @param[in]
    result_type [rocblas_datatype]
                specifies the datatype of the result.
    @param[in]
    execution_type [rocblas_datatype]
                  specifies the datatype of computation.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_dot_batched_ex",
        fn (
            Handle,
            Int32,
            OpaquePointer,
            DataType,
            Int32,
            OpaquePointer,
            DataType,
            Int32,
            Int32,
            OpaquePointer,
            DataType,
            DataType,
        ) -> Status,
    ]()(
        handle,
        n,
        x,
        x_type,
        incx,
        y,
        y_type,
        incy,
        batch_count,
        result,
        result_type,
        execution_type,
    )


fn rocblas_get_version_string_size(len: UnsafePointer[Int]) -> Status:
    """\\brief   Queries the minimum buffer size for a successful call to
    \\ref rocblas_get_version_string.

    \\details

    @param[out]
    len             pointer to size_t for storing the length

    ****************************************************************************.
    """
    return _get_dylib_function[
        "rocblas_get_version_string_size", fn (UnsafePointer[Int]) -> Status
    ]()(len)


fn rocblas_dnrm2(
    handle: Handle,
    n: Int32,
    x: UnsafePointer[Float64],
    incx: Int32,
    result: UnsafePointer[Float64],
) -> Status:
    return _get_dylib_function[
        "rocblas_dnrm2",
        fn (
            Handle, Int32, UnsafePointer[Float64], Int32, UnsafePointer[Float64]
        ) -> Status,
    ]()(handle, n, x, incx, result)


fn rocblas_dscal_64(
    handle: Handle,
    n: Int64,
    alpha: UnsafePointer[Float64],
    x: UnsafePointer[Float64],
    incx: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_dscal_64",
        fn (
            Handle, Int64, UnsafePointer[Float64], UnsafePointer[Float64], Int64
        ) -> Status,
    ]()(handle, n, alpha, x, incx)


fn rocblas_ctpsv_batched_64(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int64,
    _ap: OpaquePointer,
    x: OpaquePointer,
    incx: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_ctpsv_batched_64",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int64,
            OpaquePointer,
            OpaquePointer,
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, uplo, trans_a, diag, n, _ap, x, incx, batch_count)


fn rocblas_isamax_batched_64(
    handle: Handle,
    n: Int64,
    x: OpaquePointer,
    incx: Int64,
    batch_count: Int64,
    result: UnsafePointer[Int64],
) -> Status:
    return _get_dylib_function[
        "rocblas_isamax_batched_64",
        fn (
            Handle,
            Int64,
            OpaquePointer,
            Int64,
            Int64,
            UnsafePointer[Int64],
        ) -> Status,
    ]()(handle, n, x, incx, batch_count, result)


fn rocblas_csyr2_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    alpha: UnsafePointer[ComplexFloat32],
    x: UnsafePointer[ComplexFloat32],
    incx: Int64,
    y: UnsafePointer[ComplexFloat32],
    incy: Int64,
    _a: UnsafePointer[ComplexFloat32],
    lda: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_csyr2_64",
        fn (
            Handle,
            Fill,
            Int64,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int64,
            UnsafePointer[ComplexFloat32],
            Int64,
            UnsafePointer[ComplexFloat32],
            Int64,
        ) -> Status,
    ]()(handle, uplo, n, alpha, x, incx, y, incy, _a, lda)


fn rocblas_zdrot_batched_64(
    handle: Handle,
    n: Int64,
    x: OpaquePointer,
    incx: Int64,
    y: OpaquePointer,
    incy: Int64,
    c: UnsafePointer[Float64],
    s: UnsafePointer[Float64],
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_zdrot_batched_64",
        fn (
            Handle,
            Int64,
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int64,
        ) -> Status,
    ]()(handle, n, x, incx, y, incy, c, s, batch_count)


fn rocblas_dot_ex_64(
    handle: Handle,
    n: Int64,
    x: OpaquePointer,
    x_type: DataType,
    incx: Int64,
    y: OpaquePointer,
    y_type: DataType,
    incy: Int64,
    result: OpaquePointer,
    result_type: DataType,
    execution_type: DataType,
) -> Status:
    return _get_dylib_function[
        "rocblas_dot_ex_64",
        fn (
            Handle,
            Int64,
            OpaquePointer,
            DataType,
            Int64,
            OpaquePointer,
            DataType,
            Int64,
            OpaquePointer,
            DataType,
            DataType,
        ) -> Status,
    ]()(
        handle,
        n,
        x,
        x_type,
        incx,
        y,
        y_type,
        incy,
        result,
        result_type,
        execution_type,
    )


fn rocblas_cgerc_64(
    handle: Handle,
    m: Int64,
    n: Int64,
    alpha: UnsafePointer[ComplexFloat32],
    x: UnsafePointer[ComplexFloat32],
    incx: Int64,
    y: UnsafePointer[ComplexFloat32],
    incy: Int64,
    _a: UnsafePointer[ComplexFloat32],
    lda: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_cgerc_64",
        fn (
            Handle,
            Int64,
            Int64,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int64,
            UnsafePointer[ComplexFloat32],
            Int64,
            UnsafePointer[ComplexFloat32],
            Int64,
        ) -> Status,
    ]()(handle, m, n, alpha, x, incx, y, incy, _a, lda)


fn rocblas_tstgemv_strided_batched(
    handle: Handle,
    trans_a: Operation,
    m: Int32,
    n: Int32,
    alpha: UnsafePointer[Float32],
    _a: UnsafePointer[BFloat16],
    lda: Int32,
    stride_a: Int64,
    x: UnsafePointer[BFloat16],
    incx: Int32,
    stridex: Int64,
    beta: UnsafePointer[Float32],
    y: UnsafePointer[BFloat16],
    incy: Int32,
    stridey: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_tstgemv_strided_batched",
        fn (
            Handle,
            Operation,
            Int32,
            Int32,
            UnsafePointer[Float32],
            UnsafePointer[BFloat16],
            Int32,
            Int64,
            UnsafePointer[BFloat16],
            Int32,
            Int64,
            UnsafePointer[Float32],
            UnsafePointer[BFloat16],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        trans_a,
        m,
        n,
        alpha,
        _a,
        lda,
        stride_a,
        x,
        incx,
        stridex,
        beta,
        y,
        incy,
        stridey,
        batch_count,
    )


fn rocblas_dspmv_strided_batched_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    alpha: UnsafePointer[Float64],
    _a: UnsafePointer[Float64],
    stride_a: Int64,
    x: UnsafePointer[Float64],
    incx: Int64,
    stridex: Int64,
    beta: UnsafePointer[Float64],
    y: UnsafePointer[Float64],
    incy: Int64,
    stridey: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_dspmv_strided_batched_64",
        fn (
            Handle,
            Fill,
            Int64,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int64,
            UnsafePointer[Float64],
            Int64,
            Int64,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int64,
            Int64,
            Int64,
        ) -> Status,
    ]()(
        handle,
        uplo,
        n,
        alpha,
        _a,
        stride_a,
        x,
        incx,
        stridex,
        beta,
        y,
        incy,
        stridey,
        batch_count,
    )


fn rocblas_drotm_strided_batched_64(
    handle: Handle,
    n: Int64,
    x: UnsafePointer[Float64],
    incx: Int64,
    stride_x: Int64,
    y: UnsafePointer[Float64],
    incy: Int64,
    stride_y: Int64,
    param: UnsafePointer[Float64],
    stride_param: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_drotm_strided_batched_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[Float64],
            Int64,
            Int64,
            UnsafePointer[Float64],
            Int64,
            Int64,
            UnsafePointer[Float64],
            Int64,
            Int64,
        ) -> Status,
    ]()(
        handle,
        n,
        x,
        incx,
        stride_x,
        y,
        incy,
        stride_y,
        param,
        stride_param,
        batch_count,
    )


fn rocblas_ztrsv_strided_batched(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int32,
    _a: UnsafePointer[ComplexFloat64],
    lda: Int32,
    stride__a: Int64,
    x: UnsafePointer[ComplexFloat64],
    incx: Int32,
    stride_x: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_ztrsv_strided_batched",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int32,
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        uplo,
        trans_a,
        diag,
        n,
        _a,
        lda,
        stride__a,
        x,
        incx,
        stride_x,
        batch_count,
    )


fn rocblas_ssymv_strided_batched(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    alpha: UnsafePointer[Float32],
    _a: UnsafePointer[Float32],
    lda: Int32,
    stride_a: Int64,
    x: UnsafePointer[Float32],
    incx: Int32,
    stridex: Int64,
    beta: UnsafePointer[Float32],
    y: UnsafePointer[Float32],
    incy: Int32,
    stridey: Int64,
    batch_count: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 2 API </b>.

    \\details
    symv_strided_batched performs the matrix-vector operation:

        y_i := alpha*A_i*x_i + beta*y_i
        where (A_i, x_i, y_i) is the i-th instance of the batch.
        alpha and beta are scalars, x_i and y_i are vectors and A_i is an
        n by n symmetric matrix, for i = 1, ..., batch_count.
        A a should contain an upper or lower triangular symmetric matrix
        and the opposing triangular part of A is not referenced.

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue
    @param[in]
    uplo      [rocblas_fill]
            specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
            - if rocblas_fill_upper, the lower part of A is not referenced
            - if rocblas_fill_lower, the upper part of A is not referenced
    @param[in]
    n         [rocblas_int]
              number of rows and columns of each matrix A_i.
    @param[in]
    alpha
              device pointer or host pointer to scalar alpha.
    @param[in]
    A         Device pointer to the first matrix A_1 on the GPU.
    @param[in]
    lda       [rocblas_int]
              specifies the leading dimension of each matrix A_i.
    @param[in]
    strideA     [rocblas_stride]
                stride from the start of one matrix (A_i) and the next one (A_i+1).
    @param[in]
    x         Device pointer to the first vector x_1 on the GPU.
    @param[in]
    incx      [rocblas_int]
              specifies the increment for the elements of each vector x_i.
    @param[in]
    stridex     [rocblas_stride]
                stride from the start of one vector (x_i) and the next one (x_i+1).
                There are no restrictions placed on stride_x. However, ensure that stridex is of appropriate size.
                This typically means stridex >= n * incx. stridex should be non zero.
    @param[in]
    beta      device pointer or host pointer to scalar beta.
    @param[out]
    y         Device pointer to the first vector y_1 on the GPU.
    @param[in]
    incy      [rocblas_int]
              specifies the increment for the elements of each vector y_i.
    @param[in]
    stridey     [rocblas_stride]
                stride from the start of one vector (y_i) and the next one (y_i+1).
                There are no restrictions placed on stride_y. However, ensure that stridey is of appropriate size.
                This typically means stridey >= n * incy. stridey should be non zero.
    @param[in]
    batch_count [rocblas_int]
                number of instances in the batch.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_ssymv_strided_batched",
        fn (
            Handle,
            Fill,
            Int32,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int32,
            Int64,
            UnsafePointer[Float32],
            Int32,
            Int64,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        uplo,
        n,
        alpha,
        _a,
        lda,
        stride_a,
        x,
        incx,
        stridex,
        beta,
        y,
        incy,
        stridey,
        batch_count,
    )


fn rocblas_axpy_ex_64(
    handle: Handle,
    n: Int64,
    alpha: OpaquePointer,
    alpha_type: DataType,
    x: OpaquePointer,
    x_type: DataType,
    incx: Int64,
    y: OpaquePointer,
    y_type: DataType,
    incy: Int64,
    execution_type: DataType,
) -> Status:
    return _get_dylib_function[
        "rocblas_axpy_ex_64",
        fn (
            Handle,
            Int64,
            OpaquePointer,
            DataType,
            OpaquePointer,
            DataType,
            Int64,
            OpaquePointer,
            DataType,
            Int64,
            DataType,
        ) -> Status,
    ]()(
        handle,
        n,
        alpha,
        alpha_type,
        x,
        x_type,
        incx,
        y,
        y_type,
        incy,
        execution_type,
    )


fn rocblas_drotmg_64(
    handle: Handle,
    d1: UnsafePointer[Float64],
    d2: UnsafePointer[Float64],
    x1: UnsafePointer[Float64],
    y1: UnsafePointer[Float64],
    param: UnsafePointer[Float64],
) -> Status:
    return _get_dylib_function[
        "rocblas_drotmg_64",
        fn (
            Handle,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            UnsafePointer[Float64],
        ) -> Status,
    ]()(handle, d1, d2, x1, y1, param)


fn rocblas_csyr_strided_batched_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    alpha: UnsafePointer[ComplexFloat32],
    x: UnsafePointer[ComplexFloat32],
    incx: Int64,
    stridex: Int64,
    _a: UnsafePointer[ComplexFloat32],
    lda: Int64,
    stride_a: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_csyr_strided_batched_64",
        fn (
            Handle,
            Fill,
            Int64,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int64,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int64,
            Int64,
            Int64,
        ) -> Status,
    ]()(
        handle, uplo, n, alpha, x, incx, stridex, _a, lda, stride_a, batch_count
    )


fn rocblas_dsyrkx_batched(
    handle: Handle,
    uplo: Fill,
    trans: Operation,
    n: Int32,
    k: Int32,
    alpha: UnsafePointer[Float64],
    _a: OpaquePointer,
    lda: Int32,
    _b: OpaquePointer,
    ldb: Int32,
    beta: UnsafePointer[Float64],
    _c: OpaquePointer,
    ldc: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_dsyrkx_batched",
        fn (
            Handle,
            Fill,
            Operation,
            Int32,
            Int32,
            UnsafePointer[Float64],
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            UnsafePointer[Float64],
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(
        handle,
        uplo,
        trans,
        n,
        k,
        alpha,
        _a,
        lda,
        _b,
        ldb,
        beta,
        _c,
        ldc,
        batch_count,
    )


fn rocblas_zhemv_strided_batched_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    alpha: UnsafePointer[ComplexFloat64],
    _a: UnsafePointer[ComplexFloat64],
    lda: Int64,
    stride__a: Int64,
    x: UnsafePointer[ComplexFloat64],
    incx: Int64,
    stride_x: Int64,
    beta: UnsafePointer[ComplexFloat64],
    y: UnsafePointer[ComplexFloat64],
    incy: Int64,
    stride_y: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_zhemv_strided_batched_64",
        fn (
            Handle,
            Fill,
            Int64,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int64,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int64,
            Int64,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int64,
            Int64,
            Int64,
        ) -> Status,
    ]()(
        handle,
        uplo,
        n,
        alpha,
        _a,
        lda,
        stride__a,
        x,
        incx,
        stride_x,
        beta,
        y,
        incy,
        stride_y,
        batch_count,
    )


fn rocblas_ctrsm_batched_64(
    handle: Handle,
    side: Side,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    m: Int64,
    n: Int64,
    alpha: UnsafePointer[ComplexFloat32],
    _a: OpaquePointer,
    lda: Int64,
    _b: OpaquePointer,
    ldb: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_ctrsm_batched_64",
        fn (
            Handle,
            Side,
            Fill,
            Operation,
            Diagonal,
            Int64,
            Int64,
            UnsafePointer[ComplexFloat32],
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            Int64,
        ) -> Status,
    ]()(
        handle,
        side,
        uplo,
        trans_a,
        diag,
        m,
        n,
        alpha,
        _a,
        lda,
        _b,
        ldb,
        batch_count,
    )


fn rocblas_dtrsv_batched_64(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int64,
    _a: OpaquePointer,
    lda: Int64,
    x: OpaquePointer,
    incx: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_dtrsv_batched_64",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int64,
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, uplo, trans_a, diag, n, _a, lda, x, incx, batch_count)


fn rocblas_hdot(
    handle: Handle,
    n: Int32,
    x: UnsafePointer[Float16],
    incx: Int32,
    y: UnsafePointer[Float16],
    incy: Int32,
    result: UnsafePointer[Float16],
) -> Status:
    return _get_dylib_function[
        "rocblas_hdot",
        fn (
            Handle,
            Int32,
            UnsafePointer[Float16],
            Int32,
            UnsafePointer[Float16],
            Int32,
            UnsafePointer[Float16],
        ) -> Status,
    ]()(handle, n, x, incx, y, incy, result)


fn rocblas_srot_batched(
    handle: Handle,
    n: Int32,
    x: OpaquePointer,
    incx: Int32,
    y: OpaquePointer,
    incy: Int32,
    c: UnsafePointer[Float32],
    s: UnsafePointer[Float32],
    batch_count: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 1 API </b>.

    \\details
    rot_batched applies the Givens rotation matrix defined by c=cos(alpha) and s=sin(alpha) to batched vectors x_i and y_i, for i = 1, ..., batch_count.
    Scalars c and s may be stored in either host or device memory. Location is specified by calling rocblas_set_pointer_mode.

    @param[in]
    handle  [rocblas_handle]
            handle to the rocblas library context queue.
    @param[in]
    n       [rocblas_int]
            number of elements in each x_i and y_i vectors.
    @param[in, out]
    x       device array of device pointers storing each vector x_i.
    @param[in]
    incx    [rocblas_int]
            specifies the increment between elements of each x_i.
    @param[in, out]
    y       device array of device pointers storing each vector y_i.
    @param[in]
    incy    [rocblas_int]
            specifies the increment between elements of each y_i.
    @param[in]
    c       device pointer or host pointer to scalar cosine component of the rotation matrix.
    @param[in]
    s       device pointer or host pointer to scalar sine component of the rotation matrix.
    @param[in]
    batch_count [rocblas_int]
                the number of x and y arrays, i.e. the number of batches.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_srot_batched",
        fn (
            Handle,
            Int32,
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int32,
        ) -> Status,
    ]()(handle, n, x, incx, y, incy, c, s, batch_count)


fn rocblas_zher2_strided_batched(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat64],
    x: UnsafePointer[ComplexFloat64],
    incx: Int32,
    stride_x: Int64,
    y: UnsafePointer[ComplexFloat64],
    incy: Int32,
    stride_y: Int64,
    _a: UnsafePointer[ComplexFloat64],
    lda: Int32,
    stride__a: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_zher2_strided_batched",
        fn (
            Handle,
            Fill,
            Int32,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        uplo,
        n,
        alpha,
        x,
        incx,
        stride_x,
        y,
        incy,
        stride_y,
        _a,
        lda,
        stride__a,
        batch_count,
    )


fn rocblas_zsymv_batched_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    alpha: UnsafePointer[ComplexFloat64],
    _a: OpaquePointer,
    lda: Int64,
    x: OpaquePointer,
    incx: Int64,
    beta: UnsafePointer[ComplexFloat64],
    y: OpaquePointer,
    incy: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_zsymv_batched_64",
        fn (
            Handle,
            Fill,
            Int64,
            UnsafePointer[ComplexFloat64],
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            UnsafePointer[ComplexFloat64],
            OpaquePointer,
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, uplo, n, alpha, _a, lda, x, incx, beta, y, incy, batch_count)


fn rocblas_dsbmv_batched(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    k: Int32,
    alpha: UnsafePointer[Float64],
    _a: OpaquePointer,
    lda: Int32,
    x: OpaquePointer,
    incx: Int32,
    beta: UnsafePointer[Float64],
    y: OpaquePointer,
    incy: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_dsbmv_batched",
        fn (
            Handle,
            Fill,
            Int32,
            Int32,
            UnsafePointer[Float64],
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            UnsafePointer[Float64],
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(handle, uplo, n, k, alpha, _a, lda, x, incx, beta, y, incy, batch_count)


fn rocblas_sgemv_strided_batched_64(
    handle: Handle,
    trans_a: Operation,
    m: Int64,
    n: Int64,
    alpha: UnsafePointer[Float32],
    _a: UnsafePointer[Float32],
    lda: Int64,
    stride_a: Int64,
    x: UnsafePointer[Float32],
    incx: Int64,
    stridex: Int64,
    beta: UnsafePointer[Float32],
    y: UnsafePointer[Float32],
    incy: Int64,
    stridey: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_sgemv_strided_batched_64",
        fn (
            Handle,
            Operation,
            Int64,
            Int64,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int64,
            Int64,
            UnsafePointer[Float32],
            Int64,
            Int64,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int64,
            Int64,
            Int64,
        ) -> Status,
    ]()(
        handle,
        trans_a,
        m,
        n,
        alpha,
        _a,
        lda,
        stride_a,
        x,
        incx,
        stridex,
        beta,
        y,
        incy,
        stridey,
        batch_count,
    )


fn rocblas_scopy(
    handle: Handle,
    n: Int32,
    x: UnsafePointer[Float32],
    incx: Int32,
    y: UnsafePointer[Float32],
    incy: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 1 API </b>.

    \\details
    copy  copies each element x[i] into y[i], for  i = 1 , ... , n:

        y := x

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    n         [rocblas_int]
              the number of elements in x to be copied to y.
    @param[in]
    x         device pointer storing vector x.
    @param[in]
    incx      [rocblas_int]
              specifies the increment for the elements of x.
    @param[out]
    y         device pointer storing vector y.
    @param[in]
    incy      [rocblas_int]
              specifies the increment for the elements of y.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_scopy",
        fn (
            Handle,
            Int32,
            UnsafePointer[Float32],
            Int32,
            UnsafePointer[Float32],
            Int32,
        ) -> Status,
    ]()(handle, n, x, incx, y, incy)


fn rocblas_ctrsv_64(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int64,
    _a: UnsafePointer[ComplexFloat32],
    lda: Int64,
    x: UnsafePointer[ComplexFloat32],
    incx: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_ctrsv_64",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int64,
            UnsafePointer[ComplexFloat32],
            Int64,
        ) -> Status,
    ]()(handle, uplo, trans_a, diag, n, _a, lda, x, incx)


fn rocblas_zdotc_64(
    handle: Handle,
    n: Int64,
    x: UnsafePointer[ComplexFloat64],
    incx: Int64,
    y: UnsafePointer[ComplexFloat64],
    incy: Int64,
    result: UnsafePointer[ComplexFloat64],
) -> Status:
    return _get_dylib_function[
        "rocblas_zdotc_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int64,
            UnsafePointer[ComplexFloat64],
            Int64,
            UnsafePointer[ComplexFloat64],
        ) -> Status,
    ]()(handle, n, x, incx, y, incy, result)


fn rocblas_drot_64(
    handle: Handle,
    n: Int64,
    x: UnsafePointer[Float64],
    incx: Int64,
    y: UnsafePointer[Float64],
    incy: Int64,
    c: UnsafePointer[Float64],
    s: UnsafePointer[Float64],
) -> Status:
    return _get_dylib_function[
        "rocblas_drot_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[Float64],
            Int64,
            UnsafePointer[Float64],
            Int64,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
        ) -> Status,
    ]()(handle, n, x, incx, y, incy, c, s)


fn rocblas_zgemmt_strided_batched(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    trans_b: Operation,
    n: Int32,
    k: Int32,
    alpha: UnsafePointer[ComplexFloat64],
    _a: UnsafePointer[ComplexFloat64],
    lda: Int32,
    stride_a: Int64,
    _b: UnsafePointer[ComplexFloat64],
    ldb: Int32,
    stride_b: Int64,
    beta: UnsafePointer[ComplexFloat64],
    _c: UnsafePointer[ComplexFloat64],
    ldc: Int32,
    stride_c: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_zgemmt_strided_batched",
        fn (
            Handle,
            Fill,
            Operation,
            Operation,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        uplo,
        trans_a,
        trans_b,
        n,
        k,
        alpha,
        _a,
        lda,
        stride_a,
        _b,
        ldb,
        stride_b,
        beta,
        _c,
        ldc,
        stride_c,
        batch_count,
    )


fn rocblas_drot_strided_batched_64(
    handle: Handle,
    n: Int64,
    x: UnsafePointer[Float64],
    incx: Int64,
    stride_x: Int64,
    y: UnsafePointer[Float64],
    incy: Int64,
    stride_y: Int64,
    c: UnsafePointer[Float64],
    s: UnsafePointer[Float64],
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_drot_strided_batched_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[Float64],
            Int64,
            Int64,
            UnsafePointer[Float64],
            Int64,
            Int64,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int64,
        ) -> Status,
    ]()(handle, n, x, incx, stride_x, y, incy, stride_y, c, s, batch_count)


fn rocblas_cher2(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat32],
    x: UnsafePointer[ComplexFloat32],
    incx: Int32,
    y: UnsafePointer[ComplexFloat32],
    incy: Int32,
    _a: UnsafePointer[ComplexFloat32],
    lda: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 2 API </b>.

    \\details
    her2 performs the matrix-vector operations:

        A := A + alpha*x*y**H + conj(alpha)*y*x**H
        where alpha is a complex scalar, x and y are vectors, and A is an
        n by n Hermitian matrix.

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    uplo      [rocblas_fill]
            specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
            - rocblas_fill_upper: The upper triangular part of A is supplied.
            - rocblas_fill_lower: The lower triangular part of A is supplied.
    @param[in]
    n         [rocblas_int]
              the number of rows and columns of matrix A. Must be at least 0.
    @param[in]
    alpha
              device pointer or host pointer to scalar alpha.
    @param[in]
    x         device pointer storing vector x.
    @param[in]
    incx      [rocblas_int]
              specifies the increment for the elements of x.
    @param[in]
    y         device pointer storing vector y.
    @param[in]
    incy      [rocblas_int]
              specifies the increment for the elements of y.
    @param[in, out]
    A         device pointer storing the specified triangular portion of
              the Hermitian matrix A. Of size (lda, n).

                    if uplo == rocblas_fill_upper:
                        The upper triangular portion of the Hermitian matrix A is supplied.
                        The lower triangular portion of A will not be touched.

                    if uplo == rocblas_fill_lower:
                        The lower triangular portion of the Hermitian matrix A is supplied.
                        The upper triangular portion of A will not be touched.
                Note that the imaginary part of the diagonal elements are not accessed
                and are assumed to be 0.
    @param[in]
    lda       [rocblas_int]
              specifies the leading dimension of A. Must be at least max(lda, 1).
    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_cher2",
        fn (
            Handle,
            Fill,
            Int32,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int32,
            UnsafePointer[ComplexFloat32],
            Int32,
            UnsafePointer[ComplexFloat32],
            Int32,
        ) -> Status,
    ]()(handle, uplo, n, alpha, x, incx, y, incy, _a, lda)


fn rocblas_ctbsv_64(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int64,
    k: Int64,
    _a: UnsafePointer[ComplexFloat32],
    lda: Int64,
    x: UnsafePointer[ComplexFloat32],
    incx: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_ctbsv_64",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int64,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int64,
            UnsafePointer[ComplexFloat32],
            Int64,
        ) -> Status,
    ]()(handle, uplo, trans_a, diag, n, k, _a, lda, x, incx)


fn rocblas_dspr2_strided_batched_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    alpha: UnsafePointer[Float64],
    x: UnsafePointer[Float64],
    incx: Int64,
    stride_x: Int64,
    y: UnsafePointer[Float64],
    incy: Int64,
    stride_y: Int64,
    _ap: UnsafePointer[Float64],
    stride__a: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_dspr2_strided_batched_64",
        fn (
            Handle,
            Fill,
            Int64,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int64,
            Int64,
            UnsafePointer[Float64],
            Int64,
            Int64,
            UnsafePointer[Float64],
            Int64,
            Int64,
        ) -> Status,
    ]()(
        handle,
        uplo,
        n,
        alpha,
        x,
        incx,
        stride_x,
        y,
        incy,
        stride_y,
        _ap,
        stride__a,
        batch_count,
    )


fn rocblas_cswap_strided_batched_64(
    handle: Handle,
    n: Int64,
    x: UnsafePointer[ComplexFloat32],
    incx: Int64,
    stridex: Int64,
    y: UnsafePointer[ComplexFloat32],
    incy: Int64,
    stridey: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_cswap_strided_batched_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int64,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int64,
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, n, x, incx, stridex, y, incy, stridey, batch_count)


fn rocblas_chemv_strided_batched_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    alpha: UnsafePointer[ComplexFloat32],
    _a: UnsafePointer[ComplexFloat32],
    lda: Int64,
    stride__a: Int64,
    x: UnsafePointer[ComplexFloat32],
    incx: Int64,
    stride_x: Int64,
    beta: UnsafePointer[ComplexFloat32],
    y: UnsafePointer[ComplexFloat32],
    incy: Int64,
    stride_y: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_chemv_strided_batched_64",
        fn (
            Handle,
            Fill,
            Int64,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int64,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int64,
            Int64,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int64,
            Int64,
            Int64,
        ) -> Status,
    ]()(
        handle,
        uplo,
        n,
        alpha,
        _a,
        lda,
        stride__a,
        x,
        incx,
        stride_x,
        beta,
        y,
        incy,
        stride_y,
        batch_count,
    )


fn rocblas_zgerc_batched_64(
    handle: Handle,
    m: Int64,
    n: Int64,
    alpha: UnsafePointer[ComplexFloat64],
    x: OpaquePointer,
    incx: Int64,
    y: OpaquePointer,
    incy: Int64,
    _a: OpaquePointer,
    lda: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_zgerc_batched_64",
        fn (
            Handle,
            Int64,
            Int64,
            UnsafePointer[ComplexFloat64],
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, m, n, alpha, x, incx, y, incy, _a, lda, batch_count)


fn rocblas_zsyr2k_strided_batched(
    handle: Handle,
    uplo: Fill,
    trans: Operation,
    n: Int32,
    k: Int32,
    alpha: UnsafePointer[ComplexFloat64],
    _a: UnsafePointer[ComplexFloat64],
    lda: Int32,
    stride__a: Int64,
    _b: UnsafePointer[ComplexFloat64],
    ldb: Int32,
    stride__b: Int64,
    beta: UnsafePointer[ComplexFloat64],
    _c: UnsafePointer[ComplexFloat64],
    ldc: Int32,
    stride__c: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_zsyr2k_strided_batched",
        fn (
            Handle,
            Fill,
            Operation,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        uplo,
        trans,
        n,
        k,
        alpha,
        _a,
        lda,
        stride__a,
        _b,
        ldb,
        stride__b,
        beta,
        _c,
        ldc,
        stride__c,
        batch_count,
    )


fn rocblas_zher_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    alpha: UnsafePointer[Float64],
    x: UnsafePointer[ComplexFloat64],
    incx: Int64,
    _a: UnsafePointer[ComplexFloat64],
    lda: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_zher_64",
        fn (
            Handle,
            Fill,
            Int64,
            UnsafePointer[Float64],
            UnsafePointer[ComplexFloat64],
            Int64,
            UnsafePointer[ComplexFloat64],
            Int64,
        ) -> Status,
    ]()(handle, uplo, n, alpha, x, incx, _a, lda)


fn rocblas_icamin(
    handle: Handle,
    n: Int32,
    x: UnsafePointer[ComplexFloat32],
    incx: Int32,
    result: UnsafePointer[Int32],
) -> Status:
    return _get_dylib_function[
        "rocblas_icamin",
        fn (
            Handle,
            Int32,
            UnsafePointer[ComplexFloat32],
            Int32,
            UnsafePointer[Int32],
        ) -> Status,
    ]()(handle, n, x, incx, result)


fn rocblas_sasum(
    handle: Handle,
    n: Int32,
    x: UnsafePointer[Float32],
    incx: Int32,
    result: UnsafePointer[Float32],
) -> Status:
    """
    \\brief <b> BLAS Level 1 API </b>.

    \\details
    asum computes the sum of the magnitudes of elements of a real vector x,
    or the sum of magnitudes of the real and imaginary parts of elements if x is a complex vector.

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    n         [rocblas_int]
              the number of elements in x and y.
    @param[in]
    x         device pointer storing vector x.
    @param[in]
    incx      [rocblas_int]
              specifies the increment for the elements of x. incx must be > 0.
    @param[in, out]
    result
              device pointer or host pointer to store the asum product.
              return is 0.0 if n <= 0.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_sasum",
        fn (
            Handle, Int32, UnsafePointer[Float32], Int32, UnsafePointer[Float32]
        ) -> Status,
    ]()(handle, n, x, incx, result)


fn rocblas_dgemmt(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    trans_b: Operation,
    n: Int32,
    k: Int32,
    alpha: UnsafePointer[Float64],
    _a: UnsafePointer[Float64],
    lda: Int32,
    _b: UnsafePointer[Float64],
    ldb: Int32,
    beta: UnsafePointer[Float64],
    _c: UnsafePointer[Float64],
    ldc: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_dgemmt",
        fn (
            Handle,
            Fill,
            Operation,
            Operation,
            Int32,
            Int32,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int32,
            UnsafePointer[Float64],
            Int32,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int32,
        ) -> Status,
    ]()(
        handle,
        uplo,
        trans_a,
        trans_b,
        n,
        k,
        alpha,
        _a,
        lda,
        _b,
        ldb,
        beta,
        _c,
        ldc,
    )


fn rocblas_isamin_batched(
    handle: Handle,
    n: Int32,
    x: OpaquePointer,
    incx: Int32,
    batch_count: Int32,
    result: UnsafePointer[Int32],
) -> Status:
    """
    \\brief <b> BLAS Level 1 API </b>.

    \\details
    amin_batched finds the first index of the element of minimum magnitude of each vector x_i in a batch, for i = 1, ..., batch_count.

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    n         [rocblas_int]
              number of elements in each vector x_i.
    @param[in]
    x         device array of device pointers storing each vector x_i.
    @param[in]
    incx      [rocblas_int]
              specifies the increment for the elements of each x_i. incx must be > 0.
    @param[in]
    batch_count [rocblas_int]
              number of instances in the batch. Must be > 0.
    @param[out]
    result
              device or host pointers to array of batch_count size for results.
              return is 0 if n, incx<=0.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_isamin_batched",
        fn (
            Handle,
            Int32,
            OpaquePointer,
            Int32,
            Int32,
            UnsafePointer[Int32],
        ) -> Status,
    ]()(handle, n, x, incx, batch_count, result)


fn rocblas_drotmg_strided_batched_64(
    handle: Handle,
    d1: UnsafePointer[Float64],
    stride_d1: Int64,
    d2: UnsafePointer[Float64],
    stride_d2: Int64,
    x1: UnsafePointer[Float64],
    stride_x1: Int64,
    y1: UnsafePointer[Float64],
    stride_y1: Int64,
    param: UnsafePointer[Float64],
    stride_param: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_drotmg_strided_batched_64",
        fn (
            Handle,
            UnsafePointer[Float64],
            Int64,
            UnsafePointer[Float64],
            Int64,
            UnsafePointer[Float64],
            Int64,
            UnsafePointer[Float64],
            Int64,
            UnsafePointer[Float64],
            Int64,
            Int64,
        ) -> Status,
    ]()(
        handle,
        d1,
        stride_d1,
        d2,
        stride_d2,
        x1,
        stride_x1,
        y1,
        stride_y1,
        param,
        stride_param,
        batch_count,
    )


fn rocblas_ztrsm_strided_batched(
    handle: Handle,
    side: Side,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    m: Int32,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat64],
    _a: UnsafePointer[ComplexFloat64],
    lda: Int32,
    stride_a: Int64,
    _b: UnsafePointer[ComplexFloat64],
    ldb: Int32,
    stride_b: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_ztrsm_strided_batched",
        fn (
            Handle,
            Side,
            Fill,
            Operation,
            Diagonal,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        side,
        uplo,
        trans_a,
        diag,
        m,
        n,
        alpha,
        _a,
        lda,
        stride_a,
        _b,
        ldb,
        stride_b,
        batch_count,
    )


fn rocblas_dasum_strided_batched(
    handle: Handle,
    n: Int32,
    x: UnsafePointer[Float64],
    incx: Int32,
    stridex: Int64,
    batch_count: Int32,
    results: UnsafePointer[Float64],
) -> Status:
    return _get_dylib_function[
        "rocblas_dasum_strided_batched",
        fn (
            Handle,
            Int32,
            UnsafePointer[Float64],
            Int32,
            Int64,
            Int32,
            UnsafePointer[Float64],
        ) -> Status,
    ]()(handle, n, x, incx, stridex, batch_count, results)


fn rocblas_hshgemv_strided_batched_64(
    handle: Handle,
    trans_a: Operation,
    m: Int64,
    n: Int64,
    alpha: UnsafePointer[Float32],
    _a: UnsafePointer[Float16],
    lda: Int64,
    stride_a: Int64,
    x: UnsafePointer[Float16],
    incx: Int64,
    stridex: Int64,
    beta: UnsafePointer[Float32],
    y: UnsafePointer[Float16],
    incy: Int64,
    stridey: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_hshgemv_strided_batched_64",
        fn (
            Handle,
            Operation,
            Int64,
            Int64,
            UnsafePointer[Float32],
            UnsafePointer[Float16],
            Int64,
            Int64,
            UnsafePointer[Float16],
            Int64,
            Int64,
            UnsafePointer[Float32],
            UnsafePointer[Float16],
            Int64,
            Int64,
            Int64,
        ) -> Status,
    ]()(
        handle,
        trans_a,
        m,
        n,
        alpha,
        _a,
        lda,
        stride_a,
        x,
        incx,
        stridex,
        beta,
        y,
        incy,
        stridey,
        batch_count,
    )


fn rocblas_zher2_batched_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    alpha: UnsafePointer[ComplexFloat64],
    x: OpaquePointer,
    incx: Int64,
    y: OpaquePointer,
    incy: Int64,
    _a: OpaquePointer,
    lda: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_zher2_batched_64",
        fn (
            Handle,
            Fill,
            Int64,
            UnsafePointer[ComplexFloat64],
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, uplo, n, alpha, x, incx, y, incy, _a, lda, batch_count)


fn rocblas_srot_64(
    handle: Handle,
    n: Int64,
    x: UnsafePointer[Float32],
    incx: Int64,
    y: UnsafePointer[Float32],
    incy: Int64,
    c: UnsafePointer[Float32],
    s: UnsafePointer[Float32],
) -> Status:
    return _get_dylib_function[
        "rocblas_srot_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[Float32],
            Int64,
            UnsafePointer[Float32],
            Int64,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
        ) -> Status,
    ]()(handle, n, x, incx, y, incy, c, s)


fn rocblas_hshgemv_strided_batched(
    handle: Handle,
    trans_a: Operation,
    m: Int32,
    n: Int32,
    alpha: UnsafePointer[Float32],
    _a: UnsafePointer[Float16],
    lda: Int32,
    stride_a: Int64,
    x: UnsafePointer[Float16],
    incx: Int32,
    stridex: Int64,
    beta: UnsafePointer[Float32],
    y: UnsafePointer[Float16],
    incy: Int32,
    stridey: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_hshgemv_strided_batched",
        fn (
            Handle,
            Operation,
            Int32,
            Int32,
            UnsafePointer[Float32],
            UnsafePointer[Float16],
            Int32,
            Int64,
            UnsafePointer[Float16],
            Int32,
            Int64,
            UnsafePointer[Float32],
            UnsafePointer[Float16],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        trans_a,
        m,
        n,
        alpha,
        _a,
        lda,
        stride_a,
        x,
        incx,
        stridex,
        beta,
        y,
        incy,
        stridey,
        batch_count,
    )


fn rocblas_ddot_strided_batched(
    handle: Handle,
    n: Int32,
    x: UnsafePointer[Float64],
    incx: Int32,
    stridex: Int64,
    y: UnsafePointer[Float64],
    incy: Int32,
    stridey: Int64,
    batch_count: Int32,
    result: UnsafePointer[Float64],
) -> Status:
    return _get_dylib_function[
        "rocblas_ddot_strided_batched",
        fn (
            Handle,
            Int32,
            UnsafePointer[Float64],
            Int32,
            Int64,
            UnsafePointer[Float64],
            Int32,
            Int64,
            Int32,
            UnsafePointer[Float64],
        ) -> Status,
    ]()(handle, n, x, incx, stridex, y, incy, stridey, batch_count, result)


fn rocblas_izamax_strided_batched_64(
    handle: Handle,
    n: Int64,
    x: UnsafePointer[ComplexFloat64],
    incx: Int64,
    stridex: Int64,
    batch_count: Int64,
    result: UnsafePointer[Int64],
) -> Status:
    return _get_dylib_function[
        "rocblas_izamax_strided_batched_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int64,
            Int64,
            Int64,
            UnsafePointer[Int64],
        ) -> Status,
    ]()(handle, n, x, incx, stridex, batch_count, result)


fn rocblas_crot_strided_batched_64(
    handle: Handle,
    n: Int64,
    x: UnsafePointer[ComplexFloat32],
    incx: Int64,
    stride_x: Int64,
    y: UnsafePointer[ComplexFloat32],
    incy: Int64,
    stride_y: Int64,
    c: UnsafePointer[Float32],
    s: UnsafePointer[ComplexFloat32],
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_crot_strided_batched_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int64,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int64,
            Int64,
            UnsafePointer[Float32],
            UnsafePointer[ComplexFloat32],
            Int64,
        ) -> Status,
    ]()(handle, n, x, incx, stride_x, y, incy, stride_y, c, s, batch_count)


fn rocblas_ztpmv_batched_64(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int64,
    _a: UnsafePointer[UnsafePointer[ComplexFloat64]],
    x: UnsafePointer[UnsafePointer[ComplexFloat64]],
    incx: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_ztpmv_batched_64",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int64,
            UnsafePointer[UnsafePointer[ComplexFloat64]],
            UnsafePointer[UnsafePointer[ComplexFloat64]],
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, uplo, trans_a, diag, n, _a, x, incx, batch_count)


fn rocblas_dsyr_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    alpha: UnsafePointer[Float64],
    x: UnsafePointer[Float64],
    incx: Int64,
    _a: UnsafePointer[Float64],
    lda: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_dsyr_64",
        fn (
            Handle,
            Fill,
            Int64,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int64,
            UnsafePointer[Float64],
            Int64,
        ) -> Status,
    ]()(handle, uplo, n, alpha, x, incx, _a, lda)


fn rocblas_sspmv_batched(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    alpha: UnsafePointer[Float32],
    _a: OpaquePointer,
    x: OpaquePointer,
    incx: Int32,
    beta: UnsafePointer[Float32],
    y: OpaquePointer,
    incy: Int32,
    batch_count: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 2 API </b>.

    \\details
    spmv_batched performs the matrix-vector operation:

        y_i := alpha*A_i*x_i + beta*y_i
        where (A_i, x_i, y_i) is the i-th instance of the batch.
        alpha and beta are scalars, x_i and y_i are vectors and A_i is an
        n by n symmetric matrix, for i = 1, ..., batch_count.
        A should contain an upper or lower triangular n by n packed symmetric matrix.

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    uplo      [rocblas_fill]
            specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
            - if rocblas_fill_upper, the lower part of A is not referenced
            - if rocblas_fill_lower, the upper part of A is not referenced
    @param[in]
    n         [rocblas_int]
              number of rows and columns of each matrix A_i.
    @param[in]
    alpha
              device pointer or host pointer to scalar alpha.
    @param[in]
    A         device array of device pointers storing each matrix A_i.
    @param[in]
    x         device array of device pointers storing each vector x_i.
    @param[in]
    incx      [rocblas_int]
              specifies the increment for the elements of each vector x_i.
    @param[in]
    beta      device pointer or host pointer to scalar beta.
    @param[out]
    y         device array of device pointers storing each vector y_i.
    @param[in]
    incy      [rocblas_int]
              specifies the increment for the elements of each vector y_i.
    @param[in]
    batch_count [rocblas_int]
                number of instances in the batch.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_sspmv_batched",
        fn (
            Handle,
            Fill,
            Int32,
            UnsafePointer[Float32],
            OpaquePointer,
            OpaquePointer,
            Int32,
            UnsafePointer[Float32],
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(handle, uplo, n, alpha, _a, x, incx, beta, y, incy, batch_count)


fn rocblas_ssyr(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    alpha: UnsafePointer[Float32],
    x: UnsafePointer[Float32],
    incx: Int32,
    _a: UnsafePointer[Float32],
    lda: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 2 API </b>.

    \\details
    syr performs the matrix-vector operations:

        A := A + alpha*x*x**T
        where alpha is a scalar, x is a vector, and A is an
        n by n symmetric matrix.

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    uplo      [rocblas_fill]
            specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
            - if rocblas_fill_upper, the lower part of A is not referenced
            - if rocblas_fill_lower, the upper part of A is not referenced

    @param[in]
    n         [rocblas_int]
              the number of rows and columns of matrix A.
    @param[in]
    alpha
              device pointer or host pointer to scalar alpha.
    @param[in]
    x         device pointer storing vector x.
    @param[in]
    incx      [rocblas_int]
              specifies the increment for the elements of x.
    @param[in, out]
    A         device pointer storing matrix A.
    @param[in]
    lda       [rocblas_int]
              specifies the leading dimension of A.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_ssyr",
        fn (
            Handle,
            Fill,
            Int32,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int32,
            UnsafePointer[Float32],
            Int32,
        ) -> Status,
    ]()(handle, uplo, n, alpha, x, incx, _a, lda)


fn rocblas_drotg(
    handle: Handle,
    a: UnsafePointer[Float64],
    b: UnsafePointer[Float64],
    c: UnsafePointer[Float64],
    s: UnsafePointer[Float64],
) -> Status:
    return _get_dylib_function[
        "rocblas_drotg",
        fn (
            Handle,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            UnsafePointer[Float64],
        ) -> Status,
    ]()(handle, a, b, c, s)


fn rocblas_device_malloc_alloc(
    handle: Handle,
    res: UnsafePointer[UnsafePointer[MallocBase]],
    count: Int,
) -> Status:
    return _get_dylib_function[
        "rocblas_device_malloc_alloc",
        fn (
            Handle,
            UnsafePointer[UnsafePointer[MallocBase]],
            Int,
        ) -> Status,
    ]()(handle, res, count)


fn rocblas_ztrmv_batched(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int32,
    _a: UnsafePointer[UnsafePointer[ComplexFloat64]],
    lda: Int32,
    x: UnsafePointer[UnsafePointer[ComplexFloat64]],
    incx: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_ztrmv_batched",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int32,
            UnsafePointer[UnsafePointer[ComplexFloat64]],
            Int32,
            UnsafePointer[UnsafePointer[ComplexFloat64]],
            Int32,
            Int32,
        ) -> Status,
    ]()(handle, uplo, trans_a, diag, n, _a, lda, x, incx, batch_count)


fn rocblas_zgerc_64(
    handle: Handle,
    m: Int64,
    n: Int64,
    alpha: UnsafePointer[ComplexFloat64],
    x: UnsafePointer[ComplexFloat64],
    incx: Int64,
    y: UnsafePointer[ComplexFloat64],
    incy: Int64,
    _a: UnsafePointer[ComplexFloat64],
    lda: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_zgerc_64",
        fn (
            Handle,
            Int64,
            Int64,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int64,
            UnsafePointer[ComplexFloat64],
            Int64,
            UnsafePointer[ComplexFloat64],
            Int64,
        ) -> Status,
    ]()(handle, m, n, alpha, x, incx, y, incy, _a, lda)


fn rocblas_csymm(
    handle: Handle,
    side: Side,
    uplo: Fill,
    m: Int32,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat32],
    _a: UnsafePointer[ComplexFloat32],
    lda: Int32,
    _b: UnsafePointer[ComplexFloat32],
    ldb: Int32,
    beta: UnsafePointer[ComplexFloat32],
    _c: UnsafePointer[ComplexFloat32],
    ldc: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_csymm",
        fn (
            Handle,
            Side,
            Fill,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int32,
            UnsafePointer[ComplexFloat32],
            Int32,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int32,
        ) -> Status,
    ]()(handle, side, uplo, m, n, alpha, _a, lda, _b, ldb, beta, _c, ldc)


fn rocblas_rot_ex_64(
    handle: Handle,
    n: Int64,
    x: OpaquePointer,
    x_type: DataType,
    incx: Int64,
    y: OpaquePointer,
    y_type: DataType,
    incy: Int64,
    c: OpaquePointer,
    s: OpaquePointer,
    cs_type: DataType,
    execution_type: DataType,
) -> Status:
    return _get_dylib_function[
        "rocblas_rot_ex_64",
        fn (
            Handle,
            Int64,
            OpaquePointer,
            DataType,
            Int64,
            OpaquePointer,
            DataType,
            Int64,
            OpaquePointer,
            OpaquePointer,
            DataType,
            DataType,
        ) -> Status,
    ]()(
        handle,
        n,
        x,
        x_type,
        incx,
        y,
        y_type,
        incy,
        c,
        s,
        cs_type,
        execution_type,
    )


fn rocblas_abort() -> NoneType:
    return _get_dylib_function["rocblas_abort", fn () -> NoneType]()()


fn rocblas_dtrmv(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int32,
    _a: UnsafePointer[Float64],
    lda: Int32,
    x: UnsafePointer[Float64],
    incx: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_dtrmv",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int32,
            UnsafePointer[Float64],
            Int32,
            UnsafePointer[Float64],
            Int32,
        ) -> Status,
    ]()(handle, uplo, trans_a, diag, n, _a, lda, x, incx)


fn rocblas_hssgemv_strided_batched_64(
    handle: Handle,
    trans_a: Operation,
    m: Int64,
    n: Int64,
    alpha: UnsafePointer[Float32],
    _a: UnsafePointer[Float16],
    lda: Int64,
    stride_a: Int64,
    x: UnsafePointer[Float16],
    incx: Int64,
    stridex: Int64,
    beta: UnsafePointer[Float32],
    y: UnsafePointer[Float32],
    incy: Int64,
    stridey: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_hssgemv_strided_batched_64",
        fn (
            Handle,
            Operation,
            Int64,
            Int64,
            UnsafePointer[Float32],
            UnsafePointer[Float16],
            Int64,
            Int64,
            UnsafePointer[Float16],
            Int64,
            Int64,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int64,
            Int64,
            Int64,
        ) -> Status,
    ]()(
        handle,
        trans_a,
        m,
        n,
        alpha,
        _a,
        lda,
        stride_a,
        x,
        incx,
        stridex,
        beta,
        y,
        incy,
        stridey,
        batch_count,
    )


fn rocblas_cherkx_batched(
    handle: Handle,
    uplo: Fill,
    trans: Operation,
    n: Int32,
    k: Int32,
    alpha: UnsafePointer[ComplexFloat32],
    _a: OpaquePointer,
    lda: Int32,
    _b: OpaquePointer,
    ldb: Int32,
    beta: UnsafePointer[Float32],
    _c: OpaquePointer,
    ldc: Int32,
    batch_count: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 3 API </b>.

    \\details
    herkx_batched performs a batch of the matrix-matrix operations for a Hermitian rank-k update:

        C_i := alpha*op( A_i )*op( B_i )^H + beta*C_i,

        where  alpha and beta are scalars, op(A_i) and op(B_i) are n by k matrices, and
        C_i is a n x n Hermitian matrix stored as either upper or lower.

    This routine should only be used when the caller can guarantee that the result of op( A )*op( B )^T will be Hermitian.

        op( A_i ) = A_i, op( B_i ) = B_i, and A_i and B_i are n by k if trans == rocblas_operation_none
        op( A_i ) = A_i^H, op( B_i ) = B_i^H,  and A_i and B_i are k by n if trans == rocblas_operation_conjugate_transpose

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.

    @param[in]
    uplo    [rocblas_fill]
            - rocblas_fill_upper:  C_i is an upper triangular matrix
            - rocblas_fill_lower:  C_i is a  lower triangular matrix

    @param[in]
    trans  [rocblas_operation]
            - rocblas_operation_conjugate_transpose: op(A) = A^H
            - rocblas_operation_none:                op(A) = A

    @param[in]
    n       [rocblas_int]
            n specifies the number of rows and columns of C_i. n >= 0.

    @param[in]
    k       [rocblas_int]
            k specifies the number of columns of op(A). k >= 0.

    @param[in]
    alpha
            alpha specifies the scalar alpha. When alpha is
            zero then A is not referenced and A need not be set before
            entry.

    @param[in]
    A       device array of device pointers storing each matrix_i A of dimension (lda, k)
            when trans is rocblas_operation_none, otherwise of dimension (lda, n)

    @param[in]
    lda     [rocblas_int]
            lda specifies the first dimension of A_i.

                if trans = rocblas_operation_none,  lda >= max( 1, n ),
                otherwise lda >= max( 1, k ).

    @param[in]
    B       device array of device pointers storing each matrix_i B of dimension (ldb, k)
            when trans is rocblas_operation_none, otherwise of dimension (ldb, n)

    @param[in]
    ldb     [rocblas_int]
            ldb specifies the first dimension of B_i.

                if trans = rocblas_operation_none,  ldb >= max( 1, n ),
                otherwise ldb >= max( 1, k ).

    @param[in]
    beta
            beta specifies the scalar beta. When beta is
            zero then C need not be set before entry.

    @param[in]
    C       device array of device pointers storing each matrix C_i on the GPU.
            The imaginary component of the diagonal elements are not used but are set to zero unless quick return.
            only the upper/lower triangular part of each C_i is accessed.

    @param[in]
    ldc    [rocblas_int]
           ldc specifies the first dimension of C. ldc >= max( 1, n ).

    @param[in]
    batch_count [rocblas_int]
                number of instances in the batch.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_cherkx_batched",
        fn (
            Handle,
            Fill,
            Operation,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat32],
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            UnsafePointer[Float32],
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(
        handle,
        uplo,
        trans,
        n,
        k,
        alpha,
        _a,
        lda,
        _b,
        ldb,
        beta,
        _c,
        ldc,
        batch_count,
    )


fn rocblas_cdotc_strided_batched_64(
    handle: Handle,
    n: Int64,
    x: UnsafePointer[ComplexFloat32],
    incx: Int64,
    stridex: Int64,
    y: UnsafePointer[ComplexFloat32],
    incy: Int64,
    stridey: Int64,
    batch_count: Int64,
    result: UnsafePointer[ComplexFloat32],
) -> Status:
    return _get_dylib_function[
        "rocblas_cdotc_strided_batched_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int64,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int64,
            Int64,
            Int64,
            UnsafePointer[ComplexFloat32],
        ) -> Status,
    ]()(handle, n, x, incx, stridex, y, incy, stridey, batch_count, result)


fn rocblas_sswap_strided_batched(
    handle: Handle,
    n: Int32,
    x: UnsafePointer[Float32],
    incx: Int32,
    stridex: Int64,
    y: UnsafePointer[Float32],
    incy: Int32,
    stridey: Int64,
    batch_count: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 1 API </b>.

    \\details
    swap_strided_batched interchanges vectors x_i and y_i, for i = 1 , ... , batch_count:

        y_i := x_i;
        x_i := y_i

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    n         [rocblas_int]
              the number of elements in each x_i and y_i.
    @param[in, out]
    x         device pointer to the first vector x_1.
    @param[in]
    incx      [rocblas_int]
              specifies the increment for the elements of x.
    @param[in]
    stridex   [rocblas_stride]
              stride from the start of one vector (x_i) and the next one (x_i+1).
              There are no restrictions placed on stride_x. However, ensure that stride_x is of appropriate size. For a typical
              case this means stride_x >= n * incx.
    @param[in, out]
    y         device pointer to the first vector y_1.
    @param[in]
    incy      [rocblas_int]
              specifies the increment for the elements of y.
    @param[in]
    stridey   [rocblas_stride]
              stride from the start of one vector (y_i) and the next one (y_i+1).
              There are no restrictions placed on stride_x. However, ensure that stride_y is of appropriate size. For a typical
              case this means stride_y >= n * incy. stridey should be non zero.
     @param[in]
     batch_count [rocblas_int]
                 number of instances in the batch.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_sswap_strided_batched",
        fn (
            Handle,
            Int32,
            UnsafePointer[Float32],
            Int32,
            Int64,
            UnsafePointer[Float32],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(handle, n, x, incx, stridex, y, incy, stridey, batch_count)


fn rocblas_dsymm_strided_batched(
    handle: Handle,
    side: Side,
    uplo: Fill,
    m: Int32,
    n: Int32,
    alpha: UnsafePointer[Float64],
    _a: UnsafePointer[Float64],
    lda: Int32,
    stride__a: Int64,
    _b: UnsafePointer[Float64],
    ldb: Int32,
    stride__b: Int64,
    beta: UnsafePointer[Float64],
    _c: UnsafePointer[Float64],
    ldc: Int32,
    stride__c: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_dsymm_strided_batched",
        fn (
            Handle,
            Side,
            Fill,
            Int32,
            Int32,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int32,
            Int64,
            UnsafePointer[Float64],
            Int32,
            Int64,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        side,
        uplo,
        m,
        n,
        alpha,
        _a,
        lda,
        stride__a,
        _b,
        ldb,
        stride__b,
        beta,
        _c,
        ldc,
        stride__c,
        batch_count,
    )


fn rocblas_scasum_strided_batched(
    handle: Handle,
    n: Int32,
    x: UnsafePointer[ComplexFloat32],
    incx: Int32,
    stridex: Int64,
    batch_count: Int32,
    results: UnsafePointer[Float32],
) -> Status:
    return _get_dylib_function[
        "rocblas_scasum_strided_batched",
        fn (
            Handle,
            Int32,
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            Int32,
            UnsafePointer[Float32],
        ) -> Status,
    ]()(handle, n, x, incx, stridex, batch_count, results)


fn rocblas_ssyr_batched(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    alpha: UnsafePointer[Float32],
    x: OpaquePointer,
    incx: Int32,
    _a: OpaquePointer,
    lda: Int32,
    batch_count: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 2 API </b>.

    \\details
    syr_batched performs a batch of matrix-vector operations:

        A[i] := A[i] + alpha*x[i]*x[i]**T
        where alpha is a scalar, x is an array of vectors, and A is an array of
        n by n symmetric matrices, for i = 1 , ... , batch_count.

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    uplo      [rocblas_fill]
            specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
            - if rocblas_fill_upper, the lower part of A is not referenced
            - if rocblas_fill_lower, the upper part of A is not referenced
    @param[in]
    n         [rocblas_int]
              the number of rows and columns of matrix A.
    @param[in]
    alpha
              device pointer or host pointer to scalar alpha.
    @param[in]
    x         device array of device pointers storing each vector x_i.
    @param[in]
    incx      [rocblas_int]
              specifies the increment for the elements of each x_i.
    @param[in, out]
    A         device array of device pointers storing each matrix A_i.
    @param[in]
    lda       [rocblas_int]
              specifies the leading dimension of each A_i.
    @param[in]
    batch_count [rocblas_int]
                number of instances in the batch.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_ssyr_batched",
        fn (
            Handle,
            Fill,
            Int32,
            UnsafePointer[Float32],
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(handle, uplo, n, alpha, x, incx, _a, lda, batch_count)


fn rocblas_dtbmv_batched(
    handle: Handle,
    uplo: Fill,
    trans: Operation,
    diag: Diagonal,
    n: Int32,
    k: Int32,
    _a: OpaquePointer,
    lda: Int32,
    x: OpaquePointer,
    incx: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_dtbmv_batched",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int32,
            Int32,
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(handle, uplo, trans, diag, n, k, _a, lda, x, incx, batch_count)


fn rocblas_ctrmm_strided_batched(
    handle: Handle,
    side: Side,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    m: Int32,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat32],
    _a: UnsafePointer[ComplexFloat32],
    lda: Int32,
    stride__a: Int64,
    _b: UnsafePointer[ComplexFloat32],
    ldb: Int32,
    stride__b: Int64,
    _c: UnsafePointer[ComplexFloat32],
    ldc: Int32,
    stride__c: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_ctrmm_strided_batched",
        fn (
            Handle,
            Side,
            Fill,
            Operation,
            Diagonal,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        side,
        uplo,
        trans_a,
        diag,
        m,
        n,
        alpha,
        _a,
        lda,
        stride__a,
        _b,
        ldb,
        stride__b,
        _c,
        ldc,
        stride__c,
        batch_count,
    )


fn rocblas_cdotc_batched_64(
    handle: Handle,
    n: Int64,
    x: OpaquePointer,
    incx: Int64,
    y: OpaquePointer,
    incy: Int64,
    batch_count: Int64,
    result: UnsafePointer[ComplexFloat32],
) -> Status:
    return _get_dylib_function[
        "rocblas_cdotc_batched_64",
        fn (
            Handle,
            Int64,
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            Int64,
            UnsafePointer[ComplexFloat32],
        ) -> Status,
    ]()(handle, n, x, incx, y, incy, batch_count, result)


fn rocblas_zgeam_strided_batched(
    handle: Handle,
    trans_a: Operation,
    trans_b: Operation,
    m: Int32,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat64],
    _a: UnsafePointer[ComplexFloat64],
    lda: Int32,
    stride__a: Int64,
    beta: UnsafePointer[ComplexFloat64],
    _b: UnsafePointer[ComplexFloat64],
    ldb: Int32,
    stride__b: Int64,
    _c: UnsafePointer[ComplexFloat64],
    ldc: Int32,
    stride__c: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_zgeam_strided_batched",
        fn (
            Handle,
            Operation,
            Operation,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        trans_a,
        trans_b,
        m,
        n,
        alpha,
        _a,
        lda,
        stride__a,
        beta,
        _b,
        ldb,
        stride__b,
        _c,
        ldc,
        stride__c,
        batch_count,
    )


fn rocblas_ccopy_strided_batched(
    handle: Handle,
    n: Int32,
    x: UnsafePointer[ComplexFloat32],
    incx: Int32,
    stridex: Int64,
    y: UnsafePointer[ComplexFloat32],
    incy: Int32,
    stridey: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_ccopy_strided_batched",
        fn (
            Handle,
            Int32,
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(handle, n, x, incx, stridex, y, incy, stridey, batch_count)


fn rocblas_ztrmv_strided_batched(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int32,
    _a: UnsafePointer[ComplexFloat64],
    lda: Int32,
    stride__a: Int64,
    x: UnsafePointer[ComplexFloat64],
    incx: Int32,
    stride_x: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_ztrmv_strided_batched",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int32,
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        uplo,
        trans_a,
        diag,
        n,
        _a,
        lda,
        stride__a,
        x,
        incx,
        stride_x,
        batch_count,
    )


fn rocblas_dtrtri_strided_batched(
    handle: Handle,
    uplo: Fill,
    diag: Diagonal,
    n: Int32,
    _a: UnsafePointer[Float64],
    lda: Int32,
    stride_a: Int64,
    inv_a: UnsafePointer[Float64],
    ldinv_a: Int32,
    stride_inv_a: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_dtrtri_strided_batched",
        fn (
            Handle,
            Fill,
            Diagonal,
            Int32,
            UnsafePointer[Float64],
            Int32,
            Int64,
            UnsafePointer[Float64],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        uplo,
        diag,
        n,
        _a,
        lda,
        stride_a,
        inv_a,
        ldinv_a,
        stride_inv_a,
        batch_count,
    )


fn rocblas_geam_ex(
    handle: Handle,
    trans_a: Operation,
    trans_b: Operation,
    m: Int32,
    n: Int32,
    k: Int32,
    alpha: OpaquePointer,
    _a: OpaquePointer,
    a_type: DataType,
    lda: Int32,
    _b: OpaquePointer,
    b_type: DataType,
    ldb: Int32,
    beta: OpaquePointer,
    _c: OpaquePointer,
    c_type: DataType,
    ldc: Int32,
    _d: OpaquePointer,
    d_type: DataType,
    ldd: Int32,
    compute_type: DataType,
    geam_ex_op: GEAMExOp,
) -> Status:
    """
    \\brief <b> BLAS EX API </b>.

    \\details
    geam_ex performs one of the matrix-matrix operations:

        Dij = min(alpha * (Aik + Bkj), beta * Cij)
        Dij = min(alpha * Aik, alpha * Bkj) + beta * Cij

    alpha and beta are scalars, and A, B, C, and D are matrices, with
    op( A ) an m by k matrix, op( B ) a k by n matrix and C and D are m by n matrices.
    C and D may point to the same matrix if their type and leading dimensions are identical.

    Aik refers to the element at the i-th row and k-th column of op( A ), Bkj refers to
    the element at the k-th row and j-th column of op( B ), and Cij/Dij refers to the element
    at the i-th row and j-th column of C/D.

    Supported types are as follows:
        - rocblas_datatype_f64_r = a_type = b_type = c_type = d_type = compute_type
        - rocblas_datatype_f32_r = a_type = b_type = c_type = d_type = compute_type
        - rocblas_datatype_f16_r = a_type = b_type = c_type = d_type = compute_type

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    transA    [rocblas_operation]
              specifies the form of op( A ).
    @param[in]
    transB    [rocblas_operation]
              specifies the form of op( B ).
    @param[in]
    m         [rocblas_int]
              matrix dimension m.
    @param[in]
    n         [rocblas_int]
              matrix dimension n.
    @param[in]
    k         [rocblas_int]
              matrix dimension k.
    @param[in]
    alpha     [const void *]
              device pointer or host pointer specifying the scalar alpha. Same datatype as compute_type.
    @param[in]
    A         [void *]
              device pointer storing matrix A.
    @param[in]
    a_type    [rocblas_datatype]
              specifies the datatype of matrix A.
    @param[in]
    lda       [rocblas_int]
              specifies the leading dimension of A

              if transA == N, must have lda >= max(1, m)
              otherwise, must have lda >= max(1, k)
    @param[in]
    B         [void *]
              device pointer storing matrix B.
    @param[in]
    b_type    [rocblas_datatype]
              specifies the datatype of matrix B.
    @param[in]
    ldb       [rocblas_int]
              specifies the leading dimension of B

              if transB == N, must have ldb >= max(1, k)
              otherwise, must have ldb >= max(1, n)
    @param[in]
    beta      [const void *]
              device pointer or host pointer specifying the scalar beta. Same datatype as compute_type.
    @param[in]
    C         [void *]
              device pointer storing matrix C.
    @param[in]
    c_type    [rocblas_datatype]
              specifies the datatype of matrix C.
    @param[in]
    ldc       [rocblas_int]
              specifies the leading dimension of C, must have ldc >= max(1, m).
    @param[out]
    D         [void *]
              device pointer storing matrix D.
              If D and C pointers are to the same matrix then d_type must equal c_type and ldd must equal ldc
              or the respective invalid status will be returned.
    @param[in]
    d_type    [rocblas_datatype]
              specifies the datatype of matrix D.
    @param[in]
    ldd       [rocblas_int]
              specifies the leading dimension of D, must have ldd >= max(1, m).
    @param[in]
    compute_type
              [rocblas_datatype]
              specifies the datatype of computation.
    @param[in]
    geam_ex_op [rocblas_geam_ex_operation]
              enumerant specifying the operation type, support for GEAMExOpmin_plus and GEAMExOpplus_min.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_geam_ex",
        fn (
            Handle,
            Operation,
            Operation,
            Int32,
            Int32,
            Int32,
            OpaquePointer,
            OpaquePointer,
            DataType,
            Int32,
            OpaquePointer,
            DataType,
            Int32,
            OpaquePointer,
            OpaquePointer,
            DataType,
            Int32,
            OpaquePointer,
            DataType,
            Int32,
            DataType,
            GEAMExOp,
        ) -> Status,
    ]()(
        handle,
        trans_a,
        trans_b,
        m,
        n,
        k,
        alpha,
        _a,
        a_type,
        lda,
        _b,
        b_type,
        ldb,
        beta,
        _c,
        c_type,
        ldc,
        _d,
        d_type,
        ldd,
        compute_type,
        geam_ex_op,
    )


fn rocblas_ctbmv(
    handle: Handle,
    uplo: Fill,
    trans: Operation,
    diag: Diagonal,
    n: Int32,
    k: Int32,
    _a: UnsafePointer[ComplexFloat32],
    lda: Int32,
    x: UnsafePointer[ComplexFloat32],
    incx: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_ctbmv",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat32],
            Int32,
            UnsafePointer[ComplexFloat32],
            Int32,
        ) -> Status,
    ]()(handle, uplo, trans, diag, n, k, _a, lda, x, incx)


fn rocblas_is_user_managing_device_memory(handle: Handle) -> Bool:
    """\\brief
    \\details
    Returns true when device memory in handle is managed by the user
    @param[in]
    handle          rocblas handle
    ****************************************************************************.
    """
    return _get_dylib_function[
        "rocblas_is_user_managing_device_memory", fn (Handle) -> Bool
    ]()(handle)


fn rocblas_dtrsv_batched(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int32,
    _a: OpaquePointer,
    lda: Int32,
    x: OpaquePointer,
    incx: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_dtrsv_batched",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int32,
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(handle, uplo, trans_a, diag, n, _a, lda, x, incx, batch_count)


fn rocblas_cswap_batched_64(
    handle: Handle,
    n: Int64,
    x: OpaquePointer,
    incx: Int64,
    y: OpaquePointer,
    incy: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_cswap_batched_64",
        fn (
            Handle,
            Int64,
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, n, x, incx, y, incy, batch_count)


fn rocblas_dnrm2_strided_batched(
    handle: Handle,
    n: Int32,
    x: UnsafePointer[Float64],
    incx: Int32,
    stridex: Int64,
    batch_count: Int32,
    results: UnsafePointer[Float64],
) -> Status:
    return _get_dylib_function[
        "rocblas_dnrm2_strided_batched",
        fn (
            Handle,
            Int32,
            UnsafePointer[Float64],
            Int32,
            Int64,
            Int32,
            UnsafePointer[Float64],
        ) -> Status,
    ]()(handle, n, x, incx, stridex, batch_count, results)


fn rocblas_axpy_batched_ex_64(
    handle: Handle,
    n: Int64,
    alpha: OpaquePointer,
    alpha_type: DataType,
    x: OpaquePointer,
    x_type: DataType,
    incx: Int64,
    y: OpaquePointer,
    y_type: DataType,
    incy: Int64,
    batch_count: Int64,
    execution_type: DataType,
) -> Status:
    return _get_dylib_function[
        "rocblas_axpy_batched_ex_64",
        fn (
            Handle,
            Int64,
            OpaquePointer,
            DataType,
            OpaquePointer,
            DataType,
            Int64,
            OpaquePointer,
            DataType,
            Int64,
            Int64,
            DataType,
        ) -> Status,
    ]()(
        handle,
        n,
        alpha,
        alpha_type,
        x,
        x_type,
        incx,
        y,
        y_type,
        incy,
        batch_count,
        execution_type,
    )


fn rocblas_csymv_strided_batched_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    alpha: UnsafePointer[ComplexFloat32],
    _a: UnsafePointer[ComplexFloat32],
    lda: Int64,
    stride_a: Int64,
    x: UnsafePointer[ComplexFloat32],
    incx: Int64,
    stridex: Int64,
    beta: UnsafePointer[ComplexFloat32],
    y: UnsafePointer[ComplexFloat32],
    incy: Int64,
    stridey: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_csymv_strided_batched_64",
        fn (
            Handle,
            Fill,
            Int64,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int64,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int64,
            Int64,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int64,
            Int64,
            Int64,
        ) -> Status,
    ]()(
        handle,
        uplo,
        n,
        alpha,
        _a,
        lda,
        stride_a,
        x,
        incx,
        stridex,
        beta,
        y,
        incy,
        stridey,
        batch_count,
    )


fn rocblas_dtrmm(
    handle: Handle,
    side: Side,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    m: Int32,
    n: Int32,
    alpha: UnsafePointer[Float64],
    _a: UnsafePointer[Float64],
    lda: Int32,
    _b: UnsafePointer[Float64],
    ldb: Int32,
    _c: UnsafePointer[Float64],
    ldc: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_dtrmm",
        fn (
            Handle,
            Side,
            Fill,
            Operation,
            Diagonal,
            Int32,
            Int32,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int32,
            UnsafePointer[Float64],
            Int32,
            UnsafePointer[Float64],
            Int32,
        ) -> Status,
    ]()(
        handle,
        side,
        uplo,
        trans_a,
        diag,
        m,
        n,
        alpha,
        _a,
        lda,
        _b,
        ldb,
        _c,
        ldc,
    )


fn rocblas_chpr_strided_batched(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    alpha: UnsafePointer[Float32],
    x: UnsafePointer[ComplexFloat32],
    incx: Int32,
    stride_x: Int64,
    _ap: UnsafePointer[ComplexFloat32],
    stride__a: Int64,
    batch_count: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 2 API </b>.

    \\details
    hpr_strided_batched performs the matrix-vector operations:

        A_i := A_i + alpha*x_i*x_i**H
        where alpha is a real scalar, x_i is a vector, and A_i is an
        n by n symmetric matrix, supplied in packed form, for i = 1, ..., batch_count.

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    uplo      [rocblas_fill]
            specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
            - rocblas_fill_upper: The upper triangular part of each A_i is supplied in AP.
            - rocblas_fill_lower: The lower triangular part of each A_i is supplied in AP.
    @param[in]
    n         [rocblas_int]
              the number of rows and columns of each matrix A_i. Must be at least 0.
    @param[in]
    alpha
              device pointer or host pointer to scalar alpha.
    @param[in]
    x         device pointer pointing to the first vector (x_1).
    @param[in]
    incx      [rocblas_int]
              specifies the increment for the elements of each x_i.
    @param[in]
    stride_x  [rocblas_stride]
              stride from the start of one vector (x_i) and the next one (x_i+1).
    @param[in, out]
    AP        device array of device pointers storing the packed version of the specified triangular portion of
              each Hermitian matrix A_i. Points to the first matrix (A_1).

                    if uplo == rocblas_fill_upper:
                        The upper triangular portion of each Hermitian matrix A_i is supplied.
                        The matrix is compacted so that AP contains the triangular portion
                        column-by-column
                        so that:
                        AP(0) = A(0,0)
                        AP(1) = A(0,1)
                        AP(2) = A(1,1), etc.
                        Ex: (rocblas_fill_upper; n = 3)
                            (1, 0) (2, 1) (4,9)
                            (2,-1) (3, 0) (5,3) ---> [(1,0),(2,1),(3,0),(4,9),(5,3),(6,0)]
                            (4,-9) (5,-3) (6,0)

                    if uplo == rocblas_fill_lower:
                        The lower triangular portion of each Hermitian matrix A_i is supplied.
                        The matrix is compacted so that AP contains the triangular portion
                        column-by-column
                        so that:
                        AP(0) = A(0,0)
                        AP(1) = A(1,0)
                        AP(2) = A(2,1), etc.
                        Ex: (rocblas_fill_lower; n = 3)
                            (1, 0) (2, 1) (4,9)
                            (2,-1) (3, 0) (5,3) ---> [(1,0),(2,-1),(4,-9),(3,0),(5,-3),(6,0)]
                            (4,-9) (5,-3) (6,0)
                    Note that the imaginary part of the diagonal elements are not accessed
                    and are assumed to be 0.
    @param[in]
    stride_A    [rocblas_stride]
                stride from the start of one (A_i) and the next (A_i+1).
    @param[in]
    batch_count [rocblas_int]
                number of instances in the batch.
    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_chpr_strided_batched",
        fn (
            Handle,
            Fill,
            Int32,
            UnsafePointer[Float32],
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int64,
            Int32,
        ) -> Status,
    ]()(handle, uplo, n, alpha, x, incx, stride_x, _ap, stride__a, batch_count)


fn rocblas_strmv_batched_64(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int64,
    _a: UnsafePointer[UnsafePointer[Float32]],
    lda: Int64,
    x: UnsafePointer[UnsafePointer[Float32]],
    incx: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_strmv_batched_64",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int64,
            UnsafePointer[UnsafePointer[Float32]],
            Int64,
            UnsafePointer[UnsafePointer[Float32]],
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, uplo, trans_a, diag, n, _a, lda, x, incx, batch_count)


fn rocblas_csymv_batched_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    alpha: UnsafePointer[ComplexFloat32],
    _a: OpaquePointer,
    lda: Int64,
    x: OpaquePointer,
    incx: Int64,
    beta: UnsafePointer[ComplexFloat32],
    y: OpaquePointer,
    incy: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_csymv_batched_64",
        fn (
            Handle,
            Fill,
            Int64,
            UnsafePointer[ComplexFloat32],
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            UnsafePointer[ComplexFloat32],
            OpaquePointer,
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, uplo, n, alpha, _a, lda, x, incx, beta, y, incy, batch_count)


fn rocblas_chemm(
    handle: Handle,
    side: Side,
    uplo: Fill,
    m: Int32,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat32],
    _a: UnsafePointer[ComplexFloat32],
    lda: Int32,
    _b: UnsafePointer[ComplexFloat32],
    ldb: Int32,
    beta: UnsafePointer[ComplexFloat32],
    _c: UnsafePointer[ComplexFloat32],
    ldc: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 3 API </b>.

    \\details
    hemm performs one of the matrix-matrix operations:

        C := alpha*A*B + beta*C if side == rocblas_side_left,
        C := alpha*B*A + beta*C if side == rocblas_side_right,

        where alpha and beta are scalars, B and C are m by n matrices, and
        A is a Hermitian matrix stored as either upper or lower.

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.

    @param[in]
    side  [rocblas_side]
            - rocblas_side_left:      C := alpha*A*B + beta*C
            - rocblas_side_right:     C := alpha*B*A + beta*C

    @param[in]
    uplo    [rocblas_fill]
            - rocblas_fill_upper:  A is an upper triangular matrix
            - rocblas_fill_lower:  A is a  lower triangular matrix

    @param[in]
    m       [rocblas_int]
            m specifies the number of rows of B and C. m >= 0.

    @param[in]
    n       [rocblas_int]
            n specifies the number of columns of B and C. n >= 0.

    @param[in]
    alpha
            alpha specifies the scalar alpha. When alpha is
            zero then A and B are not referenced.

    @param[in]
    A       pointer storing matrix A on the GPU.
            - A is m by m if side == rocblas_side_left
            - A is n by n if side == rocblas_side_right
            Only the upper/lower triangular part is accessed.
            The imaginary component of the diagonal elements is not used.

    @param[in]
    lda     [rocblas_int]
            lda specifies the first dimension of A.

                if side = rocblas_side_left,  lda >= max( 1, m ),
                otherwise lda >= max( 1, n ).

    @param[in]
    B       pointer storing matrix B on the GPU.
            Matrix dimension is m by n

    @param[in]
    ldb     [rocblas_int]
            ldb specifies the first dimension of B. ldb >= max( 1, m ).

    @param[in]
    beta
            beta specifies the scalar beta. When beta is
            zero then C need not be set before entry.

    @param[in]
    C       pointer storing matrix C on the GPU.
            Matrix dimension is m by n

    @param[in]
    ldc    [rocblas_int]
           ldc specifies the first dimension of C. ldc >= max( 1, m ).

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_chemm",
        fn (
            Handle,
            Side,
            Fill,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int32,
            UnsafePointer[ComplexFloat32],
            Int32,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int32,
        ) -> Status,
    ]()(handle, side, uplo, m, n, alpha, _a, lda, _b, ldb, beta, _c, ldc)


fn rocblas_izamin_64(
    handle: Handle,
    n: Int64,
    x: UnsafePointer[ComplexFloat64],
    incx: Int64,
    result: UnsafePointer[Int64],
) -> Status:
    return _get_dylib_function[
        "rocblas_izamin_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int64,
            UnsafePointer[Int64],
        ) -> Status,
    ]()(handle, n, x, incx, result)


fn rocblas_chpr2_strided_batched_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    alpha: UnsafePointer[ComplexFloat32],
    x: UnsafePointer[ComplexFloat32],
    incx: Int64,
    stride_x: Int64,
    y: UnsafePointer[ComplexFloat32],
    incy: Int64,
    stride_y: Int64,
    _ap: UnsafePointer[ComplexFloat32],
    stride__a: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_chpr2_strided_batched_64",
        fn (
            Handle,
            Fill,
            Int64,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int64,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int64,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int64,
            Int64,
        ) -> Status,
    ]()(
        handle,
        uplo,
        n,
        alpha,
        x,
        incx,
        stride_x,
        y,
        incy,
        stride_y,
        _ap,
        stride__a,
        batch_count,
    )


fn rocblas_ctpmv_strided_batched(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int32,
    _a: UnsafePointer[ComplexFloat32],
    stride__a: Int64,
    x: UnsafePointer[ComplexFloat32],
    incx: Int32,
    stride_x: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_ctpmv_strided_batched",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int32,
            UnsafePointer[ComplexFloat32],
            Int64,
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        uplo,
        trans_a,
        diag,
        n,
        _a,
        stride__a,
        x,
        incx,
        stride_x,
        batch_count,
    )


fn rocblas_srotg(
    handle: Handle,
    a: UnsafePointer[Float32],
    b: UnsafePointer[Float32],
    c: UnsafePointer[Float32],
    s: UnsafePointer[Float32],
) -> Status:
    """
    \\brief <b> BLAS Level 1 API </b>.

    \\details
    rotg creates the Givens rotation matrix for the vector (a b).
    Scalars a, b, c, and s may be stored in either host or device memory, location is specified by
    calling rocblas_set_pointer_mode. The computation uses the formulas

        sigma = sgn(a)    if |a| >  |b|
              = sgn(b)    if |b| >= |a|
        r = sigma*sqrt( a**2 + b**2 )
        c = 1; s = 0      if r = 0
        c = a/r; s = b/r  if r != 0

    The subroutine also computes

        z = s    if |a| > |b|,
          = 1/c  if |b| >= |a| and c != 0
          = 1    if c = 0

    This allows c and s to be reconstructed from z as follows:

        If z = 1, set c = 0, s = 1.
        If |z| < 1, set c = sqrt(1 - z**2) and s = z.
        If |z| > 1, set c = 1/z and s = sqrt( 1 - c**2).

    @param[in]
    handle  [rocblas_handle]
            handle to the rocblas library context queue.
    @param[in, out]
    a       pointer to a, an element in vector (a,b), overwritten with r.
    @param[in, out]
    b       pointer to b, an element in vector (a,b), overwritten with z.
    @param[out]
    c       pointer to c, cosine element of Givens rotation.
    @param[out]
    s       pointer to s, sine element of Givens rotation.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_srotg",
        fn (
            Handle,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            UnsafePointer[Float32],
        ) -> Status,
    ]()(handle, a, b, c, s)


fn rocblas_strsm_strided_batched(
    handle: Handle,
    side: Side,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    m: Int32,
    n: Int32,
    alpha: UnsafePointer[Float32],
    _a: UnsafePointer[Float32],
    lda: Int32,
    stride_a: Int64,
    _b: UnsafePointer[Float32],
    ldb: Int32,
    stride_b: Int64,
    batch_count: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 3 API </b>.

    \\details
    trsm_srided_batched performs the following strided batched operation:

        op(A_i)*X_i = alpha*B_i or
        X_i*op(A_i) = alpha*B_i, for i = 1, ..., batch_count,

        where alpha is a scalar, X and B are strided batched m by n matrices,

        A is triangular strided batched matrix and op(A) is one of

        op( A ) = A   or
        op( A ) = A^T   or
        op( A ) = A^H.

        Each matrix X_i is overwritten on B_i for i = 1, ..., batch_count.

    Note about memory allocation:
    When trsm is launched with a k evenly divisible by the internal block size of 128,
    and is no larger than 10 of these blocks, the API takes advantage of utilizing pre-allocated
    memory found in the handle to increase overall performance. This memory can be managed by using
    the environment variable WORKBUF_TRSM_B_CHNK. When this variable is not set the device memory
    used for temporary storage will default to 1 MB and may result in chunking, which in turn may
    reduce performance. Under these circumstances it is recommended that WORKBUF_TRSM_B_CHNK be set
    to the desired chunk of right hand sides to be used at a time
    (where k is m when rocblas_side_left and is n when rocblas_side_right).
    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    side    [rocblas_side]
            - rocblas_side_left:       op(A)*X = alpha*B.
            - rocblas_side_right:      X*op(A) = alpha*B.
    @param[in]
    uplo    [rocblas_fill]
            - rocblas_fill_upper:  each A_i is an upper triangular matrix.
            - rocblas_fill_lower:  each A_i is a  lower triangular matrix.
    @param[in]
    transA  [rocblas_operation]
            - transB:    op(A) = A.
            - rocblas_operation_transpose:      op(A) = A^T.
            - rocblas_operation_conjugate_transpose:  op(A) = A^H.
    @param[in]
    diag    [rocblas_diagonal]
            - rocblas_diagonal_unit:     each A_i is assumed to be unit triangular.
            - rocblas_diagonal_non_unit:  each A_i is not assumed to be unit triangular.
    @param[in]
    m       [rocblas_int]
            m specifies the number of rows of each B_i. m >= 0.
    @param[in]
    n       [rocblas_int]
            n specifies the number of columns of each B_i. n >= 0.
    @param[in]
    alpha
            device pointer or host pointer specifying the scalar alpha. When alpha is
            &zero then A is not referenced and B need not be set before
            entry.
    @param[in]
    A       device pointer pointing to the first matrix A_1.
            of dimension ( lda, k ), where k is m
            when  rocblas_side_left  and
            is  n  when  rocblas_side_right
            only the upper/lower triangular part is accessed.
    @param[in]
    lda     [rocblas_int]
            lda specifies the first dimension of each A_i.

                if side = rocblas_side_left,  lda >= max( 1, m ).
                if side = rocblas_side_right, lda >= max( 1, n ).
    @param[in]
    stride_a [rocblas_stride]
             stride from the start of one A_i matrix to the next A_(i + 1).
    @param[in,out]
    B       device pointer pointing to the first matrix B_1.
    @param[in]
    ldb    [rocblas_int]
           ldb specifies the first dimension of each B_i. ldb >= max( 1, m ).
    @param[in]
    stride_b [rocblas_stride]
             stride from the start of one B_i matrix to the next B_(i + 1).
    @param[in]
    batch_count [rocblas_int]
                number of trsm operations in the batch.
    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_strsm_strided_batched",
        fn (
            Handle,
            Side,
            Fill,
            Operation,
            Diagonal,
            Int32,
            Int32,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int32,
            Int64,
            UnsafePointer[Float32],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        side,
        uplo,
        trans_a,
        diag,
        m,
        n,
        alpha,
        _a,
        lda,
        stride_a,
        _b,
        ldb,
        stride_b,
        batch_count,
    )


fn rocblas_sgemm_kernel_name(
    handle: Handle,
    trans_a: Operation,
    trans_b: Operation,
    m: Int32,
    n: Int32,
    k: Int32,
    alpha: UnsafePointer[Float32],
    _a: UnsafePointer[Float32],
    lda: Int32,
    stride_a: Int64,
    _b: UnsafePointer[Float32],
    ldb: Int32,
    stride_b: Int64,
    beta: UnsafePointer[Float32],
    _c: UnsafePointer[Float32],
    ldc: Int32,
    stride_c: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_sgemm_kernel_name",
        fn (
            Handle,
            Operation,
            Operation,
            Int32,
            Int32,
            Int32,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int32,
            Int64,
            UnsafePointer[Float32],
            Int32,
            Int64,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        trans_a,
        trans_b,
        m,
        n,
        k,
        alpha,
        _a,
        lda,
        stride_a,
        _b,
        ldb,
        stride_b,
        beta,
        _c,
        ldc,
        stride_c,
        batch_count,
    )


fn rocblas_zherkx_strided_batched(
    handle: Handle,
    uplo: Fill,
    trans: Operation,
    n: Int32,
    k: Int32,
    alpha: UnsafePointer[ComplexFloat64],
    _a: UnsafePointer[ComplexFloat64],
    lda: Int32,
    stride__a: Int64,
    _b: UnsafePointer[ComplexFloat64],
    ldb: Int32,
    stride__b: Int64,
    beta: UnsafePointer[Float64],
    _c: UnsafePointer[ComplexFloat64],
    ldc: Int32,
    stride__c: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_zherkx_strided_batched",
        fn (
            Handle,
            Fill,
            Operation,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            UnsafePointer[Float64],
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        uplo,
        trans,
        n,
        k,
        alpha,
        _a,
        lda,
        stride__a,
        _b,
        ldb,
        stride__b,
        beta,
        _c,
        ldc,
        stride__c,
        batch_count,
    )


fn rocblas_ccopy(
    handle: Handle,
    n: Int32,
    x: UnsafePointer[ComplexFloat32],
    incx: Int32,
    y: UnsafePointer[ComplexFloat32],
    incy: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_ccopy",
        fn (
            Handle,
            Int32,
            UnsafePointer[ComplexFloat32],
            Int32,
            UnsafePointer[ComplexFloat32],
            Int32,
        ) -> Status,
    ]()(handle, n, x, incx, y, incy)


fn rocblas_cgerc_strided_batched_64(
    handle: Handle,
    m: Int64,
    n: Int64,
    alpha: UnsafePointer[ComplexFloat32],
    x: UnsafePointer[ComplexFloat32],
    incx: Int64,
    stridex: Int64,
    y: UnsafePointer[ComplexFloat32],
    incy: Int64,
    stridey: Int64,
    _a: UnsafePointer[ComplexFloat32],
    lda: Int64,
    stride_a: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_cgerc_strided_batched_64",
        fn (
            Handle,
            Int64,
            Int64,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int64,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int64,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int64,
            Int64,
            Int64,
        ) -> Status,
    ]()(
        handle,
        m,
        n,
        alpha,
        x,
        incx,
        stridex,
        y,
        incy,
        stridey,
        _a,
        lda,
        stride_a,
        batch_count,
    )


fn rocblas_sspr2_batched(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    alpha: UnsafePointer[Float32],
    x: OpaquePointer,
    incx: Int32,
    y: OpaquePointer,
    incy: Int32,
    _ap: OpaquePointer,
    batch_count: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 2 API </b>.

    \\details
    spr2_batched performs the matrix-vector operation:

        A_i := A_i + alpha*x_i*y_i**T + alpha*y_i*x_i**T
        where alpha is a scalar, x_i and y_i are vectors, and A_i is an
        n by n symmetric matrix, supplied in packed form, for i = 1, ..., batch_count.

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    uplo      [rocblas_fill]
            specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
            - rocblas_fill_upper: The upper triangular part of each A_i is supplied in AP.
            - rocblas_fill_lower: The lower triangular part of each A_i is supplied in AP.
    @param[in]
    n         [rocblas_int]
            the number of rows and columns of each matrix A_i. Must be at least 0.
    @param[in]
    alpha
              device pointer or host pointer to scalar alpha.
    @param[in]
    x         device array of device pointers storing each vector x_i.
    @param[in]
    incx      [rocblas_int]
              specifies the increment for the elements of each x_i.
    @param[in]
    y         device array of device pointers storing each vector y_i.
    @param[in]
    incy      [rocblas_int]
              specifies the increment for the elements of each y_i.
    @param[in, out]
    AP        device array of device pointers storing the packed version of the specified triangular portion of
              each symmetric matrix A_i of at least size ((n * (n + 1)) / 2). Array is of at least size batch_count.

                    if uplo == rocblas_fill_upper:
                        The upper triangular portion of each symmetric matrix A_i is supplied.
                        The matrix is compacted so that AP contains the triangular portion
                        column-by-column
                        so that:
                        AP(0) = A(0,0)
                        AP(1) = A(0,1)
                        AP(2) = A(1,1), etc.
                            Ex: (rocblas_fill_upper; n = 4)
                                1 2 4 7
                                2 3 5 8   -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
                                4 5 6 9
                                7 8 9 0

                    if uplo == rocblas_fill_lower:
                        The lower triangular portion of each symmetric matrix A_i is supplied.
                        The matrix is compacted so that AP contains the triangular portion
                        column-by-column
                        so that:
                        AP(0) = A(0,0)
                        AP(1) = A(1,0)
                        AP(n) = A(2,1), etc.
                            Ex: (rocblas_fill_lower; n = 4)
                                1 2 3 4
                                2 5 6 7    -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
                                3 6 8 9
                                4 7 9 0
    @param[in]
    batch_count [rocblas_int]
                number of instances in the batch.
    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_sspr2_batched",
        fn (
            Handle,
            Fill,
            Int32,
            UnsafePointer[Float32],
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
        ) -> Status,
    ]()(handle, uplo, n, alpha, x, incx, y, incy, _ap, batch_count)


fn rocblas_ccopy_strided_batched_64(
    handle: Handle,
    n: Int64,
    x: UnsafePointer[ComplexFloat32],
    incx: Int64,
    stridex: Int64,
    y: UnsafePointer[ComplexFloat32],
    incy: Int64,
    stridey: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_ccopy_strided_batched_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int64,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int64,
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, n, x, incx, stridex, y, incy, stridey, batch_count)


fn rocblas_zherk(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    n: Int32,
    k: Int32,
    alpha: UnsafePointer[Float64],
    _a: UnsafePointer[ComplexFloat64],
    lda: Int32,
    beta: UnsafePointer[Float64],
    _c: UnsafePointer[ComplexFloat64],
    ldc: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_zherk",
        fn (
            Handle,
            Fill,
            Operation,
            Int32,
            Int32,
            UnsafePointer[Float64],
            UnsafePointer[ComplexFloat64],
            Int32,
            UnsafePointer[Float64],
            UnsafePointer[ComplexFloat64],
            Int32,
        ) -> Status,
    ]()(handle, uplo, trans_a, n, k, alpha, _a, lda, beta, _c, ldc)


fn rocblas_strmm_strided_batched(
    handle: Handle,
    side: Side,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    m: Int32,
    n: Int32,
    alpha: UnsafePointer[Float32],
    _a: UnsafePointer[Float32],
    lda: Int32,
    stride__a: Int64,
    _b: UnsafePointer[Float32],
    ldb: Int32,
    stride__b: Int64,
    _c: UnsafePointer[Float32],
    ldc: Int32,
    stride__c: Int64,
    batch_count: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 3 API </b>.

    \\details
    trmm_strided_batched performs one of the matrix-matrix operations:

        C_i := alpha*op( A_i )*B_i,   or
        C_i := alpha*B_i*op( A_i )  for i = 0, 1, ... batch_count -1,

    The Legacy BLAS in-place trmm_strided_batched functionality,

        B_i := alpha*op( A_i )*B_i,   or
        B_i := alpha*B_i*op( A_i )  for i = 0, 1, ... batch_count -1,

    is available by setting pointer C equal to pointer B, ldc equal to ldb, and stride_C equal to stride_B.

        alpha  is a scalar,  B_i  is an m by n matrix, C_i  is an m by n matrix,  A_i  is a unit, or
        non-unit,  upper or lower triangular matrix  and  op( A_i )  is one  of

        op( A_i ) = A_i   or
        op( A_i ) = A_i^T   or
        op( A_i ) = A_i^H.

        When uplo == rocblas_fill_upper the  leading  k by k
        upper triangular part of the array  A must contain the upper
        triangular matrix and the strictly lower triangular part of
        A is not referenced. Here k is m when side == rocblas_side_left
        and is n when side == rocblas_side_right.

        When uplo == rocblas_fill_lower the  leading  k by k
        lower triangular part of the array  A must contain the lower
        triangular matrix  and the strictly upper triangular part of
        A is not referenced. Here k is m when  side == rocblas_side_left
        and is n when side == rocblas_side_right.

        Note that when  diag == rocblas_diagonal_unit  the diagonal elements of
        A  are not referenced either,  but are assumed to be  unity.

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.

    @param[in]
    side    [rocblas_side]
            Specifies whether op(A_i) multiplies B_i from the left or right as follows:
            - rocblas_side_left:       C_i := alpha*op( A_i )*B_i
            - rocblas_side_right:      C_i := alpha*B_i*op( A_i )

    @param[in]
    uplo    [rocblas_fill]
            Specifies whether the matrix A is an upper or lower triangular matrix as follows:
            - rocblas_fill_upper:  A is an upper triangular matrix.
            - rocblas_fill_lower:  A is a  lower triangular matrix.

    @param[in]
    transA  [rocblas_operation]
            Specifies the form of op(A_i) to be used in the matrix multiplication as follows:
            - rocblas_operation_none:    op(A_i) = A_i
            - rocblas_operation_transpose:      op(A_i) = A_i^T
            - rocblas_operation_conjugate_transpose:  op(A_i) = A_i^H

    @param[in]
    diag    [rocblas_diagonal]
            Specifies whether or not A_i is unit triangular as follows:
            - rocblas_diagonal_unit:      A_i is assumed to be unit triangular.
            - rocblas_diagonal_non_unit:  A_i is not assumed to be unit triangular.

    @param[in]
    m       [rocblas_int]
            m specifies the number of rows of B_i. m >= 0.

    @param[in]
    n       [rocblas_int]
            n specifies the number of columns of B_i. n >= 0.

    @param[in]
    alpha
            alpha specifies the scalar alpha. When alpha is
            zero then A_i is not referenced and B_i need not be set before
            entry.

    @param[in]
    A       Device pointer to the first matrix A_0 on the GPU.
            Each A_i is of dimension ( lda, k ), where k is m
            when  side == rocblas_side_left  and
            is  n  when  side == rocblas_side_right.

            When uplo == rocblas_fill_upper the  leading  k by k
            upper triangular part of the array  A must contain the upper
            triangular matrix  and the strictly lower triangular part of
            A is not referenced.

            When uplo == rocblas_fill_lower the  leading  k by k
            lower triangular part of the array  A must contain the lower
            triangular matrix  and the strictly upper triangular part of
            A is not referenced.

        Note that when  diag == rocblas_diagonal_unit  the diagonal elements of
        A_i  are not referenced either,  but are assumed to be  unity.

    @param[in]
    lda     [rocblas_int]
            lda specifies the first dimension of A.

                if side == rocblas_side_left,  lda >= max( 1, m ),
                if side == rocblas_side_right, lda >= max( 1, n ).

    @param[in]
    stride_A  [rocblas_stride]
              stride from the start of one matrix (A_i) and the next one (A_i+1).

    @param[in]
    B       Device pointer to the first matrix B_0 on the GPU.

    @param[in]
    ldb    [rocblas_int]
           ldb specifies the first dimension of B_i. ldb >= max( 1, m ).

    @param[in]
    stride_B  [rocblas_stride]
              stride from the start of one matrix (B_i) and the next one (B_i+1).

    @param[out]
    C      Device pointer to the first matrix C_0 on the GPU.

    @param[in]
    ldc   [rocblas_int]
          ldc specifies the first dimension of C_i. ldc >= max( 1, m).
          If B and C pointers are to the same matrix then ldc must equal ldb or
          rocblas_status_invalid_size will be returned.

    @param[in]
    stride_C  [rocblas_stride]
              stride from the start of one matrix (C_i) and the next one (C_i+1).
              If B == C and ldb == ldc then stride_C should equal stride_B or
              behavior is undefined.

    @param[in]
    batch_count [rocblas_int]
                number of instances i in the batch.
    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_strmm_strided_batched",
        fn (
            Handle,
            Side,
            Fill,
            Operation,
            Diagonal,
            Int32,
            Int32,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int32,
            Int64,
            UnsafePointer[Float32],
            Int32,
            Int64,
            UnsafePointer[Float32],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        side,
        uplo,
        trans_a,
        diag,
        m,
        n,
        alpha,
        _a,
        lda,
        stride__a,
        _b,
        ldb,
        stride__b,
        _c,
        ldc,
        stride__c,
        batch_count,
    )


fn rocblas_ssyr2_strided_batched_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    alpha: UnsafePointer[Float32],
    x: UnsafePointer[Float32],
    incx: Int64,
    stridex: Int64,
    y: UnsafePointer[Float32],
    incy: Int64,
    stridey: Int64,
    _a: UnsafePointer[Float32],
    lda: Int64,
    stride_a: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_ssyr2_strided_batched_64",
        fn (
            Handle,
            Fill,
            Int64,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int64,
            Int64,
            UnsafePointer[Float32],
            Int64,
            Int64,
            UnsafePointer[Float32],
            Int64,
            Int64,
            Int64,
        ) -> Status,
    ]()(
        handle,
        uplo,
        n,
        alpha,
        x,
        incx,
        stridex,
        y,
        incy,
        stridey,
        _a,
        lda,
        stride_a,
        batch_count,
    )


fn rocblas_zaxpy_strided_batched_64(
    handle: Handle,
    n: Int64,
    alpha: UnsafePointer[ComplexFloat64],
    x: UnsafePointer[ComplexFloat64],
    incx: Int64,
    stridex: Int64,
    y: UnsafePointer[ComplexFloat64],
    incy: Int64,
    stridey: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_zaxpy_strided_batched_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int64,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int64,
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, n, alpha, x, incx, stridex, y, incy, stridey, batch_count)


fn rocblas_dtrmm_batched(
    handle: Handle,
    side: Side,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    m: Int32,
    n: Int32,
    alpha: UnsafePointer[Float64],
    _a: OpaquePointer,
    lda: Int32,
    _b: OpaquePointer,
    ldb: Int32,
    _c: OpaquePointer,
    ldc: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_dtrmm_batched",
        fn (
            Handle,
            Side,
            Fill,
            Operation,
            Diagonal,
            Int32,
            Int32,
            UnsafePointer[Float64],
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(
        handle,
        side,
        uplo,
        trans_a,
        diag,
        m,
        n,
        alpha,
        _a,
        lda,
        _b,
        ldb,
        _c,
        ldc,
        batch_count,
    )


fn rocblas_zgbmv(
    handle: Handle,
    trans: Operation,
    m: Int32,
    n: Int32,
    kl: Int32,
    ku: Int32,
    alpha: UnsafePointer[ComplexFloat64],
    _a: UnsafePointer[ComplexFloat64],
    lda: Int32,
    x: UnsafePointer[ComplexFloat64],
    incx: Int32,
    beta: UnsafePointer[ComplexFloat64],
    y: UnsafePointer[ComplexFloat64],
    incy: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_zgbmv",
        fn (
            Handle,
            Operation,
            Int32,
            Int32,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int32,
            UnsafePointer[ComplexFloat64],
            Int32,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int32,
        ) -> Status,
    ]()(handle, trans, m, n, kl, ku, alpha, _a, lda, x, incx, beta, y, incy)


fn rocblas_gemm_batched_ex(
    handle: Handle,
    trans_a: Operation,
    trans_b: Operation,
    m: Int32,
    n: Int32,
    k: Int32,
    alpha: OpaquePointer,
    a: OpaquePointer,
    a_type: DataType,
    lda: Int32,
    b: OpaquePointer,
    b_type: DataType,
    ldb: Int32,
    beta: OpaquePointer,
    c: OpaquePointer,
    c_type: DataType,
    ldc: Int32,
    d: OpaquePointer,
    d_type: DataType,
    ldd: Int32,
    batch_count: Int32,
    compute_type: DataType,
    algo: Algorithm,
    solution_index: Int32,
    flags: UInt32,
) -> Status:
    """
    \\brief <b> BLAS EX API </b>.

    \\details
    gemm_batched_ex performs one of the batched matrix-matrix operations:
        D_i = alpha*op(A_i)*op(B_i) + beta*C_i, for i = 1, ..., batch_count.
    where op( X ) is one of
        op( X ) = X      or
        op( X ) = X**T   or
        op( X ) = X**H,
    alpha and beta are scalars, and A, B, C, and D are batched pointers to matrices, with
    op( A ) an m by k by batch_count batched matrix,
    op( B ) a k by n by batch_count batched matrix and
    C and D are m by n by batch_count batched matrices.
    The batched matrices are an array of pointers to matrices.
    The number of pointers to matrices is batch_count.
    C and D may point to the same matrices if their parameters are identical.

    Supported types are as follows:
        - rocblas_datatype_f64_r = a_type = b_type = c_type = d_type = compute_type
        - rocblas_datatype_f32_r = a_type = b_type = c_type = d_type = compute_type
        - rocblas_datatype_f16_r = a_type = b_type = c_type = d_type = compute_type
        - rocblas_datatype_f16_r = a_type = b_type = c_type = d_type; rocblas_datatype_f32_r =
    compute_type
        - rocblas_datatype_bf16_r = a_type = b_type = c_type = d_type; rocblas_datatype_f32_r =
    compute_type
        - rocblas_datatype_i8_r = a_type = b_type; rocblas_datatype_i32_r = c_type = d_type =
    compute_type
        - rocblas_datatype_f32_c  = a_type = b_type = c_type = d_type = compute_type
        - rocblas_datatype_f64_c  = a_type = b_type = c_type = d_type = compute_type

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    transA    [rocblas_operation]
              specifies the form of op( A ).
    @param[in]
    transB    [rocblas_operation]
              specifies the form of op( B ).
    @param[in]
    m         [rocblas_int]
              matrix dimension m.
    @param[in]
    n         [rocblas_int]
              matrix dimension n.
    @param[in]
    k         [rocblas_int]
              matrix dimension k.
    @param[in]
    alpha     [const void *]
              device pointer or host pointer specifying the scalar alpha. Same datatype as compute_type.
    @param[in]
    a         [void *]
              device pointer storing array of pointers to each matrix A_i.
    @param[in]
    a_type    [rocblas_datatype]
              specifies the datatype of each matrix A_i.
    @param[in]
    lda       [rocblas_int]
              specifies the leading dimension of each A_i.
    @param[in]
    b         [void *]
              device pointer storing array of pointers to each matrix B_i.
    @param[in]
    b_type    [rocblas_datatype]
              specifies the datatype of each matrix B_i.
    @param[in]
    ldb       [rocblas_int]
              specifies the leading dimension of each B_i.
    @param[in]
    beta      [const void *]
              device pointer or host pointer specifying the scalar beta. Same datatype as compute_type.
    @param[in]
    c         [void *]
              device array of device pointers to each matrix C_i.
    @param[in]
    c_type    [rocblas_datatype]
              specifies the datatype of each matrix C_i.
    @param[in]
    ldc       [rocblas_int]
              specifies the leading dimension of each C_i.
    @param[out]
    d         [void *]
              device array of device pointers to each matrix D_i.
              If d and c are the same array of matrix pointers then d_type must equal c_type and ldd must equal ldc
              or the respective invalid status will be returned.
    @param[in]
    d_type    [rocblas_datatype]
              specifies the datatype of each matrix D_i.
    @param[in]
    ldd       [rocblas_int]
              specifies the leading dimension of each D_i.
    @param[in]
    batch_count
              [rocblas_int]
              number of gemm operations in the batch.
    @param[in]
    compute_type
              [rocblas_datatype]
              specifies the datatype of computation.
    @param[in]
    algo      [rocblas_gemm_algo]
              enumerant specifying the algorithm type.
    @param[in]
    solution_index
              [int32_t]
              if algo is Algorithmsolution_index, this controls which solution is used.
              When algo is not Algorithmsolution_index, or if solution_index <= 0, the default solution is used.
              This parameter was unused in previous releases and instead always used the default solution
    @param[in]
    flags     [uint32_t]
              optional gemm flags.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_gemm_batched_ex",
        fn (
            Handle,
            Operation,
            Operation,
            Int32,
            Int32,
            Int32,
            OpaquePointer,
            OpaquePointer,
            DataType,
            Int32,
            OpaquePointer,
            DataType,
            Int32,
            OpaquePointer,
            OpaquePointer,
            DataType,
            Int32,
            OpaquePointer,
            DataType,
            Int32,
            Int32,
            DataType,
            Algorithm,
            Int32,
            UInt32,
        ) -> Status,
    ]()(
        handle,
        trans_a,
        trans_b,
        m,
        n,
        k,
        alpha,
        a,
        a_type,
        lda,
        b,
        b_type,
        ldb,
        beta,
        c,
        c_type,
        ldc,
        d,
        d_type,
        ldd,
        batch_count,
        compute_type,
        algo,
        solution_index,
        flags,
    )


fn rocblas_bfdot_batched_64(
    handle: Handle,
    n: Int64,
    x: OpaquePointer,
    incx: Int64,
    y: OpaquePointer,
    incy: Int64,
    batch_count: Int64,
    result: UnsafePointer[BFloat16],
) -> Status:
    return _get_dylib_function[
        "rocblas_bfdot_batched_64",
        fn (
            Handle,
            Int64,
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            Int64,
            UnsafePointer[BFloat16],
        ) -> Status,
    ]()(handle, n, x, incx, y, incy, batch_count, result)


fn rocblas_sdot_strided_batched_64(
    handle: Handle,
    n: Int64,
    x: UnsafePointer[Float32],
    incx: Int64,
    stridex: Int64,
    y: UnsafePointer[Float32],
    incy: Int64,
    stridey: Int64,
    batch_count: Int64,
    result: UnsafePointer[Float32],
) -> Status:
    return _get_dylib_function[
        "rocblas_sdot_strided_batched_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[Float32],
            Int64,
            Int64,
            UnsafePointer[Float32],
            Int64,
            Int64,
            Int64,
            UnsafePointer[Float32],
        ) -> Status,
    ]()(handle, n, x, incx, stridex, y, incy, stridey, batch_count, result)


fn rocblas_cscal_batched(
    handle: Handle,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat32],
    x: OpaquePointer,
    incx: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_cscal_batched",
        fn (
            Handle,
            Int32,
            UnsafePointer[ComplexFloat32],
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(handle, n, alpha, x, incx, batch_count)


fn rocblas_strtri_batched(
    handle: Handle,
    uplo: Fill,
    diag: Diagonal,
    n: Int32,
    _a: OpaquePointer,
    lda: Int32,
    inv_a: OpaquePointer,
    ldinv_a: Int32,
    batch_count: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 3 API </b>.

    \\details
    trtri_batched  compute the inverse of A_i and write into invA_i where
                   A_i and invA_i are the i-th matrices in the batch,
                   for i = 1, ..., batch_count.

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    uplo      [rocblas_fill]
              specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
    @param[in]
    diag      [rocblas_diagonal]
              - 'rocblas_diagonal_non_unit', A is non-unit triangular;
              - 'rocblas_diagonal_unit', A is unit triangular;
    @param[in]
    n         [rocblas_int]
    @param[in]
    A         device array of device pointers storing each matrix A_i.
    @param[in]
    lda       [rocblas_int]
              specifies the leading dimension of each A_i.
    @param[out]
    invA      device array of device pointers storing the inverse of each matrix A_i.
    Partial inplace operation is supported. See below:
            -If UPLO = 'U', the leading N-by-N upper triangular part of the invA will store
                the inverse of the upper triangular matrix, and the strictly lower
                triangular part of invA may be cleared.
            - If UPLO = 'L', the leading N-by-N lower triangular part of the invA will store
                the inverse of the lower triangular matrix, and the strictly upper
                triangular part of invA may be cleared.
    @param[in]
    ldinvA    [rocblas_int]
              specifies the leading dimension of each invA_i.
    @param[in]
    batch_count [rocblas_int]
              numbers of matrices in the batch.
    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_strtri_batched",
        fn (
            Handle,
            Fill,
            Diagonal,
            Int32,
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(handle, uplo, diag, n, _a, lda, inv_a, ldinv_a, batch_count)


fn rocblas_zher(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    alpha: UnsafePointer[Float64],
    x: UnsafePointer[ComplexFloat64],
    incx: Int32,
    _a: UnsafePointer[ComplexFloat64],
    lda: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_zher",
        fn (
            Handle,
            Fill,
            Int32,
            UnsafePointer[Float64],
            UnsafePointer[ComplexFloat64],
            Int32,
            UnsafePointer[ComplexFloat64],
            Int32,
        ) -> Status,
    ]()(handle, uplo, n, alpha, x, incx, _a, lda)


fn rocblas_zher2k(
    handle: Handle,
    uplo: Fill,
    trans: Operation,
    n: Int32,
    k: Int32,
    alpha: UnsafePointer[ComplexFloat64],
    _a: UnsafePointer[ComplexFloat64],
    lda: Int32,
    _b: UnsafePointer[ComplexFloat64],
    ldb: Int32,
    beta: UnsafePointer[Float64],
    _c: UnsafePointer[ComplexFloat64],
    ldc: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_zher2k",
        fn (
            Handle,
            Fill,
            Operation,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int32,
            UnsafePointer[ComplexFloat64],
            Int32,
            UnsafePointer[Float64],
            UnsafePointer[ComplexFloat64],
            Int32,
        ) -> Status,
    ]()(handle, uplo, trans, n, k, alpha, _a, lda, _b, ldb, beta, _c, ldc)


fn rocblas_hssgemv_batched(
    handle: Handle,
    trans: Operation,
    m: Int32,
    n: Int32,
    alpha: UnsafePointer[Float32],
    _a: OpaquePointer,
    lda: Int32,
    x: OpaquePointer,
    incx: Int32,
    beta: UnsafePointer[Float32],
    y: OpaquePointer,
    incy: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_hssgemv_batched",
        fn (
            Handle,
            Operation,
            Int32,
            Int32,
            UnsafePointer[Float32],
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            UnsafePointer[Float32],
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(
        handle, trans, m, n, alpha, _a, lda, x, incx, beta, y, incy, batch_count
    )


fn rocblas_trsm_ex(
    handle: Handle,
    side: Side,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    m: Int32,
    n: Int32,
    alpha: OpaquePointer,
    _a: OpaquePointer,
    lda: Int32,
    _b: OpaquePointer,
    ldb: Int32,
    inv_a: OpaquePointer,
    inv_a_size: Int32,
    compute_type: DataType,
) -> Status:
    """
    \\brief <b> BLAS EX API </b>.

    \\details
    trsm_ex solves:

        op(A)*X = alpha*B or X*op(A) = alpha*B,

    where alpha is a scalar, X and B are m by n matrices,
    A is triangular matrix and op(A) is one of

        op( A ) = A   or   op( A ) = A^T   or   op( A ) = A^H.

    The matrix X is overwritten on B.

    This function gives the user the ability to reuse the invA matrix between runs.
    If invA == NULL, rocblas_trsm_ex will automatically calculate invA on every run.

    Setting up invA:
    The accepted invA matrix consists of the packed 128x128 inverses of the diagonal blocks of
    matrix A, followed by any smaller diagonal block that remains.
    To set up invA it is recommended that rocblas_trtri_batched be used with matrix A as the input.

    Device memory of size 128 x k should be allocated for invA ahead of time, where k is m when
    rocblas_side_left and is n when rocblas_side_right. The actual number of elements in invA
    should be passed as invA_size.

    To begin, rocblas_trtri_batched must be called on the full 128x128-sized diagonal blocks of
    matrix A. Below are the restricted parameters:
      - n = 128
      - ldinvA = 128
      - stride_invA = 128x128
      - batch_count = k / 128,

    Then any remaining block may be added:
      - n = k % 128
      - invA = invA + stride_invA * previous_batch_count
      - ldinvA = 128
      - batch_count = 1

    Although not widespread, some gemm kernels used by trsm_ex may use atomic operations.
    See Atomic Operations in the API Reference Guide for more information.

    @param[in]
    handle  [rocblas_handle]
            handle to the rocblas library context queue.

    @param[in]
    side    [rocblas_side]
            - rocblas_side_left:       op(A)*X = alpha*B
            - rocblas_side_right:      X*op(A) = alpha*B

    @param[in]
    uplo    [rocblas_fill]
            - rocblas_fill_upper:  A is an upper triangular matrix.
            - rocblas_fill_lower:  A is a lower triangular matrix.

    @param[in]
    transA  [rocblas_operation]
            - transB:    op(A) = A.
            - rocblas_operation_transpose:      op(A) = A^T
            - rocblas_operation_conjugate_transpose:  op(A) = A^H

    @param[in]
    diag    [rocblas_diagonal]
            - rocblas_diagonal_unit:     A is assumed to be unit triangular.
            - rocblas_diagonal_non_unit:  A is not assumed to be unit triangular.

    @param[in]
    m       [rocblas_int]
            m specifies the number of rows of B. m >= 0.

    @param[in]
    n       [rocblas_int]
            n specifies the number of columns of B. n >= 0.

    @param[in]
    alpha   [void *]
            device pointer or host pointer specifying the scalar alpha. When alpha is
            &zero then A is not referenced, and B need not be set before
            entry.

    @param[in]
    A       [void *]
            device pointer storing matrix A.
            of dimension ( lda, k ), where k is m
            when rocblas_side_left and
            is n when rocblas_side_right
            only the upper/lower triangular part is accessed.

    @param[in]
    lda     [rocblas_int]
            lda specifies the first dimension of A.

                if side = rocblas_side_left,  lda >= max( 1, m ),
                if side = rocblas_side_right, lda >= max( 1, n ).

    @param[in, out]
    B       [void *]
            device pointer storing matrix B.
            B is of dimension ( ldb, n ).
            Before entry, the leading m by n part of the array B must
            contain the right-hand side matrix B, and on exit is
            overwritten by the solution matrix X.

    @param[in]
    ldb    [rocblas_int]
           ldb specifies the first dimension of B. ldb >= max( 1, m ).

    @param[in]
    invA    [void *]
            device pointer storing the inverse diagonal blocks of A.
            invA is of dimension ( ld_invA, k ), where k is m
            when rocblas_side_left and
            is n when rocblas_side_right.
            ld_invA must be equal to 128.

    @param[in]
    invA_size [rocblas_int]
            invA_size specifies the number of elements of device memory in invA.

    @param[in]
    compute_type [rocblas_datatype]
            specifies the datatype of computation.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_trsm_ex",
        fn (
            Handle,
            Side,
            Fill,
            Operation,
            Diagonal,
            Int32,
            Int32,
            OpaquePointer,
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            DataType,
        ) -> Status,
    ]()(
        handle,
        side,
        uplo,
        trans_a,
        diag,
        m,
        n,
        alpha,
        _a,
        lda,
        _b,
        ldb,
        inv_a,
        inv_a_size,
        compute_type,
    )


fn rocblas_zgeru_batched_64(
    handle: Handle,
    m: Int64,
    n: Int64,
    alpha: UnsafePointer[ComplexFloat64],
    x: OpaquePointer,
    incx: Int64,
    y: OpaquePointer,
    incy: Int64,
    _a: OpaquePointer,
    lda: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_zgeru_batched_64",
        fn (
            Handle,
            Int64,
            Int64,
            UnsafePointer[ComplexFloat64],
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, m, n, alpha, x, incx, y, incy, _a, lda, batch_count)


fn rocblas_snrm2_batched_64(
    handle: Handle,
    n: Int64,
    x: OpaquePointer,
    incx: Int64,
    batch_count: Int64,
    results: UnsafePointer[Float32],
) -> Status:
    return _get_dylib_function[
        "rocblas_snrm2_batched_64",
        fn (
            Handle,
            Int64,
            OpaquePointer,
            Int64,
            Int64,
            UnsafePointer[Float32],
        ) -> Status,
    ]()(handle, n, x, incx, batch_count, results)


fn rocblas_chemv_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    alpha: UnsafePointer[ComplexFloat32],
    _a: UnsafePointer[ComplexFloat32],
    lda: Int64,
    x: UnsafePointer[ComplexFloat32],
    incx: Int64,
    beta: UnsafePointer[ComplexFloat32],
    y: UnsafePointer[ComplexFloat32],
    incy: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_chemv_64",
        fn (
            Handle,
            Fill,
            Int64,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int64,
            UnsafePointer[ComplexFloat32],
            Int64,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int64,
        ) -> Status,
    ]()(handle, uplo, n, alpha, _a, lda, x, incx, beta, y, incy)


fn rocblas_ctrsm_64(
    handle: Handle,
    side: Side,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    m: Int64,
    n: Int64,
    alpha: UnsafePointer[ComplexFloat32],
    _a: UnsafePointer[ComplexFloat32],
    lda: Int64,
    _b: UnsafePointer[ComplexFloat32],
    ldb: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_ctrsm_64",
        fn (
            Handle,
            Side,
            Fill,
            Operation,
            Diagonal,
            Int64,
            Int64,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int64,
            UnsafePointer[ComplexFloat32],
            Int64,
        ) -> Status,
    ]()(handle, side, uplo, trans_a, diag, m, n, alpha, _a, lda, _b, ldb)


fn rocblas_zsyr_batched(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat64],
    x: OpaquePointer,
    incx: Int32,
    _a: OpaquePointer,
    lda: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_zsyr_batched",
        fn (
            Handle,
            Fill,
            Int32,
            UnsafePointer[ComplexFloat64],
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(handle, uplo, n, alpha, x, incx, _a, lda, batch_count)


fn rocblas_cgbmv_64(
    handle: Handle,
    trans: Operation,
    m: Int64,
    n: Int64,
    kl: Int64,
    ku: Int64,
    alpha: UnsafePointer[ComplexFloat32],
    _a: UnsafePointer[ComplexFloat32],
    lda: Int64,
    x: UnsafePointer[ComplexFloat32],
    incx: Int64,
    beta: UnsafePointer[ComplexFloat32],
    y: UnsafePointer[ComplexFloat32],
    incy: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_cgbmv_64",
        fn (
            Handle,
            Operation,
            Int64,
            Int64,
            Int64,
            Int64,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int64,
            UnsafePointer[ComplexFloat32],
            Int64,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int64,
        ) -> Status,
    ]()(handle, trans, m, n, kl, ku, alpha, _a, lda, x, incx, beta, y, incy)


fn rocblas_cherkx(
    handle: Handle,
    uplo: Fill,
    trans: Operation,
    n: Int32,
    k: Int32,
    alpha: UnsafePointer[ComplexFloat32],
    _a: UnsafePointer[ComplexFloat32],
    lda: Int32,
    _b: UnsafePointer[ComplexFloat32],
    ldb: Int32,
    beta: UnsafePointer[Float32],
    _c: UnsafePointer[ComplexFloat32],
    ldc: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 3 API </b>.

    \\details
    herkx performs one of the matrix-matrix operations for a Hermitian rank-k update:

        C := alpha*op( A )*op( B )^H + beta*C,

        where  alpha and beta are scalars, op(A) and op(B) are n by k matrices, and
        C is a n x n Hermitian matrix stored as either upper or lower.

    This routine should only be used when the caller can guarantee that the result of op( A )*op( B )^T will be Hermitian.

        op( A ) = A, op( B ) = B, and A and B are n by k if trans == rocblas_operation_none
        op( A ) = A^H, op( B ) = B^H,  and A and B are k by n if trans == rocblas_operation_conjugate_transpose

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.

    @param[in]
    uplo    [rocblas_fill]
            - rocblas_fill_upper:  C is an upper triangular matrix
            - rocblas_fill_lower:  C is a  lower triangular matrix

    @param[in]
    trans  [rocblas_operation]
            - rocblas_operation_conjugate_transpose:  op( A ) = A^H, op( B ) = B^H
            - rocblas_operation_none:                 op( A ) = A, op( B ) = B

    @param[in]
    n       [rocblas_int]
            n specifies the number of rows and columns of C. n >= 0.

    @param[in]
    k       [rocblas_int]
            k specifies the number of columns of op(A). k >= 0.

    @param[in]
    alpha
            alpha specifies the scalar alpha. When alpha is
            zero then A is not referenced and A need not be set before
            entry.

    @param[in]
    A       pointer storing matrix A on the GPU.
            Matrix dimension is ( lda, k ) when if trans = rocblas_operation_none, otherwise (lda, n)

    @param[in]
    lda     [rocblas_int]
            lda specifies the first dimension of A.

                if trans = rocblas_operation_none,  lda >= max( 1, n ),
                otherwise lda >= max( 1, k ).
    @param[in]
    B       pointer storing matrix B on the GPU.
            Matrix dimension is ( ldb, k ) when if trans = rocblas_operation_none, otherwise (ldb, n)

    @param[in]
    ldb     [rocblas_int]
            ldb specifies the first dimension of B.

                if trans = rocblas_operation_none,  ldb >= max( 1, n ),
                otherwise ldb >= max( 1, k ).

    @param[in]
    beta
            beta specifies the scalar beta. When beta is
            zero then C need not be set before entry.

    @param[in]
    C       pointer storing matrix C on the GPU.
            The imaginary component of the diagonal elements are not used but are set to zero unless quick return.
            only the upper/lower triangular part is accessed.

    @param[in]
    ldc    [rocblas_int]
           ldc specifies the first dimension of C. ldc >= max( 1, n ).

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_cherkx",
        fn (
            Handle,
            Fill,
            Operation,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int32,
            UnsafePointer[ComplexFloat32],
            Int32,
            UnsafePointer[Float32],
            UnsafePointer[ComplexFloat32],
            Int32,
        ) -> Status,
    ]()(handle, uplo, trans, n, k, alpha, _a, lda, _b, ldb, beta, _c, ldc)


fn rocblas_zdotu_64(
    handle: Handle,
    n: Int64,
    x: UnsafePointer[ComplexFloat64],
    incx: Int64,
    y: UnsafePointer[ComplexFloat64],
    incy: Int64,
    result: UnsafePointer[ComplexFloat64],
) -> Status:
    return _get_dylib_function[
        "rocblas_zdotu_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int64,
            UnsafePointer[ComplexFloat64],
            Int64,
            UnsafePointer[ComplexFloat64],
        ) -> Status,
    ]()(handle, n, x, incx, y, incy, result)


fn rocblas_zsyr_strided_batched(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat64],
    x: UnsafePointer[ComplexFloat64],
    incx: Int32,
    stridex: Int64,
    _a: UnsafePointer[ComplexFloat64],
    lda: Int32,
    stride_a: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_zsyr_strided_batched",
        fn (
            Handle,
            Fill,
            Int32,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle, uplo, n, alpha, x, incx, stridex, _a, lda, stride_a, batch_count
    )


fn rocblas_dger_batched(
    handle: Handle,
    m: Int32,
    n: Int32,
    alpha: UnsafePointer[Float64],
    x: OpaquePointer,
    incx: Int32,
    y: OpaquePointer,
    incy: Int32,
    _a: OpaquePointer,
    lda: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_dger_batched",
        fn (
            Handle,
            Int32,
            Int32,
            UnsafePointer[Float64],
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(handle, m, n, alpha, x, incx, y, incy, _a, lda, batch_count)


fn rocblas_csyr2(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat32],
    x: UnsafePointer[ComplexFloat32],
    incx: Int32,
    y: UnsafePointer[ComplexFloat32],
    incy: Int32,
    _a: UnsafePointer[ComplexFloat32],
    lda: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_csyr2",
        fn (
            Handle,
            Fill,
            Int32,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int32,
            UnsafePointer[ComplexFloat32],
            Int32,
            UnsafePointer[ComplexFloat32],
            Int32,
        ) -> Status,
    ]()(handle, uplo, n, alpha, x, incx, y, incy, _a, lda)


fn rocblas_dsbmv_strided_batched(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    k: Int32,
    alpha: UnsafePointer[Float64],
    _a: UnsafePointer[Float64],
    lda: Int32,
    stride_a: Int64,
    x: UnsafePointer[Float64],
    incx: Int32,
    stridex: Int64,
    beta: UnsafePointer[Float64],
    y: UnsafePointer[Float64],
    incy: Int32,
    stridey: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_dsbmv_strided_batched",
        fn (
            Handle,
            Fill,
            Int32,
            Int32,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int32,
            Int64,
            UnsafePointer[Float64],
            Int32,
            Int64,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        uplo,
        n,
        k,
        alpha,
        _a,
        lda,
        stride_a,
        x,
        incx,
        stridex,
        beta,
        y,
        incy,
        stridey,
        batch_count,
    )


fn rocblas_zhbmv_batched(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    k: Int32,
    alpha: UnsafePointer[ComplexFloat64],
    _a: OpaquePointer,
    lda: Int32,
    x: OpaquePointer,
    incx: Int32,
    beta: UnsafePointer[ComplexFloat64],
    y: OpaquePointer,
    incy: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_zhbmv_batched",
        fn (
            Handle,
            Fill,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat64],
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            UnsafePointer[ComplexFloat64],
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(handle, uplo, n, k, alpha, _a, lda, x, incx, beta, y, incy, batch_count)


fn rocblas_zscal_batched(
    handle: Handle,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat64],
    x: OpaquePointer,
    incx: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_zscal_batched",
        fn (
            Handle,
            Int32,
            UnsafePointer[ComplexFloat64],
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(handle, n, alpha, x, incx, batch_count)


fn rocblas_icamax_batched_64(
    handle: Handle,
    n: Int64,
    x: OpaquePointer,
    incx: Int64,
    batch_count: Int64,
    result: UnsafePointer[Int64],
) -> Status:
    return _get_dylib_function[
        "rocblas_icamax_batched_64",
        fn (
            Handle,
            Int64,
            OpaquePointer,
            Int64,
            Int64,
            UnsafePointer[Int64],
        ) -> Status,
    ]()(handle, n, x, incx, batch_count, result)


fn rocblas_idamin_strided_batched(
    handle: Handle,
    n: Int32,
    x: UnsafePointer[Float64],
    incx: Int32,
    stridex: Int64,
    batch_count: Int32,
    result: UnsafePointer[Int32],
) -> Status:
    return _get_dylib_function[
        "rocblas_idamin_strided_batched",
        fn (
            Handle,
            Int32,
            UnsafePointer[Float64],
            Int32,
            Int64,
            Int32,
            UnsafePointer[Int32],
        ) -> Status,
    ]()(handle, n, x, incx, stridex, batch_count, result)


fn rocblas_zsyr2k_batched(
    handle: Handle,
    uplo: Fill,
    trans: Operation,
    n: Int32,
    k: Int32,
    alpha: UnsafePointer[ComplexFloat64],
    _a: OpaquePointer,
    lda: Int32,
    _b: OpaquePointer,
    ldb: Int32,
    beta: UnsafePointer[ComplexFloat64],
    _c: OpaquePointer,
    ldc: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_zsyr2k_batched",
        fn (
            Handle,
            Fill,
            Operation,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat64],
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            UnsafePointer[ComplexFloat64],
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(
        handle,
        uplo,
        trans,
        n,
        k,
        alpha,
        _a,
        lda,
        _b,
        ldb,
        beta,
        _c,
        ldc,
        batch_count,
    )


fn rocblas_haxpy_strided_batched(
    handle: Handle,
    n: Int32,
    alpha: UnsafePointer[Float16],
    x: UnsafePointer[Float16],
    incx: Int32,
    stridex: Int64,
    y: UnsafePointer[Float16],
    incy: Int32,
    stridey: Int64,
    batch_count: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 1 API </b>.

    \\details
    axpy_strided_batched compute y := alpha * x + y over a set of strided batched vectors.

    @param[in]
    handle    rocblas_handle
              handle to the rocblas library context queue.
    @param[in]
    n         rocblas_int.
    @param[in]
    alpha     specifies the scalar alpha.
    @param[in]
    x         pointer storing vector x on the GPU.
    @param[in]
    incx      rocblas_int
              specifies the increment for the elements of x.
    @param[in]
    stridex   rocblas_stride
              specifies the increment between vectors of x.
    @param[out]
    y         pointer storing vector y on the GPU.
    @param[in, out]
    incy      rocblas_int
              specifies the increment for the elements of y.
    @param[in]
    stridey   rocblas_stride
              specifies the increment between vectors of y.

    @param[in]
    batch_count rocblas_int
              number of instances in the batch.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_haxpy_strided_batched",
        fn (
            Handle,
            Int32,
            UnsafePointer[Float16],
            UnsafePointer[Float16],
            Int32,
            Int64,
            UnsafePointer[Float16],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(handle, n, alpha, x, incx, stridex, y, incy, stridey, batch_count)


fn rocblas_zdrot_batched(
    handle: Handle,
    n: Int32,
    x: OpaquePointer,
    incx: Int32,
    y: OpaquePointer,
    incy: Int32,
    c: UnsafePointer[Float64],
    s: UnsafePointer[Float64],
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_zdrot_batched",
        fn (
            Handle,
            Int32,
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int32,
        ) -> Status,
    ]()(handle, n, x, incx, y, incy, c, s, batch_count)


fn rocblas_sgemmt_batched(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    trans_b: Operation,
    n: Int32,
    k: Int32,
    alpha: UnsafePointer[Float32],
    _a: OpaquePointer,
    lda: Int32,
    _b: OpaquePointer,
    ldb: Int32,
    beta: UnsafePointer[Float32],
    _c: OpaquePointer,
    ldc: Int32,
    batch_count: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 3 API </b>.

    \\details
    gemmt_batched performs matrix-matrix operations and updates the upper or lower triangular part of the result matrix:

        C_i = alpha*op( A_i )*op( B_i ) + beta*C_i, for i = 1, ..., batch_count,

        where op( X ) is one of

        op( X ) = X      or
        op( X ) = X**T   or
        op( X ) = X**H,

        alpha and beta are scalars. A, B  are general matrices and C is either an upper or lower triangular matrix, with

        op( A ) an n by k by batch_count matrices,
        op( B ) an k by n by batch_count matrices and
        C an n by n by batch_count matrices.

    @param[in]
    handle    [rocblas_handle
              handle to the rocblas library context queue.
    @param[in]
    uplo    [rocblas_fill]
            - rocblas_fill_upper:  C is an upper triangular matrix
            - rocblas_fill_lower:  C is a  lower triangular matrix
    @param[in]
    transA    [rocblas_operation]
            - rocblas_operation_none:    op(A_i) = A_i.
            - rocblas_operation_transpose:      op(A_i) = A_i^T
            - rocblas_operation_conjugate_transpose:  op(A_i) = A_i^H
    @param[in]
    transB    [rocblas_operation]
            - rocblas_operation_none:    op(B_i) = B_i.
            - rocblas_operation_transpose:      op(B_i) = B_i^T
            - rocblas_operation_conjugate_transpose:  op(B_i) = B_i^H
    @param[in]
    n         [rocblas_int]
              number or rows of matrices op( A_i ), columns of op( B_i ), and (rows, columns) of C_i.
    @param[in]
    k         [rocblas_int]
              number of rows of matrices op( B_i ) and columns of op( A_i ).
    @param[in]
    alpha     device pointer or host pointer specifying the scalar alpha.
    @param[in]
    A         device array of device pointers storing each matrix A_i. If transa = rocblas_operation_none, then, the leading n-by-k part of the array contains each matrix A_i, otherwise the leading k-by-n part of the array contains each matrix A_i.
    @param[in]
    lda       [rocblas_int]
              specifies the leading dimension of each A_i. If transA == rocblas_operation_none, must have lda >= max(1, n), otherwise, must have lda >= max(1, k).
    @param[in]
    B         device array of device pointers storing each matrix B_i. If transB = rocblas_operation_none, then, the leading k-by-n part of the array contains each matrix B_i, otherwise the leading n-by-k part of the array contains each matrix B_i.
    @param[in]
    ldb       [rocblas_int]
              specifies the leading dimension of each B_i. If transB == rocblas_operation_none, must have ldb >= max(1, k), otherwise, must have ldb >= max(1, n).
    @param[in]
    beta      device pointer or host pointer specifying the scalar beta.
    @param[in, out]
    C         device array of device pointers storing each matrix C_i. If uplo == rocblas_fill_upper, the upper triangular part of the leading n-by-n array contains each matrix C_i, otherwise the lower triangular part of the leading n-by-n array contains each matrix C_i.
    @param[in]
    ldc       [rocblas_int]
              specifies the leading dimension of each C_i. Must have ldc >= max(1, n).
    @param[in]
    batch_count
              [rocblas_int]
              number of gemm operations in the batch.
    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_sgemmt_batched",
        fn (
            Handle,
            Fill,
            Operation,
            Operation,
            Int32,
            Int32,
            UnsafePointer[Float32],
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            UnsafePointer[Float32],
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(
        handle,
        uplo,
        trans_a,
        trans_b,
        n,
        k,
        alpha,
        _a,
        lda,
        _b,
        ldb,
        beta,
        _c,
        ldc,
        batch_count,
    )


fn rocblas_scasum_strided_batched_64(
    handle: Handle,
    n: Int64,
    x: UnsafePointer[ComplexFloat32],
    incx: Int64,
    stridex: Int64,
    batch_count: Int64,
    results: UnsafePointer[Float32],
) -> Status:
    return _get_dylib_function[
        "rocblas_scasum_strided_batched_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int64,
            Int64,
            Int64,
            UnsafePointer[Float32],
        ) -> Status,
    ]()(handle, n, x, incx, stridex, batch_count, results)


fn rocblas_cgemm_strided_batched(
    handle: Handle,
    trans_a: Operation,
    trans_b: Operation,
    m: Int32,
    n: Int32,
    k: Int32,
    alpha: UnsafePointer[ComplexFloat32],
    _a: UnsafePointer[ComplexFloat32],
    lda: Int32,
    stride_a: Int64,
    _b: UnsafePointer[ComplexFloat32],
    ldb: Int32,
    stride_b: Int64,
    beta: UnsafePointer[ComplexFloat32],
    _c: UnsafePointer[ComplexFloat32],
    ldc: Int32,
    stride_c: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_cgemm_strided_batched",
        fn (
            Handle,
            Operation,
            Operation,
            Int32,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        trans_a,
        trans_b,
        m,
        n,
        k,
        alpha,
        _a,
        lda,
        stride_a,
        _b,
        ldb,
        stride_b,
        beta,
        _c,
        ldc,
        stride_c,
        batch_count,
    )


fn rocblas_dscal_batched_64(
    handle: Handle,
    n: Int64,
    alpha: UnsafePointer[Float64],
    x: OpaquePointer,
    incx: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_dscal_batched_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[Float64],
            OpaquePointer,
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, n, alpha, x, incx, batch_count)


fn rocblas_dgbmv_batched(
    handle: Handle,
    trans: Operation,
    m: Int32,
    n: Int32,
    kl: Int32,
    ku: Int32,
    alpha: UnsafePointer[Float64],
    _a: OpaquePointer,
    lda: Int32,
    x: OpaquePointer,
    incx: Int32,
    beta: UnsafePointer[Float64],
    y: OpaquePointer,
    incy: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_dgbmv_batched",
        fn (
            Handle,
            Operation,
            Int32,
            Int32,
            Int32,
            Int32,
            UnsafePointer[Float64],
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            UnsafePointer[Float64],
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(
        handle,
        trans,
        m,
        n,
        kl,
        ku,
        alpha,
        _a,
        lda,
        x,
        incx,
        beta,
        y,
        incy,
        batch_count,
    )


fn rocblas_strsv_strided_batched(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int32,
    _a: UnsafePointer[Float32],
    lda: Int32,
    stride__a: Int64,
    x: UnsafePointer[Float32],
    incx: Int32,
    stride_x: Int64,
    batch_count: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 2 API </b>.

    \\details
    trsv_strided_batched solves:

         A_i*x_i = b_i or
         A_i**T*x_i = b_i or
         A_i**H*x_i = b_i,
         where (A_i, x_i, b_i) is the i-th instance of the batch.
         x_i and b_i are vectors and A_i is an n by n triangular matrix, for i = 1, ..., batch_count.

    The vector x is overwritten on b.

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.

    @param[in]
    uplo    [rocblas_fill]
            - rocblas_fill_upper:  A is an upper triangular matrix.
            - rocblas_fill_lower:  A is a  lower triangular matrix.

    @param[in]
    transA     [rocblas_operation]
            - rocblas_operation_none:    op(A) = A.
            - rocblas_operation_transpose:   op(A) = A^T
            - rocblas_operation_conjugate_transpose:  op(A) = A^H

    @param[in]
    diag    [rocblas_diagonal]
            - rocblas_diagonal_unit:     A is assumed to be unit triangular.
            - rocblas_diagonal_non_unit:  A is not assumed to be unit triangular.

    @param[in]
    n         [rocblas_int]
              n specifies the number of rows of each b_i. n >= 0.

    @param[in]
    A         device pointer to the matrix A_1 of the batch, of dimension ( lda, n ). If uplo == rocblas_fill_upper, the upper triangular part of the leading n-by-n array contains the matrix A_i, otherwise the lower triangular part of the leading n-by-n array contains the matrix A_i.

    @param[in]
    stride_A  [rocblas_stride]
              stride from the start of one A_i matrix to the next A_(i + 1).

    @param[in]
    lda       [rocblas_int]
              specifies the leading dimension of A_i. lda must be at least max( 1, n ).

    @param[in, out]
    x         device pointer to the vector x_1 of the batch. On exit, each x_i is overwritten with the transformed vector x_i.

    @param[in]
    stride_x [rocblas_stride]
             stride from the start of one x_i vector to the next x_(i + 1)

    @param[in]
    incx      [rocblas_int]
              specifies the increment for the elements of each x_i.

    @param[in]
    batch_count [rocblas_int]
                number of instances in the batch.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_strsv_strided_batched",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int32,
            UnsafePointer[Float32],
            Int32,
            Int64,
            UnsafePointer[Float32],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        uplo,
        trans_a,
        diag,
        n,
        _a,
        lda,
        stride__a,
        x,
        incx,
        stride_x,
        batch_count,
    )


fn rocblas_ztbmv_strided_batched_64(
    handle: Handle,
    uplo: Fill,
    trans: Operation,
    diag: Diagonal,
    n: Int64,
    k: Int64,
    _a: UnsafePointer[ComplexFloat64],
    lda: Int64,
    stride__a: Int64,
    x: UnsafePointer[ComplexFloat64],
    incx: Int64,
    stride_x: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_ztbmv_strided_batched_64",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int64,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int64,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int64,
            Int64,
            Int64,
        ) -> Status,
    ]()(
        handle,
        uplo,
        trans,
        diag,
        n,
        k,
        _a,
        lda,
        stride__a,
        x,
        incx,
        stride_x,
        batch_count,
    )


fn rocblas_cgbmv_batched_64(
    handle: Handle,
    trans: Operation,
    m: Int64,
    n: Int64,
    kl: Int64,
    ku: Int64,
    alpha: UnsafePointer[ComplexFloat32],
    _a: OpaquePointer,
    lda: Int64,
    x: OpaquePointer,
    incx: Int64,
    beta: UnsafePointer[ComplexFloat32],
    y: OpaquePointer,
    incy: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_cgbmv_batched_64",
        fn (
            Handle,
            Operation,
            Int64,
            Int64,
            Int64,
            Int64,
            UnsafePointer[ComplexFloat32],
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            UnsafePointer[ComplexFloat32],
            OpaquePointer,
            Int64,
            Int64,
        ) -> Status,
    ]()(
        handle,
        trans,
        m,
        n,
        kl,
        ku,
        alpha,
        _a,
        lda,
        x,
        incx,
        beta,
        y,
        incy,
        batch_count,
    )


fn rocblas_sspr2_batched_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    alpha: UnsafePointer[Float32],
    x: OpaquePointer,
    incx: Int64,
    y: OpaquePointer,
    incy: Int64,
    _ap: OpaquePointer,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_sspr2_batched_64",
        fn (
            Handle,
            Fill,
            Int64,
            UnsafePointer[Float32],
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
        ) -> Status,
    ]()(handle, uplo, n, alpha, x, incx, y, incy, _ap, batch_count)


fn rocblas_zhemv_strided_batched(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat64],
    _a: UnsafePointer[ComplexFloat64],
    lda: Int32,
    stride__a: Int64,
    x: UnsafePointer[ComplexFloat64],
    incx: Int32,
    stride_x: Int64,
    beta: UnsafePointer[ComplexFloat64],
    y: UnsafePointer[ComplexFloat64],
    incy: Int32,
    stride_y: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_zhemv_strided_batched",
        fn (
            Handle,
            Fill,
            Int32,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        uplo,
        n,
        alpha,
        _a,
        lda,
        stride__a,
        x,
        incx,
        stride_x,
        beta,
        y,
        incy,
        stride_y,
        batch_count,
    )


fn rocblas_sscal_batched(
    handle: Handle,
    n: Int32,
    alpha: UnsafePointer[Float32],
    x: OpaquePointer,
    incx: Int32,
    batch_count: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 1 API </b>.

    \\details
    scal_batched  scales each element of vector x_i with scalar alpha, for i = 1, ... , batch_count:

        x_i := alpha * x_i,
        where (x_i) is the i-th instance of the batch.

    @param[in]
    handle      [rocblas_handle]
                handle to the rocblas library context queue.
    @param[in]
    n           [rocblas_int]
                the number of elements in each x_i.
    @param[in]
    alpha       host pointer or device pointer for the scalar alpha.
    @param[in, out]
    x           device array of device pointers storing each vector x_i.
    @param[in]
    incx        [rocblas_int]
                specifies the increment for the elements of each x_i.
    @param[in]
    batch_count [rocblas_int]
                specifies the number of batches in x.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_sscal_batched",
        fn (
            Handle,
            Int32,
            UnsafePointer[Float32],
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(handle, n, alpha, x, incx, batch_count)


fn rocblas_sasum_strided_batched(
    handle: Handle,
    n: Int32,
    x: UnsafePointer[Float32],
    incx: Int32,
    stridex: Int64,
    batch_count: Int32,
    results: UnsafePointer[Float32],
) -> Status:
    """
    \\brief <b> BLAS Level 1 API </b>.

    \\details
    asum_strided_batched computes the sum of the magnitudes of elements of a real vectors x_i,
    or the sum of magnitudes of the real and imaginary parts of elements if x_i is a complex
    vector, for i = 1, ..., batch_count.

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    n         [rocblas_int]
              number of elements in each vector x_i.
    @param[in]
    x         device pointer to the first vector x_1.
    @param[in]
    incx      [rocblas_int]
              specifies the increment for the elements of each x_i. incx must be > 0.
    @param[in]
    stridex   [rocblas_stride]
              stride from the start of one vector (x_i) and the next one (x_i+1).
              There are no restrictions placed on stride_x. However, ensure that stride_x is of appropriate size. For a typical
              case this means stride_x >= n * incx.
    @param[out]
    results
              device pointer or host pointer to array for storing contiguous batch_count results.
              return is 0.0 if n, incx<=0.
    @param[in]
    batch_count [rocblas_int]
              number of instances in the batch.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_sasum_strided_batched",
        fn (
            Handle,
            Int32,
            UnsafePointer[Float32],
            Int32,
            Int64,
            Int32,
            UnsafePointer[Float32],
        ) -> Status,
    ]()(handle, n, x, incx, stridex, batch_count, results)


fn rocblas_dtbmv(
    handle: Handle,
    uplo: Fill,
    trans: Operation,
    diag: Diagonal,
    n: Int32,
    k: Int32,
    _a: UnsafePointer[Float64],
    lda: Int32,
    x: UnsafePointer[Float64],
    incx: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_dtbmv",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int32,
            Int32,
            UnsafePointer[Float64],
            Int32,
            UnsafePointer[Float64],
            Int32,
        ) -> Status,
    ]()(handle, uplo, trans, diag, n, k, _a, lda, x, incx)


fn rocblas_ctbmv_64(
    handle: Handle,
    uplo: Fill,
    trans: Operation,
    diag: Diagonal,
    n: Int64,
    k: Int64,
    _a: UnsafePointer[ComplexFloat32],
    lda: Int64,
    x: UnsafePointer[ComplexFloat32],
    incx: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_ctbmv_64",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int64,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int64,
            UnsafePointer[ComplexFloat32],
            Int64,
        ) -> Status,
    ]()(handle, uplo, trans, diag, n, k, _a, lda, x, incx)


fn rocblas_dznrm2_strided_batched(
    handle: Handle,
    n: Int32,
    x: UnsafePointer[ComplexFloat64],
    incx: Int32,
    stridex: Int64,
    batch_count: Int32,
    results: UnsafePointer[Float64],
) -> Status:
    return _get_dylib_function[
        "rocblas_dznrm2_strided_batched",
        fn (
            Handle,
            Int32,
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            Int32,
            UnsafePointer[Float64],
        ) -> Status,
    ]()(handle, n, x, incx, stridex, batch_count, results)


fn rocblas_chpmv_batched_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    alpha: UnsafePointer[ComplexFloat32],
    _ap: OpaquePointer,
    x: OpaquePointer,
    incx: Int64,
    beta: UnsafePointer[ComplexFloat32],
    y: OpaquePointer,
    incy: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_chpmv_batched_64",
        fn (
            Handle,
            Fill,
            Int64,
            UnsafePointer[ComplexFloat32],
            OpaquePointer,
            OpaquePointer,
            Int64,
            UnsafePointer[ComplexFloat32],
            OpaquePointer,
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, uplo, n, alpha, _ap, x, incx, beta, y, incy, batch_count)


fn rocblas_ssyr2(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    alpha: UnsafePointer[Float32],
    x: UnsafePointer[Float32],
    incx: Int32,
    y: UnsafePointer[Float32],
    incy: Int32,
    _a: UnsafePointer[Float32],
    lda: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 2 API </b>.

    \\details
    syr2 performs the matrix-vector operations:

        A := A + alpha*x*y**T + alpha*y*x**T
        where alpha is a scalar, x and y are vectors, and A is an
        n by n symmetric matrix.

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    uplo      [rocblas_fill]
            specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
            - if rocblas_fill_upper, the lower part of A is not referenced
            - if rocblas_fill_lower, the upper part of A is not referenced

    @param[in]
    n         [rocblas_int]
              the number of rows and columns of matrix A.
    @param[in]
    alpha
              device pointer or host pointer to scalar alpha.
    @param[in]
    x         device pointer storing vector x.
    @param[in]
    incx      [rocblas_int]
              specifies the increment for the elements of x.
    @param[in]
    y         device pointer storing vector y.
    @param[in]
    incy      [rocblas_int]
              specifies the increment for the elements of y.
    @param[in, out]
    A         device pointer storing matrix A.
    @param[in]
    lda       [rocblas_int]
              specifies the leading dimension of A.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_ssyr2",
        fn (
            Handle,
            Fill,
            Int32,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int32,
            UnsafePointer[Float32],
            Int32,
            UnsafePointer[Float32],
            Int32,
        ) -> Status,
    ]()(handle, uplo, n, alpha, x, incx, y, incy, _a, lda)


fn rocblas_zsyr_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    alpha: UnsafePointer[ComplexFloat64],
    x: UnsafePointer[ComplexFloat64],
    incx: Int64,
    _a: UnsafePointer[ComplexFloat64],
    lda: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_zsyr_64",
        fn (
            Handle,
            Fill,
            Int64,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int64,
            UnsafePointer[ComplexFloat64],
            Int64,
        ) -> Status,
    ]()(handle, uplo, n, alpha, x, incx, _a, lda)


fn rocblas_ctrsm_strided_batched_64(
    handle: Handle,
    side: Side,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    m: Int64,
    n: Int64,
    alpha: UnsafePointer[ComplexFloat32],
    _a: UnsafePointer[ComplexFloat32],
    lda: Int64,
    stride_a: Int64,
    _b: UnsafePointer[ComplexFloat32],
    ldb: Int64,
    stride_b: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_ctrsm_strided_batched_64",
        fn (
            Handle,
            Side,
            Fill,
            Operation,
            Diagonal,
            Int64,
            Int64,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int64,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int64,
            Int64,
            Int64,
        ) -> Status,
    ]()(
        handle,
        side,
        uplo,
        trans_a,
        diag,
        m,
        n,
        alpha,
        _a,
        lda,
        stride_a,
        _b,
        ldb,
        stride_b,
        batch_count,
    )


fn rocblas_sgeam_strided_batched(
    handle: Handle,
    trans_a: Operation,
    trans_b: Operation,
    m: Int32,
    n: Int32,
    alpha: UnsafePointer[Float32],
    _a: UnsafePointer[Float32],
    lda: Int32,
    stride__a: Int64,
    beta: UnsafePointer[Float32],
    _b: UnsafePointer[Float32],
    ldb: Int32,
    stride__b: Int64,
    _c: UnsafePointer[Float32],
    ldc: Int32,
    stride__c: Int64,
    batch_count: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 3 API </b>.

    \\details
    geam_strided_batched performs one of the batched matrix-matrix operations:

        C_i = alpha*op( A_i ) + beta*op( B_i )  for i = 0, 1, ... batch_count - 1,

        where alpha and beta are scalars, and op(A_i), op(B_i) and C_i are m by n matrices
        and op( X ) is one of

        op( X ) = X      or
        op( X ) = X**T

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.

    @param[in]
    transA    [rocblas_operation]
              specifies the form of op( A ).

    @param[in]
    transB    [rocblas_operation]
              specifies the form of op( B ).

    @param[in]
    m         [rocblas_int]
              matrix dimension m.

    @param[in]
    n         [rocblas_int]
              matrix dimension n.

    @param[in]
    alpha     device pointer or host pointer specifying the scalar alpha.

    @param[in]
    A         device pointer to the first matrix A_0 on the GPU.
              Each A_i is of dimension ( lda, k ), where k is m
              when  transA == rocblas_operation_none and
              is  n  when  transA == rocblas_operation_transpose.

    @param[in]
    lda       [rocblas_int]
              specifies the leading dimension of A.

    @param[in]
    stride_A  [rocblas_stride]
              stride from the start of one matrix (A_i) and the next one (A_i+1).

    @param[in]
    beta      device pointer or host pointer specifying the scalar beta.

    @param[in]
    B         pointer to the first matrix B_0 on the GPU.
              Each B_i is of dimension ( ldb, k ), where k is m
              when  transB == rocblas_operation_none and
              is  n  when  transB == rocblas_operation_transpose.

    @param[in]
    ldb       [rocblas_int]
              specifies the leading dimension of B.

    @param[in]
    stride_B  [rocblas_stride]
              stride from the start of one matrix (B_i) and the next one (B_i+1)

    @param[in, out]
    C         pointer to the first matrix C_0 on the GPU.
              Each C_i is of dimension ( ldc, n ).

    @param[in]
    ldc       [rocblas_int]
              specifies the leading dimension of C.

    @param[in]
    stride_C  [rocblas_stride]
              stride from the start of one matrix (C_i) and the next one (C_i+1).

    @param[in]
    batch_count [rocblas_int]
                number of instances i in the batch.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_sgeam_strided_batched",
        fn (
            Handle,
            Operation,
            Operation,
            Int32,
            Int32,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int32,
            Int64,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int32,
            Int64,
            UnsafePointer[Float32],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        trans_a,
        trans_b,
        m,
        n,
        alpha,
        _a,
        lda,
        stride__a,
        beta,
        _b,
        ldb,
        stride__b,
        _c,
        ldc,
        stride__c,
        batch_count,
    )


fn rocblas_ztrmm_strided_batched(
    handle: Handle,
    side: Side,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    m: Int32,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat64],
    _a: UnsafePointer[ComplexFloat64],
    lda: Int32,
    stride__a: Int64,
    _b: UnsafePointer[ComplexFloat64],
    ldb: Int32,
    stride__b: Int64,
    _c: UnsafePointer[ComplexFloat64],
    ldc: Int32,
    stride__c: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_ztrmm_strided_batched",
        fn (
            Handle,
            Side,
            Fill,
            Operation,
            Diagonal,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        side,
        uplo,
        trans_a,
        diag,
        m,
        n,
        alpha,
        _a,
        lda,
        stride__a,
        _b,
        ldb,
        stride__b,
        _c,
        ldc,
        stride__c,
        batch_count,
    )


fn rocblas_set_optimal_device_memory_size_impl(
    handle: Handle, count: Int
) -> Status:
    return _get_dylib_function[
        "rocblas_set_optimal_device_memory_size_impl",
        fn (Handle, Int) -> Status,
    ]()(handle, count)


fn rocblas_zdotc(
    handle: Handle,
    n: Int32,
    x: UnsafePointer[ComplexFloat64],
    incx: Int32,
    y: UnsafePointer[ComplexFloat64],
    incy: Int32,
    result: UnsafePointer[ComplexFloat64],
) -> Status:
    return _get_dylib_function[
        "rocblas_zdotc",
        fn (
            Handle,
            Int32,
            UnsafePointer[ComplexFloat64],
            Int32,
            UnsafePointer[ComplexFloat64],
            Int32,
            UnsafePointer[ComplexFloat64],
        ) -> Status,
    ]()(handle, n, x, incx, y, incy, result)


fn rocblas_dsyr_batched(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    alpha: UnsafePointer[Float64],
    x: OpaquePointer,
    incx: Int32,
    _a: OpaquePointer,
    lda: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_dsyr_batched",
        fn (
            Handle,
            Fill,
            Int32,
            UnsafePointer[Float64],
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(handle, uplo, n, alpha, x, incx, _a, lda, batch_count)


fn rocblas_ctbmv_batched_64(
    handle: Handle,
    uplo: Fill,
    trans: Operation,
    diag: Diagonal,
    n: Int64,
    k: Int64,
    _a: OpaquePointer,
    lda: Int64,
    x: OpaquePointer,
    incx: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_ctbmv_batched_64",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int64,
            Int64,
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, uplo, trans, diag, n, k, _a, lda, x, incx, batch_count)


fn rocblas_dotc_strided_batched_ex(
    handle: Handle,
    n: Int32,
    x: OpaquePointer,
    x_type: DataType,
    incx: Int32,
    stride_x: Int64,
    y: OpaquePointer,
    y_type: DataType,
    incy: Int32,
    stride_y: Int64,
    batch_count: Int32,
    result: OpaquePointer,
    result_type: DataType,
    execution_type: DataType,
) -> Status:
    return _get_dylib_function[
        "rocblas_dotc_strided_batched_ex",
        fn (
            Handle,
            Int32,
            OpaquePointer,
            DataType,
            Int32,
            Int64,
            OpaquePointer,
            DataType,
            Int32,
            Int64,
            Int32,
            OpaquePointer,
            DataType,
            DataType,
        ) -> Status,
    ]()(
        handle,
        n,
        x,
        x_type,
        incx,
        stride_x,
        y,
        y_type,
        incy,
        stride_y,
        batch_count,
        result,
        result_type,
        execution_type,
    )


fn rocblas_cswap(
    handle: Handle,
    n: Int32,
    x: UnsafePointer[ComplexFloat32],
    incx: Int32,
    y: UnsafePointer[ComplexFloat32],
    incy: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_cswap",
        fn (
            Handle,
            Int32,
            UnsafePointer[ComplexFloat32],
            Int32,
            UnsafePointer[ComplexFloat32],
            Int32,
        ) -> Status,
    ]()(handle, n, x, incx, y, incy)


fn rocblas_dot_ex(
    handle: Handle,
    n: Int32,
    x: OpaquePointer,
    x_type: DataType,
    incx: Int32,
    y: OpaquePointer,
    y_type: DataType,
    incy: Int32,
    result: OpaquePointer,
    result_type: DataType,
    execution_type: DataType,
) -> Status:
    """
    \\brief <b> BLAS EX API </b>.

    \\details
    dot_ex  performs the dot product of vectors x and y.

        result = x * y;

    dotc_ex  performs the dot product of the conjugate of complex vector x and complex vector y

        result = conjugate (x) * y;

    Currently supported datatypes are as follows:

    --------------------------------------------------
    | x_type | y_type | result_type | execution_type |
    |--------|--------|-------------|----------------|
    | f16_r  | f16_r  |    f16_r    |     f16_r      |
    | f16_r  | f16_r  |    f16_r    |     f32_r      |
    | bf16_r | bf16_r |    bf16_r   |     f32_r      |
    | f32_r  | f32_r  |    f32_r    |     f32_r      |
    | f32_r  | f32_r  |    f64_r    |     f64_r      |
    | f64_r  | f64_r  |    f64_r    |     f64_r      |
    | f32_c  | f32_c  |    f32_c    |     f32_c      |
    | f64_c  | f64_c  |    f64_c    |     f64_c      |
    --------------------------------------------------

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    n         [rocblas_int]
              the number of elements in x and y.
    @param[in]
    x         device pointer storing vector x.
    @param[in]
    x_type [rocblas_datatype]
           specifies the datatype of vector x.
    @param[in]
    incx      [rocblas_int]
              specifies the increment for the elements of y.
    @param[in]
    y         device pointer storing vector y.
    @param[in]
    y_type [rocblas_datatype]
          specifies the datatype of vector y.
    @param[in]
    incy      [rocblas_int]
              specifies the increment for the elements of y.
    @param[in, out]
    result
              device pointer or host pointer to store the dot product.
              return is 0.0 if n <= 0.
    @param[in]
    result_type [rocblas_datatype]
                specifies the datatype of the result.
    @param[in]
    execution_type [rocblas_datatype]
                  specifies the datatype of computation.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_dot_ex",
        fn (
            Handle,
            Int32,
            OpaquePointer,
            DataType,
            Int32,
            OpaquePointer,
            DataType,
            Int32,
            OpaquePointer,
            DataType,
            DataType,
        ) -> Status,
    ]()(
        handle,
        n,
        x,
        x_type,
        incx,
        y,
        y_type,
        incy,
        result,
        result_type,
        execution_type,
    )


fn rocblas_cspr_batched_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    alpha: UnsafePointer[ComplexFloat32],
    x: OpaquePointer,
    incx: Int64,
    _ap: OpaquePointer,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_cspr_batched_64",
        fn (
            Handle,
            Fill,
            Int64,
            UnsafePointer[ComplexFloat32],
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
        ) -> Status,
    ]()(handle, uplo, n, alpha, x, incx, _ap, batch_count)


fn rocblas_dswap_batched_64(
    handle: Handle,
    n: Int64,
    x: OpaquePointer,
    incx: Int64,
    y: OpaquePointer,
    incy: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_dswap_batched_64",
        fn (
            Handle,
            Int64,
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, n, x, incx, y, incy, batch_count)


fn rocblas_crot_64(
    handle: Handle,
    n: Int64,
    x: UnsafePointer[ComplexFloat32],
    incx: Int64,
    y: UnsafePointer[ComplexFloat32],
    incy: Int64,
    c: UnsafePointer[Float32],
    s: UnsafePointer[ComplexFloat32],
) -> Status:
    return _get_dylib_function[
        "rocblas_crot_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int64,
            UnsafePointer[ComplexFloat32],
            Int64,
            UnsafePointer[Float32],
            UnsafePointer[ComplexFloat32],
        ) -> Status,
    ]()(handle, n, x, incx, y, incy, c, s)


fn rocblas_isamax_batched(
    handle: Handle,
    n: Int32,
    x: OpaquePointer,
    incx: Int32,
    batch_count: Int32,
    result: UnsafePointer[Int32],
) -> Status:
    """
    \\brief <b> BLAS Level 1 API </b>.

    \\details
     amax_batched finds the first index of the element of maximum magnitude of each vector x_i in a batch, for i = 1, ..., batch_count.

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    n         [rocblas_int]
              number of elements in each vector x_i.
    @param[in]
    x         device array of device pointers storing each vector x_i.
    @param[in]
    incx      [rocblas_int]
              specifies the increment for the elements of each x_i. incx must be > 0.
    @param[in]
    batch_count [rocblas_int]
              number of instances in the batch. Must be > 0.
    @param[out]
    result
              device or host array of pointers of batch_count size for results.
              return is 0 if n, incx<=0.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_isamax_batched",
        fn (
            Handle,
            Int32,
            OpaquePointer,
            Int32,
            Int32,
            UnsafePointer[Int32],
        ) -> Status,
    ]()(handle, n, x, incx, batch_count, result)


fn rocblas_drotg_64(
    handle: Handle,
    a: UnsafePointer[Float64],
    b: UnsafePointer[Float64],
    c: UnsafePointer[Float64],
    s: UnsafePointer[Float64],
) -> Status:
    return _get_dylib_function[
        "rocblas_drotg_64",
        fn (
            Handle,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            UnsafePointer[Float64],
        ) -> Status,
    ]()(handle, a, b, c, s)


fn rocblas_zaxpy_batched(
    handle: Handle,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat64],
    x: OpaquePointer,
    incx: Int32,
    y: OpaquePointer,
    incy: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_zaxpy_batched",
        fn (
            Handle,
            Int32,
            UnsafePointer[ComplexFloat64],
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(handle, n, alpha, x, incx, y, incy, batch_count)


fn rocblas_cgeam(
    handle: Handle,
    trans_a: Operation,
    trans_b: Operation,
    m: Int32,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat32],
    _a: UnsafePointer[ComplexFloat32],
    lda: Int32,
    beta: UnsafePointer[ComplexFloat32],
    _b: UnsafePointer[ComplexFloat32],
    ldb: Int32,
    _c: UnsafePointer[ComplexFloat32],
    ldc: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_cgeam",
        fn (
            Handle,
            Operation,
            Operation,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int32,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int32,
            UnsafePointer[ComplexFloat32],
            Int32,
        ) -> Status,
    ]()(handle, trans_a, trans_b, m, n, alpha, _a, lda, beta, _b, ldb, _c, ldc)


fn rocblas_ztbsv_batched_64(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int64,
    k: Int64,
    _a: OpaquePointer,
    lda: Int64,
    x: OpaquePointer,
    incx: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_ztbsv_batched_64",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int64,
            Int64,
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, uplo, trans_a, diag, n, k, _a, lda, x, incx, batch_count)


fn rocblas_dot_strided_batched_ex_64(
    handle: Handle,
    n: Int64,
    x: OpaquePointer,
    x_type: DataType,
    incx: Int64,
    stride_x: Int64,
    y: OpaquePointer,
    y_type: DataType,
    incy: Int64,
    stride_y: Int64,
    batch_count: Int64,
    result: OpaquePointer,
    result_type: DataType,
    execution_type: DataType,
) -> Status:
    return _get_dylib_function[
        "rocblas_dot_strided_batched_ex_64",
        fn (
            Handle,
            Int64,
            OpaquePointer,
            DataType,
            Int64,
            Int64,
            OpaquePointer,
            DataType,
            Int64,
            Int64,
            Int64,
            OpaquePointer,
            DataType,
            DataType,
        ) -> Status,
    ]()(
        handle,
        n,
        x,
        x_type,
        incx,
        stride_x,
        y,
        y_type,
        incy,
        stride_y,
        batch_count,
        result,
        result_type,
        execution_type,
    )


fn rocblas_stbmv(
    handle: Handle,
    uplo: Fill,
    trans: Operation,
    diag: Diagonal,
    n: Int32,
    k: Int32,
    _a: UnsafePointer[Float32],
    lda: Int32,
    x: UnsafePointer[Float32],
    incx: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 2 API </b>.

    \\details
    tbmv performs one of the matrix-vector operations:

        x := A*x      or
        x := A**T*x   or
        x := A**H*x,
        x is a vectors and A is a banded n by n matrix (see description below).

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    uplo      [rocblas_fill]
            - rocblas_fill_upper: A is an upper banded triangular matrix.
            - rocblas_fill_lower: A is a  lower banded triangular matrix.
    @param[in]
    trans     [rocblas_operation]
              indicates whether matrix A is transposed (conjugated) or not.
    @param[in]
    diag      [rocblas_diagonal]
            - rocblas_diagonal_unit: The main diagonal of A is assumed to consist of only
                                     1's and is not referenced.
            - rocblas_diagonal_non_unit: No assumptions are made of A's main diagonal.
    @param[in]
    n         [rocblas_int]
              the number of rows and columns of the matrix represented by A.
    @param[in]
    k         [rocblas_int]

            if uplo == rocblas_fill_upper, k specifies the number of super-diagonals
            of the matrix A.

            if uplo == rocblas_fill_lower, k specifies the number of sub-diagonals
            of the matrix A.
            k must satisfy k > 0 && k < lda.
    @param[in]
    A         device pointer storing banded triangular matrix A.

            if uplo == rocblas_fill_upper:
                The matrix represented is an upper banded triangular matrix
                with the main diagonal and k super-diagonals, everything
                else can be assumed to be 0.
                The matrix is compacted so that the main diagonal resides on the k'th
                row, the first super diagonal resides on the RHS of the k-1'th row, etc,
                with the k'th diagonal on the RHS of the 0'th row.
                   Ex: (rocblas_fill_upper; n = 5; k = 2)
                      1 6 9 0 0              0 0 9 8 7
                      0 2 7 8 0              0 6 7 8 9
                      0 0 3 8 7     ---->    1 2 3 4 5
                      0 0 0 4 9              0 0 0 0 0
                      0 0 0 0 5              0 0 0 0 0

            if uplo == rocblas_fill_lower:
                The matrix represented is a lower banded triangular matrix
                with the main diagonal and k sub-diagonals, everything else can be
                assumed to be 0.
                The matrix is compacted so that the main diagonal resides on the 0'th row,
                working up to the k'th diagonal residing on the LHS of the k'th row.
                   Ex: (rocblas_fill_lower; n = 5; k = 2)
                      1 0 0 0 0              1 2 3 4 5
                      6 2 0 0 0              6 7 8 9 0
                      9 7 3 0 0     ---->    9 8 7 0 0
                      0 8 8 4 0              0 0 0 0 0
                      0 0 7 9 5              0 0 0 0 0
    @param[in]
    lda       [rocblas_int]
              specifies the leading dimension of A. lda must satisfy lda > k.
    @param[in, out]
    x         device pointer storing vector x.
    @param[in]
    incx      [rocblas_int]
              specifies the increment for the elements of x.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_stbmv",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int32,
            Int32,
            UnsafePointer[Float32],
            Int32,
            UnsafePointer[Float32],
            Int32,
        ) -> Status,
    ]()(handle, uplo, trans, diag, n, k, _a, lda, x, incx)


fn rocblas_set_workspace(
    handle: Handle, addr: OpaquePointer, size: Int
) -> Status:
    """\\brief
    \\details
    Sets the device workspace for the handle to use.

    Any previously allocated device memory managed by the handle is freed.

    Returns rocblas_status_invalid_handle if handle is nullptr; rocblas_status_success otherwise
    @param[in]
    handle          rocblas handle
    @param[in]
    addr            address of workspace memory
    @param[in]
    size            size of workspace memory

    ****************************************************************************.
    """
    return _get_dylib_function[
        "rocblas_set_workspace",
        fn (Handle, OpaquePointer, Int) -> Status,
    ]()(handle, addr, size)


fn rocblas_dscal_strided_batched(
    handle: Handle,
    n: Int32,
    alpha: UnsafePointer[Float64],
    x: UnsafePointer[Float64],
    incx: Int32,
    stride_x: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_dscal_strided_batched",
        fn (
            Handle,
            Int32,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(handle, n, alpha, x, incx, stride_x, batch_count)


fn rocblas_dsyr2k_batched(
    handle: Handle,
    uplo: Fill,
    trans: Operation,
    n: Int32,
    k: Int32,
    alpha: UnsafePointer[Float64],
    _a: OpaquePointer,
    lda: Int32,
    _b: OpaquePointer,
    ldb: Int32,
    beta: UnsafePointer[Float64],
    _c: OpaquePointer,
    ldc: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_dsyr2k_batched",
        fn (
            Handle,
            Fill,
            Operation,
            Int32,
            Int32,
            UnsafePointer[Float64],
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            UnsafePointer[Float64],
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(
        handle,
        uplo,
        trans,
        n,
        k,
        alpha,
        _a,
        lda,
        _b,
        ldb,
        beta,
        _c,
        ldc,
        batch_count,
    )


fn rocblas_cher_strided_batched(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    alpha: UnsafePointer[Float32],
    x: UnsafePointer[ComplexFloat32],
    incx: Int32,
    stride_x: Int64,
    _a: UnsafePointer[ComplexFloat32],
    lda: Int32,
    stride__a: Int64,
    batch_count: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 2 API </b>.

    \\details
    her_strided_batched performs the matrix-vector operations:

        A_i := A_i + alpha*x_i*x_i**H
        where alpha is a real scalar, x_i is a vector, and A_i is an
        n by n Hermitian matrix, for i = 1, ..., batch_count.

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    uplo      [rocblas_fill]
              specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
            - rocblas_fill_upper: The upper triangular part of each A_i is supplied in A.
            - rocblas_fill_lower: The lower triangular part of each A_i is supplied in A.
    @param[in]
    n         [rocblas_int]
              the number of rows and columns of each matrix A_i. Must be at least 0.
    @param[in]
    alpha
              device pointer or host pointer to scalar alpha.
    @param[in]
    x         device pointer pointing to the first vector (x_1).
    @param[in]
    incx      [rocblas_int]
              specifies the increment for the elements of each x_i.
    @param[in]
    stride_x  [rocblas_stride]
              stride from the start of one vector (x_i) and the next one (x_i+1).
    @param[in, out]
    A         device array of device pointers storing the specified triangular portion of
              each Hermitian matrix A_i. Points to the first matrix (A_1).

                    if uplo == rocblas_fill_upper:
                        The upper triangular portion of each Hermitian matrix A_i is supplied.
                        The lower triangular portion of each A_i will not be touched.

                    if uplo == rocblas_fill_lower:
                        The lower triangular portion of each Hermitian matrix A_i is supplied.
                        The upper triangular portion of each A_i will not be touched.
                Note that the imaginary part of the diagonal elements are not accessed
                and are assumed to be 0.
    @param[in]
    lda       [rocblas_int]
              specifies the leading dimension of each A_i.
    @param[in]
    stride_A    [rocblas_stride]
                stride from the start of one (A_i) and the next (A_i+1).
    @param[in]
    batch_count [rocblas_int]
                number of instances in the batch.
    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_cher_strided_batched",
        fn (
            Handle,
            Fill,
            Int32,
            UnsafePointer[Float32],
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        uplo,
        n,
        alpha,
        x,
        incx,
        stride_x,
        _a,
        lda,
        stride__a,
        batch_count,
    )


fn rocblas_zsymm_batched(
    handle: Handle,
    side: Side,
    uplo: Fill,
    m: Int32,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat64],
    _a: OpaquePointer,
    lda: Int32,
    _b: OpaquePointer,
    ldb: Int32,
    beta: UnsafePointer[ComplexFloat64],
    _c: OpaquePointer,
    ldc: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_zsymm_batched",
        fn (
            Handle,
            Side,
            Fill,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat64],
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            UnsafePointer[ComplexFloat64],
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(
        handle,
        side,
        uplo,
        m,
        n,
        alpha,
        _a,
        lda,
        _b,
        ldb,
        beta,
        _c,
        ldc,
        batch_count,
    )


fn rocblas_dasum_64(
    handle: Handle,
    n: Int64,
    x: UnsafePointer[Float64],
    incx: Int64,
    result: UnsafePointer[Float64],
) -> Status:
    return _get_dylib_function[
        "rocblas_dasum_64",
        fn (
            Handle, Int64, UnsafePointer[Float64], Int64, UnsafePointer[Float64]
        ) -> Status,
    ]()(handle, n, x, incx, result)


fn rocblas_strmv_batched(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int32,
    _a: UnsafePointer[UnsafePointer[Float32]],
    lda: Int32,
    x: UnsafePointer[UnsafePointer[Float32]],
    incx: Int32,
    batch_count: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 2 API </b>.

    \\details
    trmv_batched performs one of the matrix-vector operations:

        x_i = A_i*x_i or
        x_i = A_i**T*x_i or
        x_i = A_i**H*x_i, 0 < i < batch_count
        where x_i is an n element vector and A_i is an n by n (unit, or non-unit, upper or lower triangular matrix)
        The vectors x_i are overwritten.

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.

    @param[in]
    uplo    [rocblas_fill]
            - rocblas_fill_upper:  A_i is an upper triangular matrix.
            - rocblas_fill_lower:  A_i is a  lower triangular matrix.

    @param[in]
    transA     [rocblas_operation]
            - rocblas_operation_none:    op(A) = A.
            - rocblas_operation_transpose:   op(A) = A^T
            - rocblas_operation_conjugate_transpose:  op(A) = A^H

    @param[in]
    diag    [rocblas_diagonal]
            - rocblas_diagonal_unit:     A_i is assumed to be unit triangular.
            - rocblas_diagonal_non_unit:  A_i is not assumed to be unit triangular.

    @param[in]
    n         [rocblas_int]
              n specifies the number of rows of matrices A_i. n >= 0.

    @param[in]
    A         device pointer to an array of device pointers to the A_i matrices, of dimension ( lda, n ). If uplo == rocblas_fill_upper, the upper triangular part of the leading n-by-n array contains the matrix A_i, otherwise the lower triangular part of the leading n-by-n array contains the matrix A_i.

    @param[in]
    lda       [rocblas_int]
              specifies the leading dimension of A_i. lda must be at least max( 1, n ).

    @param[in, out]
    x         device pointer to an array of device pointers to the x_i vectors. On exit, each x_i is overwritten with the transformed vector x_i.

    @param[in]
    incx      [rocblas_int]
              specifies the increment for the elements of vectors x_i.

    @param[in]
    batch_count [rocblas_int]
              The number of batched matrices/vectors.


    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_strmv_batched",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int32,
            UnsafePointer[UnsafePointer[Float32]],
            Int32,
            UnsafePointer[UnsafePointer[Float32]],
            Int32,
            Int32,
        ) -> Status,
    ]()(handle, uplo, trans_a, diag, n, _a, lda, x, incx, batch_count)


fn rocblas_ssymv_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    alpha: UnsafePointer[Float32],
    _a: UnsafePointer[Float32],
    lda: Int64,
    x: UnsafePointer[Float32],
    incx: Int64,
    beta: UnsafePointer[Float32],
    y: UnsafePointer[Float32],
    incy: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_ssymv_64",
        fn (
            Handle,
            Fill,
            Int64,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int64,
            UnsafePointer[Float32],
            Int64,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int64,
        ) -> Status,
    ]()(handle, uplo, n, alpha, _a, lda, x, incx, beta, y, incy)


fn rocblas_zgerc(
    handle: Handle,
    m: Int32,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat64],
    x: UnsafePointer[ComplexFloat64],
    incx: Int32,
    y: UnsafePointer[ComplexFloat64],
    incy: Int32,
    _a: UnsafePointer[ComplexFloat64],
    lda: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_zgerc",
        fn (
            Handle,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int32,
            UnsafePointer[ComplexFloat64],
            Int32,
            UnsafePointer[ComplexFloat64],
            Int32,
        ) -> Status,
    ]()(handle, m, n, alpha, x, incx, y, incy, _a, lda)


fn rocblas_drotg_strided_batched(
    handle: Handle,
    a: UnsafePointer[Float64],
    stride_a: Int64,
    b: UnsafePointer[Float64],
    stride_b: Int64,
    c: UnsafePointer[Float64],
    stride_c: Int64,
    s: UnsafePointer[Float64],
    stride_s: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_drotg_strided_batched",
        fn (
            Handle,
            UnsafePointer[Float64],
            Int64,
            UnsafePointer[Float64],
            Int64,
            UnsafePointer[Float64],
            Int64,
            UnsafePointer[Float64],
            Int64,
            Int32,
        ) -> Status,
    ]()(handle, a, stride_a, b, stride_b, c, stride_c, s, stride_s, batch_count)


fn rocblas_stbsv_strided_batched_64(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int64,
    k: Int64,
    _a: UnsafePointer[Float32],
    lda: Int64,
    stride__a: Int64,
    x: UnsafePointer[Float32],
    incx: Int64,
    stride_x: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_stbsv_strided_batched_64",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int64,
            Int64,
            UnsafePointer[Float32],
            Int64,
            Int64,
            UnsafePointer[Float32],
            Int64,
            Int64,
            Int64,
        ) -> Status,
    ]()(
        handle,
        uplo,
        trans_a,
        diag,
        n,
        k,
        _a,
        lda,
        stride__a,
        x,
        incx,
        stride_x,
        batch_count,
    )


fn rocblas_zsyrkx_batched(
    handle: Handle,
    uplo: Fill,
    trans: Operation,
    n: Int32,
    k: Int32,
    alpha: UnsafePointer[ComplexFloat64],
    _a: OpaquePointer,
    lda: Int32,
    _b: OpaquePointer,
    ldb: Int32,
    beta: UnsafePointer[ComplexFloat64],
    _c: OpaquePointer,
    ldc: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_zsyrkx_batched",
        fn (
            Handle,
            Fill,
            Operation,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat64],
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            UnsafePointer[ComplexFloat64],
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(
        handle,
        uplo,
        trans,
        n,
        k,
        alpha,
        _a,
        lda,
        _b,
        ldb,
        beta,
        _c,
        ldc,
        batch_count,
    )


fn rocblas_dtpsv(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int32,
    _ap: UnsafePointer[Float64],
    x: UnsafePointer[Float64],
    incx: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_dtpsv",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int32,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int32,
        ) -> Status,
    ]()(handle, uplo, trans_a, diag, n, _ap, x, incx)


fn rocblas_zgemv(
    handle: Handle,
    trans: Operation,
    m: Int32,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat64],
    _a: UnsafePointer[ComplexFloat64],
    lda: Int32,
    x: UnsafePointer[ComplexFloat64],
    incx: Int32,
    beta: UnsafePointer[ComplexFloat64],
    y: UnsafePointer[ComplexFloat64],
    incy: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_zgemv",
        fn (
            Handle,
            Operation,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int32,
            UnsafePointer[ComplexFloat64],
            Int32,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int32,
        ) -> Status,
    ]()(handle, trans, m, n, alpha, _a, lda, x, incx, beta, y, incy)


fn rocblas_sspr_strided_batched(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    alpha: UnsafePointer[Float32],
    x: UnsafePointer[Float32],
    incx: Int32,
    stride_x: Int64,
    _ap: UnsafePointer[Float32],
    stride__a: Int64,
    batch_count: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 2 API </b>.

    \\details
    spr_strided_batched performs the matrix-vector operations:

        A_i := A_i + alpha*x_i*x_i**T
        where alpha is a scalar, x_i is a vector, and A_i is an
        n by n symmetric matrix, supplied in packed form, for i = 1, ..., batch_count.

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    uplo      [rocblas_fill]
            specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
            - rocblas_fill_upper: The upper triangular part of each A_i is supplied in AP.
            - rocblas_fill_lower: The lower triangular part of each A_i is supplied in AP.
    @param[in]
    n         [rocblas_int]
            the number of rows and columns of each matrix A_i. Must be at least 0.
    @param[in]
    alpha
              device pointer or host pointer to scalar alpha.
    @param[in]
    x         device pointer pointing to the first vector (x_1).
    @param[in]
    incx      [rocblas_int]
              specifies the increment for the elements of each x_i.
    @param[in]
    stride_x  [rocblas_stride]
              stride from the start of one vector (x_i) and the next one (x_i+1).
    @param[in, out]
    AP        device pointer storing the packed version of the specified triangular portion of
              each symmetric matrix A_i. Points to the first A_1.

                    if uplo == rocblas_fill_upper:
                        The upper triangular portion of each symmetric matrix A_i is supplied.
                        The matrix is compacted so that AP contains the triangular portion
                        column-by-column
                        so that:
                        AP(0) = A(0,0)
                        AP(1) = A(0,1)
                        AP(2) = A(1,1), etc.
                            Ex: (rocblas_fill_upper; n = 4)
                                1 2 4 7
                                2 3 5 8   -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
                                4 5 6 9
                                7 8 9 0

                    if uplo == rocblas_fill_lower:
                        The lower triangular portion of each symmetric matrix A_i is supplied.
                        The matrix is compacted so that AP contains the triangular portion
                        column-by-column
                        so that:
                        AP(0) = A(0,0)
                        AP(1) = A(1,0)
                        AP(2) = A(2,1), etc.
                            Ex: (rocblas_fill_lower; n = 4)
                                1 2 3 4
                                2 5 6 7    -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
                                3 6 8 9
                                4 7 9 0
    @param[in]
    stride_A    [rocblas_stride]
                stride from the start of one (A_i) and the next (A_i+1).
    @param[in]
    batch_count [rocblas_int]
                number of instances in the batch.
    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_sspr_strided_batched",
        fn (
            Handle,
            Fill,
            Int32,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int32,
            Int64,
            UnsafePointer[Float32],
            Int64,
            Int32,
        ) -> Status,
    ]()(handle, uplo, n, alpha, x, incx, stride_x, _ap, stride__a, batch_count)


fn rocblas_zscal_strided_batched(
    handle: Handle,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat64],
    x: UnsafePointer[ComplexFloat64],
    incx: Int32,
    stride_x: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_zscal_strided_batched",
        fn (
            Handle,
            Int32,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(handle, n, alpha, x, incx, stride_x, batch_count)


fn rocblas_dtbsv(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int32,
    k: Int32,
    _a: UnsafePointer[Float64],
    lda: Int32,
    x: UnsafePointer[Float64],
    incx: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_dtbsv",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int32,
            Int32,
            UnsafePointer[Float64],
            Int32,
            UnsafePointer[Float64],
            Int32,
        ) -> Status,
    ]()(handle, uplo, trans_a, diag, n, k, _a, lda, x, incx)


fn rocblas_drotmg_batched_64(
    handle: Handle,
    d1: OpaquePointer,
    d2: OpaquePointer,
    x1: OpaquePointer,
    y1: OpaquePointer,
    param: OpaquePointer,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_drotmg_batched_64",
        fn (
            Handle,
            OpaquePointer,
            OpaquePointer,
            OpaquePointer,
            OpaquePointer,
            OpaquePointer,
            Int64,
        ) -> Status,
    ]()(handle, d1, d2, x1, y1, param, batch_count)


fn rocblas_icamax_batched(
    handle: Handle,
    n: Int32,
    x: OpaquePointer,
    incx: Int32,
    batch_count: Int32,
    result: UnsafePointer[Int32],
) -> Status:
    return _get_dylib_function[
        "rocblas_icamax_batched",
        fn (
            Handle,
            Int32,
            OpaquePointer,
            Int32,
            Int32,
            UnsafePointer[Int32],
        ) -> Status,
    ]()(handle, n, x, incx, batch_count, result)


fn rocblas_sger_64(
    handle: Handle,
    m: Int64,
    n: Int64,
    alpha: UnsafePointer[Float32],
    x: UnsafePointer[Float32],
    incx: Int64,
    y: UnsafePointer[Float32],
    incy: Int64,
    _a: UnsafePointer[Float32],
    lda: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_sger_64",
        fn (
            Handle,
            Int64,
            Int64,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int64,
            UnsafePointer[Float32],
            Int64,
            UnsafePointer[Float32],
            Int64,
        ) -> Status,
    ]()(handle, m, n, alpha, x, incx, y, incy, _a, lda)


fn rocblas_izamax(
    handle: Handle,
    n: Int32,
    x: UnsafePointer[ComplexFloat64],
    incx: Int32,
    result: UnsafePointer[Int32],
) -> Status:
    return _get_dylib_function[
        "rocblas_izamax",
        fn (
            Handle,
            Int32,
            UnsafePointer[ComplexFloat64],
            Int32,
            UnsafePointer[Int32],
        ) -> Status,
    ]()(handle, n, x, incx, result)


fn rocblas_zhpr(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    alpha: UnsafePointer[Float64],
    x: UnsafePointer[ComplexFloat64],
    incx: Int32,
    _ap: UnsafePointer[ComplexFloat64],
) -> Status:
    return _get_dylib_function[
        "rocblas_zhpr",
        fn (
            Handle,
            Fill,
            Int32,
            UnsafePointer[Float64],
            UnsafePointer[ComplexFloat64],
            Int32,
            UnsafePointer[ComplexFloat64],
        ) -> Status,
    ]()(handle, uplo, n, alpha, x, incx, _ap)


fn rocblas_dsymm_batched(
    handle: Handle,
    side: Side,
    uplo: Fill,
    m: Int32,
    n: Int32,
    alpha: UnsafePointer[Float64],
    _a: OpaquePointer,
    lda: Int32,
    _b: OpaquePointer,
    ldb: Int32,
    beta: UnsafePointer[Float64],
    _c: OpaquePointer,
    ldc: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_dsymm_batched",
        fn (
            Handle,
            Side,
            Fill,
            Int32,
            Int32,
            UnsafePointer[Float64],
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            UnsafePointer[Float64],
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(
        handle,
        side,
        uplo,
        m,
        n,
        alpha,
        _a,
        lda,
        _b,
        ldb,
        beta,
        _c,
        ldc,
        batch_count,
    )


fn rocblas_cgemv(
    handle: Handle,
    trans: Operation,
    m: Int32,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat32],
    _a: UnsafePointer[ComplexFloat32],
    lda: Int32,
    x: UnsafePointer[ComplexFloat32],
    incx: Int32,
    beta: UnsafePointer[ComplexFloat32],
    y: UnsafePointer[ComplexFloat32],
    incy: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_cgemv",
        fn (
            Handle,
            Operation,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int32,
            UnsafePointer[ComplexFloat32],
            Int32,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int32,
        ) -> Status,
    ]()(handle, trans, m, n, alpha, _a, lda, x, incx, beta, y, incy)


fn rocblas_zrot_batched(
    handle: Handle,
    n: Int32,
    x: OpaquePointer,
    incx: Int32,
    y: OpaquePointer,
    incy: Int32,
    c: UnsafePointer[Float64],
    s: UnsafePointer[ComplexFloat64],
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_zrot_batched",
        fn (
            Handle,
            Int32,
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            UnsafePointer[Float64],
            UnsafePointer[ComplexFloat64],
            Int32,
        ) -> Status,
    ]()(handle, n, x, incx, y, incy, c, s, batch_count)


fn rocblas_sgemm(
    handle: Handle,
    trans_a: Operation,
    trans_b: Operation,
    m: Int32,
    n: Int32,
    k: Int32,
    alpha: UnsafePointer[Float32],
    _a: UnsafePointer[Float32],
    lda: Int32,
    _b: UnsafePointer[Float32],
    ldb: Int32,
    beta: UnsafePointer[Float32],
    _c: UnsafePointer[Float32],
    ldc: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 3 API </b>.

    \\details
    gemm performs one of the matrix-matrix operations:

        C = alpha*op( A )*op( B ) + beta*C,

        where op( X ) is one of

        op( X ) = X      or
        op( X ) = X**T   or
        op( X ) = X**H,

        alpha and beta are scalars, and A, B and C are matrices, with
        op( A ) an m by k matrix, op( B ) a k by n matrix and C an m by n matrix.

    Although not widespread, some gemm kernels may use atomic operations. See Atomic Operations
    in the API Reference Guide for more information.

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    transA    [rocblas_operation]
              specifies the form of op( A ).
    @param[in]
    transB    [rocblas_operation]
              specifies the form of op( B ).
    @param[in]
    m         [rocblas_int]
              number or rows of matrices op( A ) and C.
    @param[in]
    n         [rocblas_int]
              number of columns of matrices op( B ) and C.
    @param[in]
    k         [rocblas_int]
              number of columns of matrix op( A ) and number of rows of matrix op( B ).
    @param[in]
    alpha     device pointer or host pointer specifying the scalar alpha.
    @param[in]
    A         device pointer storing matrix A.
    @param[in]
    lda       [rocblas_int]
              specifies the leading dimension of A.
    @param[in]
    B         device pointer storing matrix B.
    @param[in]
    ldb       [rocblas_int]
              specifies the leading dimension of B.
    @param[in]
    beta      device pointer or host pointer specifying the scalar beta.
    @param[in, out]
    C         device pointer storing matrix C on the GPU.
    @param[in]
    ldc       [rocblas_int]
              specifies the leading dimension of C.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_sgemm",
        fn (
            Handle,
            Operation,
            Operation,
            Int32,
            Int32,
            Int32,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int32,
            UnsafePointer[Float32],
            Int32,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int32,
        ) -> Status,
    ]()(
        handle,
        trans_a,
        trans_b,
        m,
        n,
        k,
        alpha,
        _a,
        lda,
        _b,
        ldb,
        beta,
        _c,
        ldc,
    )


fn rocblas_dot_batched_ex_64(
    handle: Handle,
    n: Int64,
    x: OpaquePointer,
    x_type: DataType,
    incx: Int64,
    y: OpaquePointer,
    y_type: DataType,
    incy: Int64,
    batch_count: Int64,
    result: OpaquePointer,
    result_type: DataType,
    execution_type: DataType,
) -> Status:
    return _get_dylib_function[
        "rocblas_dot_batched_ex_64",
        fn (
            Handle,
            Int64,
            OpaquePointer,
            DataType,
            Int64,
            OpaquePointer,
            DataType,
            Int64,
            Int64,
            OpaquePointer,
            DataType,
            DataType,
        ) -> Status,
    ]()(
        handle,
        n,
        x,
        x_type,
        incx,
        y,
        y_type,
        incy,
        batch_count,
        result,
        result_type,
        execution_type,
    )


fn rocblas_strsv_64(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int64,
    _a: UnsafePointer[Float32],
    lda: Int64,
    x: UnsafePointer[Float32],
    incx: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_strsv_64",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int64,
            UnsafePointer[Float32],
            Int64,
            UnsafePointer[Float32],
            Int64,
        ) -> Status,
    ]()(handle, uplo, trans_a, diag, n, _a, lda, x, incx)


fn rocblas_dspr2_batched_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    alpha: UnsafePointer[Float64],
    x: OpaquePointer,
    incx: Int64,
    y: OpaquePointer,
    incy: Int64,
    _ap: OpaquePointer,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_dspr2_batched_64",
        fn (
            Handle,
            Fill,
            Int64,
            UnsafePointer[Float64],
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
        ) -> Status,
    ]()(handle, uplo, n, alpha, x, incx, y, incy, _ap, batch_count)


fn rocblas_dzasum_64(
    handle: Handle,
    n: Int64,
    x: UnsafePointer[ComplexFloat64],
    incx: Int64,
    result: UnsafePointer[Float64],
) -> Status:
    return _get_dylib_function[
        "rocblas_dzasum_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int64,
            UnsafePointer[Float64],
        ) -> Status,
    ]()(handle, n, x, incx, result)


fn rocblas_ddot(
    handle: Handle,
    n: Int32,
    x: UnsafePointer[Float64],
    incx: Int32,
    y: UnsafePointer[Float64],
    incy: Int32,
    result: UnsafePointer[Float64],
) -> Status:
    return _get_dylib_function[
        "rocblas_ddot",
        fn (
            Handle,
            Int32,
            UnsafePointer[Float64],
            Int32,
            UnsafePointer[Float64],
            Int32,
            UnsafePointer[Float64],
        ) -> Status,
    ]()(handle, n, x, incx, y, incy, result)


fn rocblas_cher2_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    alpha: UnsafePointer[ComplexFloat32],
    x: UnsafePointer[ComplexFloat32],
    incx: Int64,
    y: UnsafePointer[ComplexFloat32],
    incy: Int64,
    _a: UnsafePointer[ComplexFloat32],
    lda: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_cher2_64",
        fn (
            Handle,
            Fill,
            Int64,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int64,
            UnsafePointer[ComplexFloat32],
            Int64,
            UnsafePointer[ComplexFloat32],
            Int64,
        ) -> Status,
    ]()(handle, uplo, n, alpha, x, incx, y, incy, _a, lda)


fn rocblas_csscal_strided_batched_64(
    handle: Handle,
    n: Int64,
    alpha: UnsafePointer[Float32],
    x: UnsafePointer[ComplexFloat32],
    incx: Int64,
    stride_x: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_csscal_strided_batched_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[Float32],
            UnsafePointer[ComplexFloat32],
            Int64,
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, n, alpha, x, incx, stride_x, batch_count)


fn rocblas_cgerc_batched_64(
    handle: Handle,
    m: Int64,
    n: Int64,
    alpha: UnsafePointer[ComplexFloat32],
    x: OpaquePointer,
    incx: Int64,
    y: OpaquePointer,
    incy: Int64,
    _a: OpaquePointer,
    lda: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_cgerc_batched_64",
        fn (
            Handle,
            Int64,
            Int64,
            UnsafePointer[ComplexFloat32],
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, m, n, alpha, x, incx, y, incy, _a, lda, batch_count)


fn rocblas_tstgemv_batched_64(
    handle: Handle,
    trans: Operation,
    m: Int64,
    n: Int64,
    alpha: UnsafePointer[Float32],
    _a: OpaquePointer,
    lda: Int64,
    x: OpaquePointer,
    incx: Int64,
    beta: UnsafePointer[Float32],
    y: OpaquePointer,
    incy: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_tstgemv_batched_64",
        fn (
            Handle,
            Operation,
            Int64,
            Int64,
            UnsafePointer[Float32],
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            UnsafePointer[Float32],
            OpaquePointer,
            Int64,
            Int64,
        ) -> Status,
    ]()(
        handle, trans, m, n, alpha, _a, lda, x, incx, beta, y, incy, batch_count
    )


fn rocblas_hdot_64(
    handle: Handle,
    n: Int64,
    x: UnsafePointer[Float16],
    incx: Int64,
    y: UnsafePointer[Float16],
    incy: Int64,
    result: UnsafePointer[Float16],
) -> Status:
    return _get_dylib_function[
        "rocblas_hdot_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[Float16],
            Int64,
            UnsafePointer[Float16],
            Int64,
            UnsafePointer[Float16],
        ) -> Status,
    ]()(handle, n, x, incx, y, incy, result)


fn rocblas_sgeam_batched(
    handle: Handle,
    trans_a: Operation,
    trans_b: Operation,
    m: Int32,
    n: Int32,
    alpha: UnsafePointer[Float32],
    _a: OpaquePointer,
    lda: Int32,
    beta: UnsafePointer[Float32],
    _b: OpaquePointer,
    ldb: Int32,
    _c: OpaquePointer,
    ldc: Int32,
    batch_count: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 3 API </b>.

    \\details
    geam_batched performs one of the batched matrix-matrix operations:

        C_i = alpha*op( A_i ) + beta*op( B_i )  for i = 0, 1, ... batch_count - 1,

        where alpha and beta are scalars, and op(A_i), op(B_i) and C_i are m by n matrices
        and op( X ) is one of

        op( X ) = X      or
        op( X ) = X**T

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    transA    [rocblas_operation]
              specifies the form of op( A ).
    @param[in]
    transB    [rocblas_operation]
              specifies the form of op( B ).
    @param[in]
    m         [rocblas_int]
              matrix dimension m.
    @param[in]
    n         [rocblas_int]
              matrix dimension n.
    @param[in]
    alpha     device pointer or host pointer specifying the scalar alpha.
    @param[in]
    A         device array of device pointers storing each matrix A_i on the GPU.
              Each A_i is of dimension ( lda, k ), where k is m
              when  transA == rocblas_operation_none and
              is  n  when  transA == rocblas_operation_transpose.
    @param[in]
    lda       [rocblas_int]
              specifies the leading dimension of A.
    @param[in]
    beta      device pointer or host pointer specifying the scalar beta.
    @param[in]
    B         device array of device pointers storing each matrix B_i on the GPU.
              Each B_i is of dimension ( ldb, k ), where k is m
              when  transB == rocblas_operation_none and
              is  n  when  transB == rocblas_operation_transpose.
    @param[in]
    ldb       [rocblas_int]
              specifies the leading dimension of B.
    @param[in, out]
    C         device array of device pointers storing each matrix C_i on the GPU.
              Each C_i is of dimension ( ldc, n ).
    @param[in]
    ldc       [rocblas_int]
              specifies the leading dimension of C.

    @param[in]
    batch_count [rocblas_int]
                number of instances i in the batch.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_sgeam_batched",
        fn (
            Handle,
            Operation,
            Operation,
            Int32,
            Int32,
            UnsafePointer[Float32],
            OpaquePointer,
            Int32,
            UnsafePointer[Float32],
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(
        handle,
        trans_a,
        trans_b,
        m,
        n,
        alpha,
        _a,
        lda,
        beta,
        _b,
        ldb,
        _c,
        ldc,
        batch_count,
    )


fn rocblas_zdscal_batched(
    handle: Handle,
    n: Int32,
    alpha: UnsafePointer[Float64],
    x: OpaquePointer,
    incx: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_zdscal_batched",
        fn (
            Handle,
            Int32,
            UnsafePointer[Float64],
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(handle, n, alpha, x, incx, batch_count)


fn rocblas_ctrmv_batched(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int32,
    _a: UnsafePointer[UnsafePointer[ComplexFloat32]],
    lda: Int32,
    x: UnsafePointer[UnsafePointer[ComplexFloat32]],
    incx: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_ctrmv_batched",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int32,
            UnsafePointer[UnsafePointer[ComplexFloat32]],
            Int32,
            UnsafePointer[UnsafePointer[ComplexFloat32]],
            Int32,
            Int32,
        ) -> Status,
    ]()(handle, uplo, trans_a, diag, n, _a, lda, x, incx, batch_count)


fn rocblas_cherk_strided_batched(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    n: Int32,
    k: Int32,
    alpha: UnsafePointer[Float32],
    _a: UnsafePointer[ComplexFloat32],
    lda: Int32,
    stride__a: Int64,
    beta: UnsafePointer[Float32],
    _c: UnsafePointer[ComplexFloat32],
    ldc: Int32,
    stride__c: Int64,
    batch_count: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 3 API </b>.

    \\details
    herk_strided_batched performs a batch of the matrix-matrix operations for a Hermitian rank-k update:

        C_i := alpha*op( A_i )*op( A_i )^H + beta*C_i,

        where  alpha and beta are scalars, op(A) is an n by k matrix, and
        C_i is a n x n Hermitian matrix stored as either upper or lower.

        op( A_i ) = A_i, and A_i is n by k if transA == rocblas_operation_none
        op( A_i ) = A_i^H and A_i is k by n if transA == rocblas_operation_conjugate_transpose


    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.

    @param[in]
    uplo    [rocblas_fill]
            - rocblas_fill_upper:  C_i is an upper triangular matrix
            - rocblas_fill_lower:  C_i is a  lower triangular matrix

    @param[in]
    transA  [rocblas_operation]
            - rocblas_operation_conjugate_transpose: op(A) = A^H
            - rocblas_operation_none:                op(A) = A

    @param[in]
    n       [rocblas_int]
            n specifies the number of rows and columns of C_i. n >= 0.

    @param[in]
    k       [rocblas_int]
            k specifies the number of columns of op(A). k >= 0.

    @param[in]
    alpha
            alpha specifies the scalar alpha. When alpha is
            zero then A is not referenced and A need not be set before
            entry.

    @param[in]
    A       Device pointer to the first matrix A_1 on the GPU of dimension (lda, k)
            when transA is rocblas_operation_none, otherwise of dimension (lda, n)

    @param[in]
    lda     [rocblas_int]
            lda specifies the first dimension of A_i.

                if transA = rocblas_operation_none,  lda >= max( 1, n ),
                otherwise lda >= max( 1, k ).

    @param[in]
    stride_A  [rocblas_stride]
              stride from the start of one matrix (A_i) and the next one (A_i+1).

    @param[in]
    beta
            beta specifies the scalar beta. When beta is
            zero then C need not be set before entry.

    @param[in]
    C       Device pointer to the first matrix C_1 on the GPU.
            The imaginary component of the diagonal elements are not used but are set to zero unless quick return.
            only the upper/lower triangular part of each C_i is accessed.

    @param[in]
    ldc    [rocblas_int]
           ldc specifies the first dimension of C. ldc >= max( 1, n ).

    @param[in, out]
    stride_C  [rocblas_stride]
              stride from the start of one matrix (C_i) and the next one (C_i+1).

    @param[in]
    batch_count [rocblas_int]
                number of instances in the batch.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_cherk_strided_batched",
        fn (
            Handle,
            Fill,
            Operation,
            Int32,
            Int32,
            UnsafePointer[Float32],
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            UnsafePointer[Float32],
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        uplo,
        trans_a,
        n,
        k,
        alpha,
        _a,
        lda,
        stride__a,
        beta,
        _c,
        ldc,
        stride__c,
        batch_count,
    )


fn rocblas_hgemm(
    handle: Handle,
    trans_a: Operation,
    trans_b: Operation,
    m: Int32,
    n: Int32,
    k: Int32,
    alpha: UnsafePointer[Float16],
    _a: UnsafePointer[Float16],
    lda: Int32,
    _b: UnsafePointer[Float16],
    ldb: Int32,
    beta: UnsafePointer[Float16],
    _c: UnsafePointer[Float16],
    ldc: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_hgemm",
        fn (
            Handle,
            Operation,
            Operation,
            Int32,
            Int32,
            Int32,
            UnsafePointer[Float16],
            UnsafePointer[Float16],
            Int32,
            UnsafePointer[Float16],
            Int32,
            UnsafePointer[Float16],
            UnsafePointer[Float16],
            Int32,
        ) -> Status,
    ]()(
        handle,
        trans_a,
        trans_b,
        m,
        n,
        k,
        alpha,
        _a,
        lda,
        _b,
        ldb,
        beta,
        _c,
        ldc,
    )


fn rocblas_zrotg(
    handle: Handle,
    a: UnsafePointer[ComplexFloat64],
    b: UnsafePointer[ComplexFloat64],
    c: UnsafePointer[Float64],
    s: UnsafePointer[ComplexFloat64],
) -> Status:
    return _get_dylib_function[
        "rocblas_zrotg",
        fn (
            Handle,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            UnsafePointer[Float64],
            UnsafePointer[ComplexFloat64],
        ) -> Status,
    ]()(handle, a, b, c, s)


fn rocblas_cspr_strided_batched(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat32],
    x: UnsafePointer[ComplexFloat32],
    incx: Int32,
    stride_x: Int64,
    _ap: UnsafePointer[ComplexFloat32],
    stride__a: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_cspr_strided_batched",
        fn (
            Handle,
            Fill,
            Int32,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int64,
            Int32,
        ) -> Status,
    ]()(handle, uplo, n, alpha, x, incx, stride_x, _ap, stride__a, batch_count)


fn rocblas_stpsv_batched_64(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int64,
    _ap: OpaquePointer,
    x: OpaquePointer,
    incx: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_stpsv_batched_64",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int64,
            OpaquePointer,
            OpaquePointer,
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, uplo, trans_a, diag, n, _ap, x, incx, batch_count)


fn rocblas_ddot_64(
    handle: Handle,
    n: Int64,
    x: UnsafePointer[Float64],
    incx: Int64,
    y: UnsafePointer[Float64],
    incy: Int64,
    result: UnsafePointer[Float64],
) -> Status:
    return _get_dylib_function[
        "rocblas_ddot_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[Float64],
            Int64,
            UnsafePointer[Float64],
            Int64,
            UnsafePointer[Float64],
        ) -> Status,
    ]()(handle, n, x, incx, y, incy, result)


fn rocblas_idamax_batched_64(
    handle: Handle,
    n: Int64,
    x: OpaquePointer,
    incx: Int64,
    batch_count: Int64,
    result: UnsafePointer[Int64],
) -> Status:
    return _get_dylib_function[
        "rocblas_idamax_batched_64",
        fn (
            Handle,
            Int64,
            OpaquePointer,
            Int64,
            Int64,
            UnsafePointer[Int64],
        ) -> Status,
    ]()(handle, n, x, incx, batch_count, result)


fn rocblas_dotc_ex_64(
    handle: Handle,
    n: Int64,
    x: OpaquePointer,
    x_type: DataType,
    incx: Int64,
    y: OpaquePointer,
    y_type: DataType,
    incy: Int64,
    result: OpaquePointer,
    result_type: DataType,
    execution_type: DataType,
) -> Status:
    return _get_dylib_function[
        "rocblas_dotc_ex_64",
        fn (
            Handle,
            Int64,
            OpaquePointer,
            DataType,
            Int64,
            OpaquePointer,
            DataType,
            Int64,
            OpaquePointer,
            DataType,
            DataType,
        ) -> Status,
    ]()(
        handle,
        n,
        x,
        x_type,
        incx,
        y,
        y_type,
        incy,
        result,
        result_type,
        execution_type,
    )


fn rocblas_dger_strided_batched(
    handle: Handle,
    m: Int32,
    n: Int32,
    alpha: UnsafePointer[Float64],
    x: UnsafePointer[Float64],
    incx: Int32,
    stridex: Int64,
    y: UnsafePointer[Float64],
    incy: Int32,
    stridey: Int64,
    _a: UnsafePointer[Float64],
    lda: Int32,
    stride_a: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_dger_strided_batched",
        fn (
            Handle,
            Int32,
            Int32,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int32,
            Int64,
            UnsafePointer[Float64],
            Int32,
            Int64,
            UnsafePointer[Float64],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        m,
        n,
        alpha,
        x,
        incx,
        stridex,
        y,
        incy,
        stridey,
        _a,
        lda,
        stride_a,
        batch_count,
    )


fn rocblas_ztrmv_64(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int64,
    _a: UnsafePointer[ComplexFloat64],
    lda: Int64,
    x: UnsafePointer[ComplexFloat64],
    incx: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_ztrmv_64",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int64,
            UnsafePointer[ComplexFloat64],
            Int64,
        ) -> Status,
    ]()(handle, uplo, trans_a, diag, n, _a, lda, x, incx)


fn rocblas_ctrmm(
    handle: Handle,
    side: Side,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    m: Int32,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat32],
    _a: UnsafePointer[ComplexFloat32],
    lda: Int32,
    _b: UnsafePointer[ComplexFloat32],
    ldb: Int32,
    _c: UnsafePointer[ComplexFloat32],
    ldc: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_ctrmm",
        fn (
            Handle,
            Side,
            Fill,
            Operation,
            Diagonal,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int32,
            UnsafePointer[ComplexFloat32],
            Int32,
            UnsafePointer[ComplexFloat32],
            Int32,
        ) -> Status,
    ]()(
        handle,
        side,
        uplo,
        trans_a,
        diag,
        m,
        n,
        alpha,
        _a,
        lda,
        _b,
        ldb,
        _c,
        ldc,
    )


fn rocblas_chpr2(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat32],
    x: UnsafePointer[ComplexFloat32],
    incx: Int32,
    y: UnsafePointer[ComplexFloat32],
    incy: Int32,
    _ap: UnsafePointer[ComplexFloat32],
) -> Status:
    """
    \\brief <b> BLAS Level 2 API </b>.

    \\details
    hpr2 performs the matrix-vector operations:

        A := A + alpha*x*y**H + conj(alpha)*y*x**H
        where alpha is a complex scalar, x and y are vectors, and A is an
        n by n Hermitian matrix, supplied in packed form.

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    uplo      [rocblas_fill]
            specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
            - rocblas_fill_upper: The upper triangular part of A is supplied in AP.
            - rocblas_fill_lower: The lower triangular part of A is supplied in AP.
    @param[in]
    n         [rocblas_int]
              the number of rows and columns of matrix A. Must be at least 0.
    @param[in]
    alpha
              device pointer or host pointer to scalar alpha.
    @param[in]
    x         device pointer storing vector x.
    @param[in]
    incx      [rocblas_int]
              specifies the increment for the elements of x.
    @param[in]
    y         device pointer storing vector y.
    @param[in]
    incy      [rocblas_int]
              specifies the increment for the elements of y.
    @param[in, out]
    AP        device pointer storing the packed version of the specified triangular portion of
              the Hermitian matrix A. Of at least size ((n * (n + 1)) / 2).

                    if uplo == rocblas_fill_upper:
                        The upper triangular portion of the Hermitian matrix A is supplied.
                        The matrix is compacted so that AP contains the triangular portion
                        column-by-column
                        so that:
                        AP(0) = A(0,0)
                        AP(1) = A(0,1)
                        AP(2) = A(1,1), etc.
                        Ex: (rocblas_fill_upper; n = 3)
                            (1, 0) (2, 1) (4,9)
                            (2,-1) (3, 0) (5,3) ---> [(1,0),(2,1),(3,0),(4,9),(5,3),(6,0)]
                            (4,-9) (5,-3) (6,0)

                    if uplo == rocblas_fill_lower:
                        The lower triangular portion of the Hermitian matrix A is supplied.
                        The matrix is compacted so that AP contains the triangular portion
                        column-by-column
                        so that:
                        AP(0) = A(0,0)
                        AP(1) = A(1,0)
                        AP(2) = A(2,1), etc.
                        Ex: (rocblas_fill_lower; n = 3)
                            (1, 0) (2, 1) (4,9)
                            (2,-1) (3, 0) (5,3) ---> [(1,0),(2,-1),(4,-9),(3,0),(5,-3),(6,0)]
                            (4,-9) (5,-3) (6,0)
                    Note that the imaginary part of the diagonal elements are not accessed
                    and are assumed to be 0.
    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_chpr2",
        fn (
            Handle,
            Fill,
            Int32,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int32,
            UnsafePointer[ComplexFloat32],
            Int32,
            UnsafePointer[ComplexFloat32],
        ) -> Status,
    ]()(handle, uplo, n, alpha, x, incx, y, incy, _ap)


fn rocblas_zcopy_64(
    handle: Handle,
    n: Int64,
    x: UnsafePointer[ComplexFloat64],
    incx: Int64,
    y: UnsafePointer[ComplexFloat64],
    incy: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_zcopy_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int64,
            UnsafePointer[ComplexFloat64],
            Int64,
        ) -> Status,
    ]()(handle, n, x, incx, y, incy)


fn rocblas_scopy_strided_batched(
    handle: Handle,
    n: Int32,
    x: UnsafePointer[Float32],
    incx: Int32,
    stridex: Int64,
    y: UnsafePointer[Float32],
    incy: Int32,
    stridey: Int64,
    batch_count: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 1 API </b>.

    \\details
    copy_strided_batched copies each element x_i[j] into y_i[j], for  j = 1 , ... , n; i = 1 , ... , batch_count:

        y_i := x_i,
        where (x_i, y_i) is the i-th instance of the batch.
        x_i and y_i are vectors.

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    n         [rocblas_int]
              the number of elements in each x_i to be copied to y_i.
    @param[in]
    x         device pointer to the first vector (x_1) in the batch.
    @param[in]
    incx      [rocblas_int]
              specifies the increments for the elements of vectors x_i.
    @param[in]
    stridex     [rocblas_stride]
                stride from the start of one vector (x_i) and the next one (x_i+1).
                There are no restrictions placed on stride_x. However, the user should
                take care to ensure that stride_x is of appropriate size. For a typical
                case, this means stride_x >= n * incx.
    @param[out]
    y         device pointer to the first vector (y_1) in the batch.
    @param[in]
    incy      [rocblas_int]
              specifies the increment for the elements of vectors y_i.
    @param[in]
    stridey     [rocblas_stride]
                stride from the start of one vector (y_i) and the next one (y_i+1).
                There are no restrictions placed on stride_y, However, ensure that stride_y is of appropriate size, for a typical
                case this means stride_y >= n * incy. stridey should be non zero.
    @param[in]
    batch_count [rocblas_int]
                number of instances in the batch.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_scopy_strided_batched",
        fn (
            Handle,
            Int32,
            UnsafePointer[Float32],
            Int32,
            Int64,
            UnsafePointer[Float32],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(handle, n, x, incx, stridex, y, incy, stridey, batch_count)


fn rocblas_sasum_64(
    handle: Handle,
    n: Int64,
    x: UnsafePointer[Float32],
    incx: Int64,
    result: UnsafePointer[Float32],
) -> Status:
    return _get_dylib_function[
        "rocblas_sasum_64",
        fn (
            Handle, Int64, UnsafePointer[Float32], Int64, UnsafePointer[Float32]
        ) -> Status,
    ]()(handle, n, x, incx, result)


fn rocblas_cgemv_strided_batched(
    handle: Handle,
    trans_a: Operation,
    m: Int32,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat32],
    _a: UnsafePointer[ComplexFloat32],
    lda: Int32,
    stride_a: Int64,
    x: UnsafePointer[ComplexFloat32],
    incx: Int32,
    stridex: Int64,
    beta: UnsafePointer[ComplexFloat32],
    y: UnsafePointer[ComplexFloat32],
    incy: Int32,
    stridey: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_cgemv_strided_batched",
        fn (
            Handle,
            Operation,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        trans_a,
        m,
        n,
        alpha,
        _a,
        lda,
        stride_a,
        x,
        incx,
        stridex,
        beta,
        y,
        incy,
        stridey,
        batch_count,
    )


fn rocblas_zgbmv_strided_batched_64(
    handle: Handle,
    trans: Operation,
    m: Int64,
    n: Int64,
    kl: Int64,
    ku: Int64,
    alpha: UnsafePointer[ComplexFloat64],
    _a: UnsafePointer[ComplexFloat64],
    lda: Int64,
    stride__a: Int64,
    x: UnsafePointer[ComplexFloat64],
    incx: Int64,
    stride_x: Int64,
    beta: UnsafePointer[ComplexFloat64],
    y: UnsafePointer[ComplexFloat64],
    incy: Int64,
    stride_y: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_zgbmv_strided_batched_64",
        fn (
            Handle,
            Operation,
            Int64,
            Int64,
            Int64,
            Int64,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int64,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int64,
            Int64,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int64,
            Int64,
            Int64,
        ) -> Status,
    ]()(
        handle,
        trans,
        m,
        n,
        kl,
        ku,
        alpha,
        _a,
        lda,
        stride__a,
        x,
        incx,
        stride_x,
        beta,
        y,
        incy,
        stride_y,
        batch_count,
    )


fn rocblas_srotmg(
    handle: Handle,
    d1: UnsafePointer[Float32],
    d2: UnsafePointer[Float32],
    x1: UnsafePointer[Float32],
    y1: UnsafePointer[Float32],
    param: UnsafePointer[Float32],
) -> Status:
    """
    \\brief <b> BLAS Level 1 API </b>.

    \\details
    rotmg creates the modified Givens rotation matrix for the vector (d1 * x1, d2 * y1).
          Parameters may be stored in either host or device memory. Location is specified by calling rocblas_set_pointer_mode:

    @param[in]
    handle  [rocblas_handle]
            handle to the rocblas library context queue.
    @param[in, out]
    d1      device pointer or host pointer to input scalar that is overwritten.
    @param[in, out]
    d2      device pointer or host pointer to input scalar that is overwritten.
    @param[in, out]
    x1      device pointer or host pointer to input scalar that is overwritten.
    @param[in]
    y1      device pointer or host pointer to input scalar.
    @param[out]
    param   device vector or host vector of five elements defining the rotation.

        param[0] = flag
        param[1] = H11
        param[2] = H21
        param[3] = H12
        param[4] = H22

        The flag parameter defines the form of H:

        flag = -1 => H = ( H11 H12 H21 H22 )
        flag =  0 => H = ( 1.0 H12 H21 1.0 )
        flag =  1 => H = ( H11 1.0 -1.0 H22 )
        flag = -2 => H = ( 1.0 0.0 0.0 1.0 )

        param may be stored in either host or device memory.
        Location is specified by calling rocblas_set_pointer_mode.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_srotmg",
        fn (
            Handle,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            UnsafePointer[Float32],
        ) -> Status,
    ]()(handle, d1, d2, x1, y1, param)


fn rocblas_zher2k_strided_batched(
    handle: Handle,
    uplo: Fill,
    trans: Operation,
    n: Int32,
    k: Int32,
    alpha: UnsafePointer[ComplexFloat64],
    _a: UnsafePointer[ComplexFloat64],
    lda: Int32,
    stride__a: Int64,
    _b: UnsafePointer[ComplexFloat64],
    ldb: Int32,
    stride__b: Int64,
    beta: UnsafePointer[Float64],
    _c: UnsafePointer[ComplexFloat64],
    ldc: Int32,
    stride__c: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_zher2k_strided_batched",
        fn (
            Handle,
            Fill,
            Operation,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            UnsafePointer[Float64],
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        uplo,
        trans,
        n,
        k,
        alpha,
        _a,
        lda,
        stride__a,
        _b,
        ldb,
        stride__b,
        beta,
        _c,
        ldc,
        stride__c,
        batch_count,
    )


fn rocblas_sspr(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    alpha: UnsafePointer[Float32],
    x: UnsafePointer[Float32],
    incx: Int32,
    _ap: UnsafePointer[Float32],
) -> Status:
    """
    \\brief <b> BLAS Level 2 API </b>.

    \\details
    spr performs the matrix-vector operations:

        A := A + alpha*x*x**T
        where alpha is a scalar, x is a vector, and A is an
        n by n symmetric matrix, supplied in packed form.

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    uplo      [rocblas_fill]
            specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
            - rocblas_fill_upper: The upper triangular part of A is supplied in AP.
            - rocblas_fill_lower: The lower triangular part of A is supplied in AP.
    @param[in]
    n         [rocblas_int]
            the number of rows and columns of matrix A. Must be at least 0.
    @param[in]
    alpha
              device pointer or host pointer to scalar alpha.
    @param[in]
    x         device pointer storing vector x.
    @param[in]
    incx      [rocblas_int]
              specifies the increment for the elements of x.
    @param[in, out]
    AP        device pointer storing the packed version of the specified triangular portion of
              the symmetric matrix A. Of at least size ((n * (n + 1)) / 2).

                    if uplo == rocblas_fill_upper:
                        The upper triangular portion of the symmetric matrix A is supplied.
                        The matrix is compacted so that AP contains the triangular portion
                        column-by-column
                        so that:
                        AP(0) = A(0,0)
                        AP(1) = A(0,1)
                        AP(2) = A(1,1), etc.
                            Ex: (rocblas_fill_upper; n = 4)
                                1 2 4 7
                                2 3 5 8   -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
                                4 5 6 9
                                7 8 9 0

                    if uplo == rocblas_fill_lower:
                        The lower triangular portion of the symmetric matrix A is supplied.
                        The matrix is compacted so that AP contains the triangular portion
                        column-by-column
                        so that:
                        AP(0) = A(0,0)
                        AP(1) = A(1,0)
                        AP(2) = A(2,1), etc.
                            Ex: (rocblas_fill_lower; n = 4)
                                1 2 3 4
                                2 5 6 7    -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
                                3 6 8 9
                                4 7 9 0
    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_sspr",
        fn (
            Handle,
            Fill,
            Int32,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int32,
            UnsafePointer[Float32],
        ) -> Status,
    ]()(handle, uplo, n, alpha, x, incx, _ap)


fn rocblas_zgbmv_batched_64(
    handle: Handle,
    trans: Operation,
    m: Int64,
    n: Int64,
    kl: Int64,
    ku: Int64,
    alpha: UnsafePointer[ComplexFloat64],
    _a: OpaquePointer,
    lda: Int64,
    x: OpaquePointer,
    incx: Int64,
    beta: UnsafePointer[ComplexFloat64],
    y: OpaquePointer,
    incy: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_zgbmv_batched_64",
        fn (
            Handle,
            Operation,
            Int64,
            Int64,
            Int64,
            Int64,
            UnsafePointer[ComplexFloat64],
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            UnsafePointer[ComplexFloat64],
            OpaquePointer,
            Int64,
            Int64,
        ) -> Status,
    ]()(
        handle,
        trans,
        m,
        n,
        kl,
        ku,
        alpha,
        _a,
        lda,
        x,
        incx,
        beta,
        y,
        incy,
        batch_count,
    )


fn rocblas_idamax_batched(
    handle: Handle,
    n: Int32,
    x: OpaquePointer,
    incx: Int32,
    batch_count: Int32,
    result: UnsafePointer[Int32],
) -> Status:
    return _get_dylib_function[
        "rocblas_idamax_batched",
        fn (
            Handle,
            Int32,
            OpaquePointer,
            Int32,
            Int32,
            UnsafePointer[Int32],
        ) -> Status,
    ]()(handle, n, x, incx, batch_count, result)


fn rocblas_zhemv(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat64],
    _a: UnsafePointer[ComplexFloat64],
    lda: Int32,
    x: UnsafePointer[ComplexFloat64],
    incx: Int32,
    beta: UnsafePointer[ComplexFloat64],
    y: UnsafePointer[ComplexFloat64],
    incy: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_zhemv",
        fn (
            Handle,
            Fill,
            Int32,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int32,
            UnsafePointer[ComplexFloat64],
            Int32,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int32,
        ) -> Status,
    ]()(handle, uplo, n, alpha, _a, lda, x, incx, beta, y, incy)


fn rocblas_csymv_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    alpha: UnsafePointer[ComplexFloat32],
    _a: UnsafePointer[ComplexFloat32],
    lda: Int64,
    x: UnsafePointer[ComplexFloat32],
    incx: Int64,
    beta: UnsafePointer[ComplexFloat32],
    y: UnsafePointer[ComplexFloat32],
    incy: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_csymv_64",
        fn (
            Handle,
            Fill,
            Int64,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int64,
            UnsafePointer[ComplexFloat32],
            Int64,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int64,
        ) -> Status,
    ]()(handle, uplo, n, alpha, _a, lda, x, incx, beta, y, incy)


fn rocblas_dcopy_batched(
    handle: Handle,
    n: Int32,
    x: OpaquePointer,
    incx: Int32,
    y: OpaquePointer,
    incy: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_dcopy_batched",
        fn (
            Handle,
            Int32,
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(handle, n, x, incx, y, incy, batch_count)


fn rocblas_snrm2_64(
    handle: Handle,
    n: Int64,
    x: UnsafePointer[Float32],
    incx: Int64,
    result: UnsafePointer[Float32],
) -> Status:
    return _get_dylib_function[
        "rocblas_snrm2_64",
        fn (
            Handle, Int64, UnsafePointer[Float32], Int64, UnsafePointer[Float32]
        ) -> Status,
    ]()(handle, n, x, incx, result)


fn rocblas_zdscal_64(
    handle: Handle,
    n: Int64,
    alpha: UnsafePointer[Float64],
    x: UnsafePointer[ComplexFloat64],
    incx: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_zdscal_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[Float64],
            UnsafePointer[ComplexFloat64],
            Int64,
        ) -> Status,
    ]()(handle, n, alpha, x, incx)


fn rocblas_hssgemv_batched_64(
    handle: Handle,
    trans: Operation,
    m: Int64,
    n: Int64,
    alpha: UnsafePointer[Float32],
    _a: OpaquePointer,
    lda: Int64,
    x: OpaquePointer,
    incx: Int64,
    beta: UnsafePointer[Float32],
    y: OpaquePointer,
    incy: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_hssgemv_batched_64",
        fn (
            Handle,
            Operation,
            Int64,
            Int64,
            UnsafePointer[Float32],
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            UnsafePointer[Float32],
            OpaquePointer,
            Int64,
            Int64,
        ) -> Status,
    ]()(
        handle, trans, m, n, alpha, _a, lda, x, incx, beta, y, incy, batch_count
    )


fn rocblas_zscal_batched_64(
    handle: Handle,
    n: Int64,
    alpha: UnsafePointer[ComplexFloat64],
    x: OpaquePointer,
    incx: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_zscal_batched_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[ComplexFloat64],
            OpaquePointer,
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, n, alpha, x, incx, batch_count)


fn rocblas_zhpr_batched_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    alpha: UnsafePointer[Float64],
    x: OpaquePointer,
    incx: Int64,
    _ap: OpaquePointer,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_zhpr_batched_64",
        fn (
            Handle,
            Fill,
            Int64,
            UnsafePointer[Float64],
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
        ) -> Status,
    ]()(handle, uplo, n, alpha, x, incx, _ap, batch_count)


fn rocblas_dcopy_batched_64(
    handle: Handle,
    n: Int64,
    x: OpaquePointer,
    incx: Int64,
    y: OpaquePointer,
    incy: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_dcopy_batched_64",
        fn (
            Handle,
            Int64,
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, n, x, incx, y, incy, batch_count)


fn rocblas_sgemmt(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    trans_b: Operation,
    n: Int32,
    k: Int32,
    alpha: UnsafePointer[Float32],
    _a: UnsafePointer[Float32],
    lda: Int32,
    _b: UnsafePointer[Float32],
    ldb: Int32,
    beta: UnsafePointer[Float32],
    _c: UnsafePointer[Float32],
    ldc: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 3 API </b>.

    \\details
    gemmt performs matrix-matrix operations and updates the upper or lower triangular part of the result matrix:

        C = alpha*op( A )*op( B ) + beta*C,

        where op( X ) is one of

        op( X ) = X      or
        op( X ) = X**T   or
        op( X ) = X**H,

        alpha and beta are scalars. A, B  are general matrices and C is either an upper or lower triangular matrix, with
        op( A ) an n by k matrix, op( B ) a k by n matrix and C an n by n matrix.

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    uplo    [rocblas_fill]
            - rocblas_fill_upper:  C is an upper triangular matrix
            - rocblas_fill_lower:  C is a  lower triangular matrix
    @param[in]
    transA    [rocblas_operation]
            - rocblas_operation_none:    op(A) = A.
            - rocblas_operation_transpose:      op(A) = A^T
            - rocblas_operation_conjugate_transpose:  op(A) = A^H
    @param[in]
    transB    [rocblas_operation]
            - rocblas_operation_none:    op(B) = B.
            - rocblas_operation_transpose:      op(B) = B^T
            - rocblas_operation_conjugate_transpose:  op(B) = B^H
    @param[in]
    n         [rocblas_int]
              number or rows of matrices op( A ), columns of op( B ), and (rows, columns) of C.
    @param[in]
    k         [rocblas_int]
              number of rows of matrices op( B ) and columns of op( A ).
    @param[in]
    alpha     device pointer or host pointer specifying the scalar alpha.
    @param[in]
    A         device pointer storing matrix A. If transa = rocblas_operation_none, then, the leading n-by-k part of the array contains the matrix A, otherwise the leading k-by-n part of the array contains the matrix A.
    @param[in]
    lda       [rocblas_int]
              specifies the leading dimension of A. If transA == rocblas_operation_none, must have lda >= max(1, n), otherwise, must have lda >= max(1, k).
    @param[in]
    B         device pointer storing matrix B. If transB = rocblas_operation_none, then, the leading k-by-n part of the array contains the matrix B, otherwise the leading n-by-k part of the array contains the matrix B.
    @param[in]
    ldb       [rocblas_int]
              specifies the leading dimension of B. If transB == rocblas_operation_none, must have ldb >= max(1, k), otherwise, must have ldb >= max(1, n)
    @param[in]
    beta      device pointer or host pointer specifying the scalar beta.
    @param[in, out]
    C         device pointer storing matrix C on the GPU. If uplo == rocblas_fill_upper, the upper triangular part of the leading n-by-n array contains the matrix C, otherwise the lower triangular part of the leading n-by-n array contains the matrix C.
    @param[in]
    ldc       [rocblas_int]
              specifies the leading dimension of C. Must have ldc >= max(1, n).

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_sgemmt",
        fn (
            Handle,
            Fill,
            Operation,
            Operation,
            Int32,
            Int32,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int32,
            UnsafePointer[Float32],
            Int32,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int32,
        ) -> Status,
    ]()(
        handle,
        uplo,
        trans_a,
        trans_b,
        n,
        k,
        alpha,
        _a,
        lda,
        _b,
        ldb,
        beta,
        _c,
        ldc,
    )


fn rocblas_zhpmv(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat64],
    _ap: UnsafePointer[ComplexFloat64],
    x: UnsafePointer[ComplexFloat64],
    incx: Int32,
    beta: UnsafePointer[ComplexFloat64],
    y: UnsafePointer[ComplexFloat64],
    incy: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_zhpmv",
        fn (
            Handle,
            Fill,
            Int32,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int32,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int32,
        ) -> Status,
    ]()(handle, uplo, n, alpha, _ap, x, incx, beta, y, incy)


fn rocblas_drotmg_batched(
    handle: Handle,
    d1: OpaquePointer,
    d2: OpaquePointer,
    x1: OpaquePointer,
    y1: OpaquePointer,
    param: OpaquePointer,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_drotmg_batched",
        fn (
            Handle,
            OpaquePointer,
            OpaquePointer,
            OpaquePointer,
            OpaquePointer,
            OpaquePointer,
            Int32,
        ) -> Status,
    ]()(handle, d1, d2, x1, y1, param, batch_count)


fn rocblas_ctbsv_strided_batched_64(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int64,
    k: Int64,
    _a: UnsafePointer[ComplexFloat32],
    lda: Int64,
    stride__a: Int64,
    x: UnsafePointer[ComplexFloat32],
    incx: Int64,
    stride_x: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_ctbsv_strided_batched_64",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int64,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int64,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int64,
            Int64,
            Int64,
        ) -> Status,
    ]()(
        handle,
        uplo,
        trans_a,
        diag,
        n,
        k,
        _a,
        lda,
        stride__a,
        x,
        incx,
        stride_x,
        batch_count,
    )


fn rocblas_zgeru_strided_batched(
    handle: Handle,
    m: Int32,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat64],
    x: UnsafePointer[ComplexFloat64],
    incx: Int32,
    stridex: Int64,
    y: UnsafePointer[ComplexFloat64],
    incy: Int32,
    stridey: Int64,
    _a: UnsafePointer[ComplexFloat64],
    lda: Int32,
    stride_a: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_zgeru_strided_batched",
        fn (
            Handle,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        m,
        n,
        alpha,
        x,
        incx,
        stridex,
        y,
        incy,
        stridey,
        _a,
        lda,
        stride_a,
        batch_count,
    )


fn rocblas_strsm_batched_64(
    handle: Handle,
    side: Side,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    m: Int64,
    n: Int64,
    alpha: UnsafePointer[Float32],
    _a: OpaquePointer,
    lda: Int64,
    _b: OpaquePointer,
    ldb: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_strsm_batched_64",
        fn (
            Handle,
            Side,
            Fill,
            Operation,
            Diagonal,
            Int64,
            Int64,
            UnsafePointer[Float32],
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            Int64,
        ) -> Status,
    ]()(
        handle,
        side,
        uplo,
        trans_a,
        diag,
        m,
        n,
        alpha,
        _a,
        lda,
        _b,
        ldb,
        batch_count,
    )


fn rocblas_zdscal_strided_batched_64(
    handle: Handle,
    n: Int64,
    alpha: UnsafePointer[Float64],
    x: UnsafePointer[ComplexFloat64],
    incx: Int64,
    stride_x: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_zdscal_strided_batched_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[Float64],
            UnsafePointer[ComplexFloat64],
            Int64,
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, n, alpha, x, incx, stride_x, batch_count)


fn rocblas_cherk(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    n: Int32,
    k: Int32,
    alpha: UnsafePointer[Float32],
    _a: UnsafePointer[ComplexFloat32],
    lda: Int32,
    beta: UnsafePointer[Float32],
    _c: UnsafePointer[ComplexFloat32],
    ldc: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 3 API </b>.

    \\details
    herk performs one of the matrix-matrix operations for a Hermitian rank-k update:

        C := alpha*op( A )*op( A )^H + beta*C,

        where  alpha and beta are scalars, op(A) is an n by k matrix, and
        C is a n x n Hermitian matrix stored as either upper or lower.

        op( A ) = A, and A is n by k if transA == rocblas_operation_none
        op( A ) = A^H and A is k by n if transA == rocblas_operation_conjugate_transpose

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.

    @param[in]
    uplo    [rocblas_fill]
            - rocblas_fill_upper:  C is an upper triangular matrix
            - rocblas_fill_lower:  C is a  lower triangular matrix

    @param[in]
    transA  [rocblas_operation]
            - rocblas_operation_conjugate_transpose:  op(A) = A^H
            - rocblas_operation_none:                 op(A) = A

    @param[in]
    n       [rocblas_int]
            n specifies the number of rows and columns of C. n >= 0.

    @param[in]
    k       [rocblas_int]
            k specifies the number of columns of op(A). k >= 0.

    @param[in]
    alpha
            alpha specifies the scalar alpha. When alpha is
            zero then A is not referenced and A need not be set before
            entry.

    @param[in]
    A       pointer storing matrix A on the GPU.
            Matrix dimension is ( lda, k ) when if transA = rocblas_operation_none, otherwise (lda, n)

    @param[in]
    lda     [rocblas_int]
            lda specifies the first dimension of A.

                if transA = rocblas_operation_none,  lda >= max( 1, n ),
                otherwise lda >= max( 1, k ).

    @param[in]
    beta
            beta specifies the scalar beta. When beta is
            zero then C need not be set before entry.

    @param[in]
    C       pointer storing matrix C on the GPU.
            The imaginary component of the diagonal elements are not used but are set to zero unless quick return.
            only the upper/lower triangular part is accessed.

    @param[in]
    ldc    [rocblas_int]
           ldc specifies the first dimension of C. ldc >= max( 1, n ).

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_cherk",
        fn (
            Handle,
            Fill,
            Operation,
            Int32,
            Int32,
            UnsafePointer[Float32],
            UnsafePointer[ComplexFloat32],
            Int32,
            UnsafePointer[Float32],
            UnsafePointer[ComplexFloat32],
            Int32,
        ) -> Status,
    ]()(handle, uplo, trans_a, n, k, alpha, _a, lda, beta, _c, ldc)


fn rocblas_dsyr2_strided_batched(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    alpha: UnsafePointer[Float64],
    x: UnsafePointer[Float64],
    incx: Int32,
    stridex: Int64,
    y: UnsafePointer[Float64],
    incy: Int32,
    stridey: Int64,
    _a: UnsafePointer[Float64],
    lda: Int32,
    stride_a: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_dsyr2_strided_batched",
        fn (
            Handle,
            Fill,
            Int32,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int32,
            Int64,
            UnsafePointer[Float64],
            Int32,
            Int64,
            UnsafePointer[Float64],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        uplo,
        n,
        alpha,
        x,
        incx,
        stridex,
        y,
        incy,
        stridey,
        _a,
        lda,
        stride_a,
        batch_count,
    )


fn rocblas_dtbsv_batched_64(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int64,
    k: Int64,
    _a: OpaquePointer,
    lda: Int64,
    x: OpaquePointer,
    incx: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_dtbsv_batched_64",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int64,
            Int64,
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, uplo, trans_a, diag, n, k, _a, lda, x, incx, batch_count)


fn rocblas_cgbmv_strided_batched(
    handle: Handle,
    trans: Operation,
    m: Int32,
    n: Int32,
    kl: Int32,
    ku: Int32,
    alpha: UnsafePointer[ComplexFloat32],
    _a: UnsafePointer[ComplexFloat32],
    lda: Int32,
    stride__a: Int64,
    x: UnsafePointer[ComplexFloat32],
    incx: Int32,
    stride_x: Int64,
    beta: UnsafePointer[ComplexFloat32],
    y: UnsafePointer[ComplexFloat32],
    incy: Int32,
    stride_y: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_cgbmv_strided_batched",
        fn (
            Handle,
            Operation,
            Int32,
            Int32,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        trans,
        m,
        n,
        kl,
        ku,
        alpha,
        _a,
        lda,
        stride__a,
        x,
        incx,
        stride_x,
        beta,
        y,
        incy,
        stride_y,
        batch_count,
    )


fn rocblas_chbmv_batched(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    k: Int32,
    alpha: UnsafePointer[ComplexFloat32],
    _a: OpaquePointer,
    lda: Int32,
    x: OpaquePointer,
    incx: Int32,
    beta: UnsafePointer[ComplexFloat32],
    y: OpaquePointer,
    incy: Int32,
    batch_count: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 2 API </b>.

    \\details
    hbmv_batched performs one of the matrix-vector operations:

        y_i := alpha*A_i*x_i + beta*y_i
        where alpha and beta are scalars, x_i and y_i are n element vectors and A_i is an
        n by n Hermitian band matrix with k super-diagonals, for each batch in i = [1, batch_count].

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    uplo      [rocblas_fill]
            - rocblas_fill_upper: The upper triangular part of each A_i is being supplied.
            - rocblas_fill_lower: The lower triangular part of each A_i is being supplied.
    @param[in]
    n         [rocblas_int]
              the order of each matrix A_i.
    @param[in]
    k         [rocblas_int]
              the number of super-diagonals of each matrix A_i. Must be >= 0.
    @param[in]
    alpha     device pointer or host pointer to scalar alpha.
    @param[in]
    A         device array of device pointers storing each matrix_i A of dimension (lda, n).

            if uplo == rocblas_fill_upper:
                The leading (k + 1) by n part of each A_i must contain the upper
                triangular band part of the Hermitian matrix, with the leading
                diagonal in row (k + 1), the first super-diagonal on the RHS
                of row k, etc.
                The top left k by x triangle of each A_i will not be referenced.
                    Ex (upper, lda = n = 4, k = 1):
                    A                             Represented matrix
                    (0,0) (5,9) (6,8) (7,7)       (1, 0) (5, 9) (0, 0) (0, 0)
                    (1,0) (2,0) (3,0) (4,0)       (5,-9) (2, 0) (6, 8) (0, 0)
                    (0,0) (0,0) (0,0) (0,0)       (0, 0) (6,-8) (3, 0) (7, 7)
                    (0,0) (0,0) (0,0) (0,0)       (0, 0) (0, 0) (7,-7) (4, 0)

            if uplo == rocblas_fill_lower:
                The leading (k + 1) by n part of each A_i must contain the lower
                triangular band part of the Hermitian matrix, with the leading
                diagonal in row (1), the first sub-diagonal on the LHS of
                row 2, etc.
                The bottom right k by k triangle of each A_i will not be referenced.
                    Ex (lower, lda = 2, n = 4, k = 1):
                    A                               Represented matrix
                    (1,0) (2,0) (3,0) (4,0)         (1, 0) (5,-9) (0, 0) (0, 0)
                    (5,9) (6,8) (7,7) (0,0)         (5, 9) (2, 0) (6,-8) (0, 0)
                                                    (0, 0) (6, 8) (3, 0) (7,-7)
                                                    (0, 0) (0, 0) (7, 7) (4, 0)

              As a Hermitian matrix, the imaginary part of the main diagonal
              of each A_i will not be referenced and is assumed to be == 0.
    @param[in]
    lda       [rocblas_int]
              specifies the leading dimension of each A_i. must be >= max(1, n).
    @param[in]
    x         device array of device pointers storing each vector x_i.
    @param[in]
    incx      [rocblas_int]
              specifies the increment for the elements of each x_i.
    @param[in]
    beta      device pointer or host pointer to scalar beta.
    @param[in, out]
    y         device array of device pointers storing each vector y_i.
    @param[in]
    incy      [rocblas_int]
              specifies the increment for the elements of y.
    @param[in]
    batch_count [rocblas_int]
                number of instances in the batch.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_chbmv_batched",
        fn (
            Handle,
            Fill,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat32],
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            UnsafePointer[ComplexFloat32],
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(handle, uplo, n, k, alpha, _a, lda, x, incx, beta, y, incy, batch_count)


fn rocblas_dspmv_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    alpha: UnsafePointer[Float64],
    _a: UnsafePointer[Float64],
    x: UnsafePointer[Float64],
    incx: Int64,
    beta: UnsafePointer[Float64],
    y: UnsafePointer[Float64],
    incy: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_dspmv_64",
        fn (
            Handle,
            Fill,
            Int64,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int64,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int64,
        ) -> Status,
    ]()(handle, uplo, n, alpha, _a, x, incx, beta, y, incy)


fn rocblas_ztrsm_batched_64(
    handle: Handle,
    side: Side,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    m: Int64,
    n: Int64,
    alpha: UnsafePointer[ComplexFloat64],
    _a: OpaquePointer,
    lda: Int64,
    _b: OpaquePointer,
    ldb: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_ztrsm_batched_64",
        fn (
            Handle,
            Side,
            Fill,
            Operation,
            Diagonal,
            Int64,
            Int64,
            UnsafePointer[ComplexFloat64],
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            Int64,
        ) -> Status,
    ]()(
        handle,
        side,
        uplo,
        trans_a,
        diag,
        m,
        n,
        alpha,
        _a,
        lda,
        _b,
        ldb,
        batch_count,
    )


fn rocblas_snrm2_strided_batched(
    handle: Handle,
    n: Int32,
    x: UnsafePointer[Float32],
    incx: Int32,
    stridex: Int64,
    batch_count: Int32,
    results: UnsafePointer[Float32],
) -> Status:
    """
    \\brief <b> BLAS Level 1 API </b>.

    \\details
    nrm2_strided_batched computes the euclidean norm over a batch of real or complex vectors:

        result := sqrt( x_i'*x_i ) for real vectors x, for i = 1, ..., batch_count
        result := sqrt( x_i**H*x_i ) for complex vectors, for i = 1, ..., batch_count

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    n         [rocblas_int]
              number of elements in each x_i.
    @param[in]
    x         device pointer to the first vector x_1.
    @param[in]
    incx      [rocblas_int]
              specifies the increment for the elements of each x_i. incx must be > 0.
    @param[in]
    stridex   [rocblas_stride]
              stride from the start of one vector (x_i) and the next one (x_i+1).
              There are no restrictions placed on stride_x. However, ensure that stride_x is of appropriate size. For a typical
              case this means stride_x >= n * incx.
    @param[in]
    batch_count [rocblas_int]
              number of instances in the batch.
    @param[out]
    results
              device pointer or host pointer to array for storing contiguous batch_count results.
              return is 0.0 for each element if n <= 0, incx<=0.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_snrm2_strided_batched",
        fn (
            Handle,
            Int32,
            UnsafePointer[Float32],
            Int32,
            Int64,
            Int32,
            UnsafePointer[Float32],
        ) -> Status,
    ]()(handle, n, x, incx, stridex, batch_count, results)


fn rocblas_stbsv_batched(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int32,
    k: Int32,
    _a: OpaquePointer,
    lda: Int32,
    x: OpaquePointer,
    incx: Int32,
    batch_count: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 2 API </b>.

    \\details
    tbsv_batched solves:

         A_i*x_i = b_i or
         A_i**T*x_i = b_i or
         A_i**H*x_i = b_i
         where x_i and b_i are vectors and A_i is a banded triangular matrix,
        for i = [1, batch_count].

    The input vectors b_i are overwritten by the output vectors x_i.

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.

    @param[in]
    uplo    [rocblas_fill]
            - rocblas_fill_upper:  A_i is an upper triangular matrix.
            - rocblas_fill_lower:  A_i is a  lower triangular matrix.

    @param[in]
    transA     [rocblas_operation]
            - rocblas_operation_none: Solves A_i*x_i = b_i
            - rocblas_operation_transpose: Solves A_i**T*x_i = b_i
            - rocblas_operation_conjugate_transpose: Solves A_i**H*x_i = b_i

    @param[in]
    diag    [rocblas_diagonal]
            - rocblas_diagonal_unit:     each A_i is assumed to be unit triangular (i.e. the diagonal elements
            of each A_i are not used in computations).
            - rocblas_diagonal_non_unit: each A_i is not assumed to be unit triangular.

    @param[in]
    n         [rocblas_int]
              n specifies the number of rows of each b_i. n >= 0.
    @param[in]
    k         [rocblas_int]

            if(uplo == rocblas_fill_upper)
                k specifies the number of super-diagonals of each A_i.
            if(uplo == rocblas_fill_lower)
                k specifies the number of sub-diagonals of each A_i.
            k >= 0.

    @param[in]
    A         device vector of device pointers storing each matrix A_i in banded format.

    @param[in]
    lda       [rocblas_int]
              specifies the leading dimension of each A_i.
              lda >= (k + 1).

    @param[in, out]
    x         device vector of device pointers storing each input vector b_i. Overwritten by each output
              vector x_i.
    @param[in]
    incx      [rocblas_int]
              specifies the increment for the elements of each x_i.
    @param[in]
    batch_count [rocblas_int]
                number of instances in the batch.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_stbsv_batched",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int32,
            Int32,
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(handle, uplo, trans_a, diag, n, k, _a, lda, x, incx, batch_count)


fn rocblas_ccopy_64(
    handle: Handle,
    n: Int64,
    x: UnsafePointer[ComplexFloat32],
    incx: Int64,
    y: UnsafePointer[ComplexFloat32],
    incy: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_ccopy_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int64,
            UnsafePointer[ComplexFloat32],
            Int64,
        ) -> Status,
    ]()(handle, n, x, incx, y, incy)


fn rocblas_sger_batched_64(
    handle: Handle,
    m: Int64,
    n: Int64,
    alpha: UnsafePointer[Float32],
    x: OpaquePointer,
    incx: Int64,
    y: OpaquePointer,
    incy: Int64,
    _a: OpaquePointer,
    lda: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_sger_batched_64",
        fn (
            Handle,
            Int64,
            Int64,
            UnsafePointer[Float32],
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, m, n, alpha, x, incx, y, incy, _a, lda, batch_count)


fn rocblas_ctpmv(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int32,
    _a: UnsafePointer[ComplexFloat32],
    x: UnsafePointer[ComplexFloat32],
    incx: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_ctpmv",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int32,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int32,
        ) -> Status,
    ]()(handle, uplo, trans_a, diag, n, _a, x, incx)


fn rocblas_drot_strided_batched(
    handle: Handle,
    n: Int32,
    x: UnsafePointer[Float64],
    incx: Int32,
    stride_x: Int64,
    y: UnsafePointer[Float64],
    incy: Int32,
    stride_y: Int64,
    c: UnsafePointer[Float64],
    s: UnsafePointer[Float64],
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_drot_strided_batched",
        fn (
            Handle,
            Int32,
            UnsafePointer[Float64],
            Int32,
            Int64,
            UnsafePointer[Float64],
            Int32,
            Int64,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int32,
        ) -> Status,
    ]()(handle, n, x, incx, stride_x, y, incy, stride_y, c, s, batch_count)


fn rocblas_cher2_batched_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    alpha: UnsafePointer[ComplexFloat32],
    x: OpaquePointer,
    incx: Int64,
    y: OpaquePointer,
    incy: Int64,
    _a: OpaquePointer,
    lda: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_cher2_batched_64",
        fn (
            Handle,
            Fill,
            Int64,
            UnsafePointer[ComplexFloat32],
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, uplo, n, alpha, x, incx, y, incy, _a, lda, batch_count)


fn rocblas_isamax_64(
    handle: Handle,
    n: Int64,
    x: UnsafePointer[Float32],
    incx: Int64,
    result: UnsafePointer[Int64],
) -> Status:
    return _get_dylib_function[
        "rocblas_isamax_64",
        fn (
            Handle, Int64, UnsafePointer[Float32], Int64, UnsafePointer[Int64]
        ) -> Status,
    ]()(handle, n, x, incx, result)


fn rocblas_zsyr_strided_batched_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    alpha: UnsafePointer[ComplexFloat64],
    x: UnsafePointer[ComplexFloat64],
    incx: Int64,
    stridex: Int64,
    _a: UnsafePointer[ComplexFloat64],
    lda: Int64,
    stride_a: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_zsyr_strided_batched_64",
        fn (
            Handle,
            Fill,
            Int64,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int64,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int64,
            Int64,
            Int64,
        ) -> Status,
    ]()(
        handle, uplo, n, alpha, x, incx, stridex, _a, lda, stride_a, batch_count
    )


fn rocblas_cgemv_batched(
    handle: Handle,
    trans: Operation,
    m: Int32,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat32],
    _a: OpaquePointer,
    lda: Int32,
    x: OpaquePointer,
    incx: Int32,
    beta: UnsafePointer[ComplexFloat32],
    y: OpaquePointer,
    incy: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_cgemv_batched",
        fn (
            Handle,
            Operation,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat32],
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            UnsafePointer[ComplexFloat32],
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(
        handle, trans, m, n, alpha, _a, lda, x, incx, beta, y, incy, batch_count
    )


fn rocblas_scasum_batched_64(
    handle: Handle,
    n: Int64,
    x: OpaquePointer,
    incx: Int64,
    batch_count: Int64,
    results: UnsafePointer[Float32],
) -> Status:
    return _get_dylib_function[
        "rocblas_scasum_batched_64",
        fn (
            Handle,
            Int64,
            OpaquePointer,
            Int64,
            Int64,
            UnsafePointer[Float32],
        ) -> Status,
    ]()(handle, n, x, incx, batch_count, results)


fn rocblas_dsyr2_batched(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    alpha: UnsafePointer[Float64],
    x: OpaquePointer,
    incx: Int32,
    y: OpaquePointer,
    incy: Int32,
    _a: OpaquePointer,
    lda: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_dsyr2_batched",
        fn (
            Handle,
            Fill,
            Int32,
            UnsafePointer[Float64],
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(handle, uplo, n, alpha, x, incx, y, incy, _a, lda, batch_count)


fn rocblas_ssyr_strided_batched(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    alpha: UnsafePointer[Float32],
    x: UnsafePointer[Float32],
    incx: Int32,
    stridex: Int64,
    _a: UnsafePointer[Float32],
    lda: Int32,
    stride_a: Int64,
    batch_count: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 2 API </b>.

    \\details
    syr_strided_batched performs the matrix-vector operations:

        A[i] := A[i] + alpha*x[i]*x[i]**T
        where alpha is a scalar, vectors, and A is an array of
        n by n symmetric matrices, for i = 1 , ... , batch_count.

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    uplo      [rocblas_fill]
            specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
            - if rocblas_fill_upper, the lower part of A is not referenced
            - if rocblas_fill_lower, the upper part of A is not referenced
    @param[in]
    n         [rocblas_int]
              the number of rows and columns of each matrix A.
    @param[in]
    alpha
              device pointer or host pointer to scalar alpha.
    @param[in]
    x         device pointer to the first vector x_1.
    @param[in]
    incx      [rocblas_int]
              specifies the increment for the elements of each x_i.
    @param[in]
    stridex   [rocblas_stride]
              specifies the pointer increment between vectors (x_i) and (x_i+1).
    @param[in, out]
    A         device pointer to the first matrix A_1.
    @param[in]
    lda       [rocblas_int]
              specifies the leading dimension of each A_i.
    @param[in]
    strideA   [rocblas_stride]
              stride from the start of one matrix (A_i) and the next one (A_i+1).
    @param[in]
    batch_count [rocblas_int]
              number of instances in the batch.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_ssyr_strided_batched",
        fn (
            Handle,
            Fill,
            Int32,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int32,
            Int64,
            UnsafePointer[Float32],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle, uplo, n, alpha, x, incx, stridex, _a, lda, stride_a, batch_count
    )


fn rocblas_sgbmv_batched(
    handle: Handle,
    trans: Operation,
    m: Int32,
    n: Int32,
    kl: Int32,
    ku: Int32,
    alpha: UnsafePointer[Float32],
    _a: OpaquePointer,
    lda: Int32,
    x: OpaquePointer,
    incx: Int32,
    beta: UnsafePointer[Float32],
    y: OpaquePointer,
    incy: Int32,
    batch_count: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 2 API </b>.

    \\details
    gbmv_batched performs one of the matrix-vector operations:

        y_i := alpha*A_i*x_i    + beta*y_i,   or
        y_i := alpha*A_i**T*x_i + beta*y_i,   or
        y_i := alpha*A_i**H*x_i + beta*y_i,
        where (A_i, x_i, y_i) is the i-th instance of the batch.
        alpha and beta are scalars, x_i and y_i are vectors and A_i is an
        m by n banded matrix with kl sub-diagonals and ku super-diagonals,
        for i = 1, ..., batch_count.

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    trans     [rocblas_operation]
              indicates whether matrix A is transposed (conjugated) or not.
    @param[in]
    m         [rocblas_int]
              number of rows of each matrix A_i.
    @param[in]
    n         [rocblas_int]
              number of columns of each matrix A_i.
    @param[in]
    kl        [rocblas_int]
              number of sub-diagonals of each A_i.
    @param[in]
    ku        [rocblas_int]
              number of super-diagonals of each A_i.
    @param[in]
    alpha     device pointer or host pointer to scalar alpha.
    @param[in]
        A     device array of device pointers storing each banded matrix A_i.
              Leading (kl + ku + 1) by n part of the matrix contains the coefficients
              of the banded matrix. The leading diagonal resides in row (ku + 1) with
              the first super-diagonal above on the RHS of row ku. The first sub-diagonal
              resides below on the LHS of row ku + 2. This propagates up and down across
              sub/super-diagonals.

                    Ex: (m = n = 7; ku = 2, kl = 2)
                    1 2 3 0 0 0 0             0 0 3 3 3 3 3
                    4 1 2 3 0 0 0             0 2 2 2 2 2 2
                    5 4 1 2 3 0 0    ---->    1 1 1 1 1 1 1
                    0 5 4 1 2 3 0             4 4 4 4 4 4 0
                    0 0 5 4 1 2 3             5 5 5 5 5 0 0
                    0 0 0 5 4 1 2             0 0 0 0 0 0 0
                    0 0 0 0 5 4 1             0 0 0 0 0 0 0

              Note that the empty elements which do not correspond to data will not
              be referenced.
    @param[in]
    lda       [rocblas_int]
              specifies the leading dimension of each A_i. Must be >= (kl + ku + 1)
    @param[in]
    x         device array of device pointers storing each vector x_i.
    @param[in]
    incx      [rocblas_int]
              specifies the increment for the elements of each x_i.
    @param[in]
    beta      device pointer or host pointer to scalar beta.
    @param[in, out]
    y         device array of device pointers storing each vector y_i.
    @param[in]
    incy      [rocblas_int]
              specifies the increment for the elements of each y_i.
    @param[in]
    batch_count [rocblas_int]
                specifies the number of instances in the batch.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_sgbmv_batched",
        fn (
            Handle,
            Operation,
            Int32,
            Int32,
            Int32,
            Int32,
            UnsafePointer[Float32],
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            UnsafePointer[Float32],
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(
        handle,
        trans,
        m,
        n,
        kl,
        ku,
        alpha,
        _a,
        lda,
        x,
        incx,
        beta,
        y,
        incy,
        batch_count,
    )


fn rocblas_ztpsv_64(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int64,
    _ap: UnsafePointer[ComplexFloat64],
    x: UnsafePointer[ComplexFloat64],
    incx: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_ztpsv_64",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int64,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int64,
        ) -> Status,
    ]()(handle, uplo, trans_a, diag, n, _ap, x, incx)


fn rocblas_zspr(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat64],
    x: UnsafePointer[ComplexFloat64],
    incx: Int32,
    _ap: UnsafePointer[ComplexFloat64],
) -> Status:
    return _get_dylib_function[
        "rocblas_zspr",
        fn (
            Handle,
            Fill,
            Int32,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int32,
            UnsafePointer[ComplexFloat64],
        ) -> Status,
    ]()(handle, uplo, n, alpha, x, incx, _ap)


fn rocblas_sgemv(
    handle: Handle,
    trans: Operation,
    m: Int32,
    n: Int32,
    alpha: UnsafePointer[Float32],
    _a: UnsafePointer[Float32],
    lda: Int32,
    x: UnsafePointer[Float32],
    incx: Int32,
    beta: UnsafePointer[Float32],
    y: UnsafePointer[Float32],
    incy: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 2 API </b>.

    \\details
    gemv performs one of the matrix-vector operations:

        y := alpha*A*x    + beta*y,   or
        y := alpha*A**T*x + beta*y,   or
        y := alpha*A**H*x + beta*y,
        where alpha and beta are scalars, x and y are vectors and A is an
        m by n matrix.

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    trans     [rocblas_operation]
              indicates whether matrix A is transposed (conjugated) or not.
    @param[in]
    m         [rocblas_int]
              number of rows of matrix A.
    @param[in]
    n         [rocblas_int]
              number of columns of matrix A.
    @param[in]
    alpha     device pointer or host pointer to scalar alpha.
    @param[in]
    A         device pointer storing matrix A.
    @param[in]
    lda       [rocblas_int]
              specifies the leading dimension of A.
    @param[in]
    x         device pointer storing vector x.
    @param[in]
    incx      [rocblas_int]
              specifies the increment for the elements of x.
    @param[in]
    beta      device pointer or host pointer to scalar beta.
    @param[in, out]
    y         device pointer storing vector y.
    @param[in]
    incy      [rocblas_int]
              specifies the increment for the elements of y.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_sgemv",
        fn (
            Handle,
            Operation,
            Int32,
            Int32,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int32,
            UnsafePointer[Float32],
            Int32,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int32,
        ) -> Status,
    ]()(handle, trans, m, n, alpha, _a, lda, x, incx, beta, y, incy)


fn rocblas_dtrsv_64(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int64,
    _a: UnsafePointer[Float64],
    lda: Int64,
    x: UnsafePointer[Float64],
    incx: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_dtrsv_64",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int64,
            UnsafePointer[Float64],
            Int64,
            UnsafePointer[Float64],
            Int64,
        ) -> Status,
    ]()(handle, uplo, trans_a, diag, n, _a, lda, x, incx)


fn rocblas_zcopy_batched(
    handle: Handle,
    n: Int32,
    x: OpaquePointer,
    incx: Int32,
    y: OpaquePointer,
    incy: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_zcopy_batched",
        fn (
            Handle,
            Int32,
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(handle, n, x, incx, y, incy, batch_count)


fn rocblas_ssymv_strided_batched_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    alpha: UnsafePointer[Float32],
    _a: UnsafePointer[Float32],
    lda: Int64,
    stride_a: Int64,
    x: UnsafePointer[Float32],
    incx: Int64,
    stridex: Int64,
    beta: UnsafePointer[Float32],
    y: UnsafePointer[Float32],
    incy: Int64,
    stridey: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_ssymv_strided_batched_64",
        fn (
            Handle,
            Fill,
            Int64,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int64,
            Int64,
            UnsafePointer[Float32],
            Int64,
            Int64,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int64,
            Int64,
            Int64,
        ) -> Status,
    ]()(
        handle,
        uplo,
        n,
        alpha,
        _a,
        lda,
        stride_a,
        x,
        incx,
        stridex,
        beta,
        y,
        incy,
        stridey,
        batch_count,
    )


fn rocblas_dsbmv_batched_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    k: Int64,
    alpha: UnsafePointer[Float64],
    _a: OpaquePointer,
    lda: Int64,
    x: OpaquePointer,
    incx: Int64,
    beta: UnsafePointer[Float64],
    y: OpaquePointer,
    incy: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_dsbmv_batched_64",
        fn (
            Handle,
            Fill,
            Int64,
            Int64,
            UnsafePointer[Float64],
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            UnsafePointer[Float64],
            OpaquePointer,
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, uplo, n, k, alpha, _a, lda, x, incx, beta, y, incy, batch_count)


fn rocblas_ztpmv_strided_batched(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int32,
    _a: UnsafePointer[ComplexFloat64],
    stride__a: Int64,
    x: UnsafePointer[ComplexFloat64],
    incx: Int32,
    stride_x: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_ztpmv_strided_batched",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int32,
            UnsafePointer[ComplexFloat64],
            Int64,
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        uplo,
        trans_a,
        diag,
        n,
        _a,
        stride__a,
        x,
        incx,
        stride_x,
        batch_count,
    )


fn rocblas_dgemm_batched(
    handle: Handle,
    trans_a: Operation,
    trans_b: Operation,
    m: Int32,
    n: Int32,
    k: Int32,
    alpha: UnsafePointer[Float64],
    _a: OpaquePointer,
    lda: Int32,
    _b: OpaquePointer,
    ldb: Int32,
    beta: UnsafePointer[Float64],
    _c: OpaquePointer,
    ldc: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_dgemm_batched",
        fn (
            Handle,
            Operation,
            Operation,
            Int32,
            Int32,
            Int32,
            UnsafePointer[Float64],
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            UnsafePointer[Float64],
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(
        handle,
        trans_a,
        trans_b,
        m,
        n,
        k,
        alpha,
        _a,
        lda,
        _b,
        ldb,
        beta,
        _c,
        ldc,
        batch_count,
    )


fn rocblas_cscal(
    handle: Handle,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat32],
    x: UnsafePointer[ComplexFloat32],
    incx: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_cscal",
        fn (
            Handle,
            Int32,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int32,
        ) -> Status,
    ]()(handle, n, alpha, x, incx)


fn rocblas_cherkx_strided_batched(
    handle: Handle,
    uplo: Fill,
    trans: Operation,
    n: Int32,
    k: Int32,
    alpha: UnsafePointer[ComplexFloat32],
    _a: UnsafePointer[ComplexFloat32],
    lda: Int32,
    stride__a: Int64,
    _b: UnsafePointer[ComplexFloat32],
    ldb: Int32,
    stride__b: Int64,
    beta: UnsafePointer[Float32],
    _c: UnsafePointer[ComplexFloat32],
    ldc: Int32,
    stride__c: Int64,
    batch_count: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 3 API </b>.

    \\details
    herkx_strided_batched performs a batch of the matrix-matrix operations for a Hermitian rank-k update:

        C_i := alpha*op( A_i )*op( B_i )^H + beta*C_i,

        where  alpha and beta are scalars, op(A_i) and op(B_i) are n by k matrices, and
        C_i is a n x n Hermitian matrix stored as either upper or lower.

    This routine should only be used when the caller can guarantee that the result of op( A )*op( B )^T will be Hermitian.

        op( A_i ) = A_i, op( B_i ) = B_i, and A_i and B_i are n by k if trans == rocblas_operation_none
        op( A_i ) = A_i^H, op( B_i ) = B_i^H,  and A_i and B_i are k by n if trans == rocblas_operation_conjugate_transpose

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.

    @param[in]
    uplo    [rocblas_fill]
            - rocblas_fill_upper:  C_i is an upper triangular matrix
            - rocblas_fill_lower:  C_i is a  lower triangular matrix

    @param[in]
    trans  [rocblas_operation]
            - rocblas_operation_conjugate_transpose: op( A_i ) = A_i^H, op( B_i ) = B_i^H
            - rocblas_operation_none:                op( A_i ) = A_i, op( B_i ) = B_i

    @param[in]
    n       [rocblas_int]
            n specifies the number of rows and columns of C_i. n >= 0.

    @param[in]
    k       [rocblas_int]
            k specifies the number of columns of op(A). k >= 0.

    @param[in]
    alpha
            alpha specifies the scalar alpha. When alpha is
            zero then A is not referenced and A need not be set before
            entry.

    @param[in]
    A       Device pointer to the first matrix A_1 on the GPU of dimension (lda, k)
            when trans is rocblas_operation_none, otherwise of dimension (lda, n).

    @param[in]
    lda     [rocblas_int]
            lda specifies the first dimension of A_i.

                if trans = rocblas_operation_none,  lda >= max( 1, n ),
                otherwise lda >= max( 1, k ).

    @param[in]
    stride_A  [rocblas_stride]
              stride from the start of one matrix (A_i) and the next one (A_i+1)

    @param[in]
    B       Device pointer to the first matrix B_1 on the GPU of dimension (ldb, k)
            when trans is rocblas_operation_none, otherwise of dimension (ldb, n).

    @param[in]
    ldb     [rocblas_int]
            ldb specifies the first dimension of B_i.

                if trans = rocblas_operation_none,  ldb >= max( 1, n ),
                otherwise ldb >= max( 1, k ).

    @param[in]
    stride_B  [rocblas_stride]
              stride from the start of one matrix (B_i) and the next one (B_i+1)

    @param[in]
    beta
            beta specifies the scalar beta. When beta is
            zero then C need not be set before entry.

    @param[in]
    C       Device pointer to the first matrix C_1 on the GPU.
            The imaginary component of the diagonal elements are not used but are set to zero unless quick return.
            only the upper/lower triangular part of each C_i is accessed.

    @param[in]
    ldc    [rocblas_int]
           ldc specifies the first dimension of C. ldc >= max( 1, n ).

    @param[in, out]
    stride_C  [rocblas_stride]
              stride from the start of one matrix (C_i) and the next one (C_i+1).

    @param[in]
    batch_count [rocblas_int]
                number of instances in the batch.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_cherkx_strided_batched",
        fn (
            Handle,
            Fill,
            Operation,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            UnsafePointer[Float32],
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        uplo,
        trans,
        n,
        k,
        alpha,
        _a,
        lda,
        stride__a,
        _b,
        ldb,
        stride__b,
        beta,
        _c,
        ldc,
        stride__c,
        batch_count,
    )


fn rocblas_drotm_batched_64(
    handle: Handle,
    n: Int64,
    x: OpaquePointer,
    incx: Int64,
    y: OpaquePointer,
    incy: Int64,
    param: OpaquePointer,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_drotm_batched_64",
        fn (
            Handle,
            Int64,
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
        ) -> Status,
    ]()(handle, n, x, incx, y, incy, param, batch_count)


fn rocblas_zgbmv_strided_batched(
    handle: Handle,
    trans: Operation,
    m: Int32,
    n: Int32,
    kl: Int32,
    ku: Int32,
    alpha: UnsafePointer[ComplexFloat64],
    _a: UnsafePointer[ComplexFloat64],
    lda: Int32,
    stride__a: Int64,
    x: UnsafePointer[ComplexFloat64],
    incx: Int32,
    stride_x: Int64,
    beta: UnsafePointer[ComplexFloat64],
    y: UnsafePointer[ComplexFloat64],
    incy: Int32,
    stride_y: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_zgbmv_strided_batched",
        fn (
            Handle,
            Operation,
            Int32,
            Int32,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        trans,
        m,
        n,
        kl,
        ku,
        alpha,
        _a,
        lda,
        stride__a,
        x,
        incx,
        stride_x,
        beta,
        y,
        incy,
        stride_y,
        batch_count,
    )


fn rocblas_csscal_batched(
    handle: Handle,
    n: Int32,
    alpha: UnsafePointer[Float32],
    x: OpaquePointer,
    incx: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_csscal_batched",
        fn (
            Handle,
            Int32,
            UnsafePointer[Float32],
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(handle, n, alpha, x, incx, batch_count)


fn rocblas_crot_batched_64(
    handle: Handle,
    n: Int64,
    x: OpaquePointer,
    incx: Int64,
    y: OpaquePointer,
    incy: Int64,
    c: UnsafePointer[Float32],
    s: UnsafePointer[ComplexFloat32],
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_crot_batched_64",
        fn (
            Handle,
            Int64,
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            UnsafePointer[Float32],
            UnsafePointer[ComplexFloat32],
            Int64,
        ) -> Status,
    ]()(handle, n, x, incx, y, incy, c, s, batch_count)


fn rocblas_dsyr_strided_batched_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    alpha: UnsafePointer[Float64],
    x: UnsafePointer[Float64],
    incx: Int64,
    stridex: Int64,
    _a: UnsafePointer[Float64],
    lda: Int64,
    stride_a: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_dsyr_strided_batched_64",
        fn (
            Handle,
            Fill,
            Int64,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int64,
            Int64,
            UnsafePointer[Float64],
            Int64,
            Int64,
            Int64,
        ) -> Status,
    ]()(
        handle, uplo, n, alpha, x, incx, stridex, _a, lda, stride_a, batch_count
    )


fn rocblas_csymm_batched(
    handle: Handle,
    side: Side,
    uplo: Fill,
    m: Int32,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat32],
    _a: OpaquePointer,
    lda: Int32,
    _b: OpaquePointer,
    ldb: Int32,
    beta: UnsafePointer[ComplexFloat32],
    _c: OpaquePointer,
    ldc: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_csymm_batched",
        fn (
            Handle,
            Side,
            Fill,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat32],
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            UnsafePointer[ComplexFloat32],
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(
        handle,
        side,
        uplo,
        m,
        n,
        alpha,
        _a,
        lda,
        _b,
        ldb,
        beta,
        _c,
        ldc,
        batch_count,
    )


fn rocblas_zspr_strided_batched(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat64],
    x: UnsafePointer[ComplexFloat64],
    incx: Int32,
    stride_x: Int64,
    _ap: UnsafePointer[ComplexFloat64],
    stride__a: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_zspr_strided_batched",
        fn (
            Handle,
            Fill,
            Int32,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int64,
            Int32,
        ) -> Status,
    ]()(handle, uplo, n, alpha, x, incx, stride_x, _ap, stride__a, batch_count)


fn rocblas_ztbsv(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int32,
    k: Int32,
    _a: UnsafePointer[ComplexFloat64],
    lda: Int32,
    x: UnsafePointer[ComplexFloat64],
    incx: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_ztbsv",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat64],
            Int32,
            UnsafePointer[ComplexFloat64],
            Int32,
        ) -> Status,
    ]()(handle, uplo, trans_a, diag, n, k, _a, lda, x, incx)


fn rocblas_isamin(
    handle: Handle,
    n: Int32,
    x: UnsafePointer[Float32],
    incx: Int32,
    result: UnsafePointer[Int32],
) -> Status:
    """
    \\brief <b> BLAS Level 1 API </b>.

    \\details
    amin finds the first index of the element of minimum magnitude of a vector x.

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    n         [rocblas_int]
              the number of elements in x.
    @param[in]
    x         device pointer storing vector x.
    @param[in]
    incx      [rocblas_int]
              specifies the increment for the elements of y.
    @param[in, out]
    result
              device pointer or host pointer to store the amin index.
              return is 0.0 if n, incx<=0.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_isamin",
        fn (
            Handle, Int32, UnsafePointer[Float32], Int32, UnsafePointer[Int32]
        ) -> Status,
    ]()(handle, n, x, incx, result)


fn rocblas_dtrtri(
    handle: Handle,
    uplo: Fill,
    diag: Diagonal,
    n: Int32,
    _a: UnsafePointer[Float64],
    lda: Int32,
    inv_a: UnsafePointer[Float64],
    ldinv_a: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_dtrtri",
        fn (
            Handle,
            Fill,
            Diagonal,
            Int32,
            UnsafePointer[Float64],
            Int32,
            UnsafePointer[Float64],
            Int32,
        ) -> Status,
    ]()(handle, uplo, diag, n, _a, lda, inv_a, ldinv_a)


fn rocblas_cher(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    alpha: UnsafePointer[Float32],
    x: UnsafePointer[ComplexFloat32],
    incx: Int32,
    _a: UnsafePointer[ComplexFloat32],
    lda: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 2 API </b>.

    \\details
    her performs the matrix-vector operations:

        A := A + alpha*x*x**H
        where alpha is a real scalar, x is a vector, and A is an
        n by n Hermitian matrix.

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    uplo      [rocblas_fill]
            specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
            - rocblas_fill_upper: The upper triangular part of A is supplied in A.
            - rocblas_fill_lower: The lower triangular part of A is supplied in A.
    @param[in]
    n         [rocblas_int]
              the number of rows and columns of matrix A. Must be at least 0.
    @param[in]
    alpha
              device pointer or host pointer to scalar alpha.
    @param[in]
    x         device pointer storing vector x.
    @param[in]
    incx      [rocblas_int]
              specifies the increment for the elements of x.
    @param[in, out]
    A         device pointer storing the specified triangular portion of the Hermitian matrix A. Of size (lda * n).

                if uplo == rocblas_fill_upper:
                    The upper triangular portion of the Hermitian matrix A is supplied.
                    The lower triangluar portion will not be touched.

                if uplo == rocblas_fill_lower:
                    The lower triangular portion of the Hermitian matrix A is supplied.
                    The upper triangular portion will not be touched.
                Note that the imaginary part of the diagonal elements are not accessed
                and are assumed to be 0.

    @param[in]
    lda       [rocblas_int]
              specifies the leading dimension of A. Must be at least max(1, n).
    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_cher",
        fn (
            Handle,
            Fill,
            Int32,
            UnsafePointer[Float32],
            UnsafePointer[ComplexFloat32],
            Int32,
            UnsafePointer[ComplexFloat32],
            Int32,
        ) -> Status,
    ]()(handle, uplo, n, alpha, x, incx, _a, lda)


fn rocblas_zhpmv_strided_batched_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    alpha: UnsafePointer[ComplexFloat64],
    _ap: UnsafePointer[ComplexFloat64],
    stride__a: Int64,
    x: UnsafePointer[ComplexFloat64],
    incx: Int64,
    stride_x: Int64,
    beta: UnsafePointer[ComplexFloat64],
    y: UnsafePointer[ComplexFloat64],
    incy: Int64,
    stride_y: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_zhpmv_strided_batched_64",
        fn (
            Handle,
            Fill,
            Int64,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int64,
            UnsafePointer[ComplexFloat64],
            Int64,
            Int64,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int64,
            Int64,
            Int64,
        ) -> Status,
    ]()(
        handle,
        uplo,
        n,
        alpha,
        _ap,
        stride__a,
        x,
        incx,
        stride_x,
        beta,
        y,
        incy,
        stride_y,
        batch_count,
    )


fn rocblas_srotm_64(
    handle: Handle,
    n: Int64,
    x: UnsafePointer[Float32],
    incx: Int64,
    y: UnsafePointer[Float32],
    incy: Int64,
    param: UnsafePointer[Float32],
) -> Status:
    return _get_dylib_function[
        "rocblas_srotm_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[Float32],
            Int64,
            UnsafePointer[Float32],
            Int64,
            UnsafePointer[Float32],
        ) -> Status,
    ]()(handle, n, x, incx, y, incy, param)


fn rocblas_dscal(
    handle: Handle,
    n: Int32,
    alpha: UnsafePointer[Float64],
    x: UnsafePointer[Float64],
    incx: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_dscal",
        fn (
            Handle, Int32, UnsafePointer[Float64], UnsafePointer[Float64], Int32
        ) -> Status,
    ]()(handle, n, alpha, x, incx)


fn rocblas_zhpr_batched(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    alpha: UnsafePointer[Float64],
    x: OpaquePointer,
    incx: Int32,
    _ap: OpaquePointer,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_zhpr_batched",
        fn (
            Handle,
            Fill,
            Int32,
            UnsafePointer[Float64],
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
        ) -> Status,
    ]()(handle, uplo, n, alpha, x, incx, _ap, batch_count)


fn rocblas_csymv_strided_batched(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat32],
    _a: UnsafePointer[ComplexFloat32],
    lda: Int32,
    stride_a: Int64,
    x: UnsafePointer[ComplexFloat32],
    incx: Int32,
    stridex: Int64,
    beta: UnsafePointer[ComplexFloat32],
    y: UnsafePointer[ComplexFloat32],
    incy: Int32,
    stridey: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_csymv_strided_batched",
        fn (
            Handle,
            Fill,
            Int32,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        uplo,
        n,
        alpha,
        _a,
        lda,
        stride_a,
        x,
        incx,
        stridex,
        beta,
        y,
        incy,
        stridey,
        batch_count,
    )


fn rocblas_ctpsv(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int32,
    _ap: UnsafePointer[ComplexFloat32],
    x: UnsafePointer[ComplexFloat32],
    incx: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_ctpsv",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int32,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int32,
        ) -> Status,
    ]()(handle, uplo, trans_a, diag, n, _ap, x, incx)


fn rocblas_srotg_strided_batched(
    handle: Handle,
    a: UnsafePointer[Float32],
    stride_a: Int64,
    b: UnsafePointer[Float32],
    stride_b: Int64,
    c: UnsafePointer[Float32],
    stride_c: Int64,
    s: UnsafePointer[Float32],
    stride_s: Int64,
    batch_count: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 1 API </b>.

    \\details
    rotg_strided_batched creates the Givens rotation matrix for the strided batched vectors (a_i b_i), for i = 1, ..., batch_count.
    a, b, c, and s are host pointers to arrays a, b, c, s on the device.

    @param[in]
    handle  [rocblas_handle]
            handle to the rocblas library context queue.
    @param[in, out]
    a       host pointer to first single input vector element a_1 on the device, overwritten with r.
    @param[in]
    stride_a [rocblas_stride]
             distance between elements of a in batch (distance between a_i and a_(i + 1)).
    @param[in, out]
    b       host pointer to first single input vector element b_1 on the device, overwritten with z.
    @param[in]
    stride_b [rocblas_stride]
             distance between elements of b in batch (distance between b_i and b_(i + 1)).
    @param[out]
    c       host pointer to first single cosine element of Givens rotations c_1 on the device.
    @param[in]
    stride_c [rocblas_stride]
             distance between elements of c in batch (distance between c_i and c_(i + 1)).
    @param[out]
    s       host pointer to first single sine element of Givens rotations s_1 on the device.
    @param[in]
    stride_s [rocblas_stride]
             distance between elements of s in batch (distance between s_i and s_(i + 1)).
    @param[in]
    batch_count [rocblas_int]
                number of batches (length of arrays a, b, c, and s).

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_srotg_strided_batched",
        fn (
            Handle,
            UnsafePointer[Float32],
            Int64,
            UnsafePointer[Float32],
            Int64,
            UnsafePointer[Float32],
            Int64,
            UnsafePointer[Float32],
            Int64,
            Int32,
        ) -> Status,
    ]()(handle, a, stride_a, b, stride_b, c, stride_c, s, stride_s, batch_count)


fn rocblas_ssbmv_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    k: Int64,
    alpha: UnsafePointer[Float32],
    _a: UnsafePointer[Float32],
    lda: Int64,
    x: UnsafePointer[Float32],
    incx: Int64,
    beta: UnsafePointer[Float32],
    y: UnsafePointer[Float32],
    incy: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_ssbmv_64",
        fn (
            Handle,
            Fill,
            Int64,
            Int64,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int64,
            UnsafePointer[Float32],
            Int64,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int64,
        ) -> Status,
    ]()(handle, uplo, n, k, alpha, _a, lda, x, incx, beta, y, incy)


fn rocblas_sscal_batched_64(
    handle: Handle,
    n: Int64,
    alpha: UnsafePointer[Float32],
    x: OpaquePointer,
    incx: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_sscal_batched_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[Float32],
            OpaquePointer,
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, n, alpha, x, incx, batch_count)


fn rocblas_stbsv(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int32,
    k: Int32,
    _a: UnsafePointer[Float32],
    lda: Int32,
    x: UnsafePointer[Float32],
    incx: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 2 API </b>.

    \\details
    tbsv solves:

         A*x = b or
         A**T*x = b or
         A**H*x = b
         where x and b are vectors and A is a banded triangular matrix.

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.

    @param[in]
    uplo    [rocblas_fill]
            - rocblas_fill_upper:  A is an upper triangular matrix.
            - rocblas_fill_lower:  A is a  lower triangular matrix.

    @param[in]
    transA     [rocblas_operation]
            - rocblas_operation_none: Solves A*x = b
            - rocblas_operation_transpose: Solves A**T*x = b
            - rocblas_operation_conjugate_transpose: Solves A**H*x = b

    @param[in]
    diag    [rocblas_diagonal]
            - rocblas_diagonal_unit: A is assumed to be unit triangular (i.e. the diagonal elements
            of A are not used in computations).
            - rocblas_diagonal_non_unit: A is not assumed to be unit triangular.

    @param[in]
    n         [rocblas_int]
              n specifies the number of rows of b. n >= 0.
    @param[in]
    k         [rocblas_int]

            if(uplo == rocblas_fill_upper)
                k specifies the number of super-diagonals of A.
            if(uplo == rocblas_fill_lower)
                k specifies the number of sub-diagonals of A.
            k >= 0.

    @param[in]
    A         device pointer storing the matrix A in banded format.

    @param[in]
    lda       [rocblas_int]
              specifies the leading dimension of A.
              lda >= (k + 1).

    @param[in, out]
    x         device pointer storing input vector b. Overwritten by the output vector x.

    @param[in]
    incx      [rocblas_int]
              specifies the increment for the elements of x.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_stbsv",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int32,
            Int32,
            UnsafePointer[Float32],
            Int32,
            UnsafePointer[Float32],
            Int32,
        ) -> Status,
    ]()(handle, uplo, trans_a, diag, n, k, _a, lda, x, incx)


fn rocblas_ddgmm_strided_batched(
    handle: Handle,
    side: Side,
    m: Int32,
    n: Int32,
    _a: UnsafePointer[Float64],
    lda: Int32,
    stride__a: Int64,
    x: UnsafePointer[Float64],
    incx: Int32,
    stride_x: Int64,
    _c: UnsafePointer[Float64],
    ldc: Int32,
    stride__c: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_ddgmm_strided_batched",
        fn (
            Handle,
            Side,
            Int32,
            Int32,
            UnsafePointer[Float64],
            Int32,
            Int64,
            UnsafePointer[Float64],
            Int32,
            Int64,
            UnsafePointer[Float64],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        side,
        m,
        n,
        _a,
        lda,
        stride__a,
        x,
        incx,
        stride_x,
        _c,
        ldc,
        stride__c,
        batch_count,
    )


fn rocblas_dspmv(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    alpha: UnsafePointer[Float64],
    _a: UnsafePointer[Float64],
    x: UnsafePointer[Float64],
    incx: Int32,
    beta: UnsafePointer[Float64],
    y: UnsafePointer[Float64],
    incy: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_dspmv",
        fn (
            Handle,
            Fill,
            Int32,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int32,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int32,
        ) -> Status,
    ]()(handle, uplo, n, alpha, _a, x, incx, beta, y, incy)


fn rocblas_sspmv_batched_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    alpha: UnsafePointer[Float32],
    _a: OpaquePointer,
    x: OpaquePointer,
    incx: Int64,
    beta: UnsafePointer[Float32],
    y: OpaquePointer,
    incy: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_sspmv_batched_64",
        fn (
            Handle,
            Fill,
            Int64,
            UnsafePointer[Float32],
            OpaquePointer,
            OpaquePointer,
            Int64,
            UnsafePointer[Float32],
            OpaquePointer,
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, uplo, n, alpha, _a, x, incx, beta, y, incy, batch_count)


fn rocblas_zher2k_batched(
    handle: Handle,
    uplo: Fill,
    trans: Operation,
    n: Int32,
    k: Int32,
    alpha: UnsafePointer[ComplexFloat64],
    _a: OpaquePointer,
    lda: Int32,
    _b: OpaquePointer,
    ldb: Int32,
    beta: UnsafePointer[Float64],
    _c: OpaquePointer,
    ldc: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_zher2k_batched",
        fn (
            Handle,
            Fill,
            Operation,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat64],
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            UnsafePointer[Float64],
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(
        handle,
        uplo,
        trans,
        n,
        k,
        alpha,
        _a,
        lda,
        _b,
        ldb,
        beta,
        _c,
        ldc,
        batch_count,
    )


fn rocblas_csyrkx(
    handle: Handle,
    uplo: Fill,
    trans: Operation,
    n: Int32,
    k: Int32,
    alpha: UnsafePointer[ComplexFloat32],
    _a: UnsafePointer[ComplexFloat32],
    lda: Int32,
    _b: UnsafePointer[ComplexFloat32],
    ldb: Int32,
    beta: UnsafePointer[ComplexFloat32],
    _c: UnsafePointer[ComplexFloat32],
    ldc: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_csyrkx",
        fn (
            Handle,
            Fill,
            Operation,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int32,
            UnsafePointer[ComplexFloat32],
            Int32,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int32,
        ) -> Status,
    ]()(handle, uplo, trans, n, k, alpha, _a, lda, _b, ldb, beta, _c, ldc)


fn rocblas_strmv(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int32,
    _a: UnsafePointer[Float32],
    lda: Int32,
    x: UnsafePointer[Float32],
    incx: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 2 API </b>.

    \\details
    trmv performs one of the matrix-vector operations:

        x = A*x or
        x = A**T*x or
        x = A**H*x
        where x is an n element vector and A is an n by n unit, or non-unit, upper or lower triangular matrix.
        The vector x is overwritten.
    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.

    @param[in]
    uplo    [rocblas_fill]
            - rocblas_fill_upper:  A is an upper triangular matrix.
            - rocblas_fill_lower:  A is a  lower triangular matrix.

    @param[in]
    transA     [rocblas_operation]
            - rocblas_operation_none:    op(A) = A.
            - rocblas_operation_transpose:   op(A) = A^T
            - rocblas_operation_conjugate_transpose:  op(A) = A^H

    @param[in]
    diag    [rocblas_diagonal]
            - rocblas_diagonal_unit:     A is assumed to be unit triangular.
            - rocblas_diagonal_non_unit:  A is not assumed to be unit triangular.

    @param[in]
    n         [rocblas_int]
              n specifies the number of rows of A. n >= 0.

    @param[in]
    A         device pointer storing matrix A, of dimension ( lda, n ). If uplo == rocblas_fill_upper, the upper triangular part of the leading n-by-n array contains the matrix A, otherwise the lower triangular part of the leading n-by-n array contains the matrix A.

    @param[in]
    lda       [rocblas_int]
              specifies the leading dimension of A. lda must be at least max( 1, n ).

    @param[in, out]
    x         device pointer storing vector x. On exit, x is overwritten with the transformed vector x.

    @param[in]
    incx      [rocblas_int]
              specifies the increment for the elements of x.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_strmv",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int32,
            UnsafePointer[Float32],
            Int32,
            UnsafePointer[Float32],
            Int32,
        ) -> Status,
    ]()(handle, uplo, trans_a, diag, n, _a, lda, x, incx)


fn rocblas_zher_batched(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    alpha: UnsafePointer[Float64],
    x: OpaquePointer,
    incx: Int32,
    _a: OpaquePointer,
    lda: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_zher_batched",
        fn (
            Handle,
            Fill,
            Int32,
            UnsafePointer[Float64],
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(handle, uplo, n, alpha, x, incx, _a, lda, batch_count)


fn rocblas_csrot_batched(
    handle: Handle,
    n: Int32,
    x: OpaquePointer,
    incx: Int32,
    y: OpaquePointer,
    incy: Int32,
    c: UnsafePointer[Float32],
    s: UnsafePointer[Float32],
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_csrot_batched",
        fn (
            Handle,
            Int32,
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int32,
        ) -> Status,
    ]()(handle, n, x, incx, y, incy, c, s, batch_count)


fn rocblas_cgeru_strided_batched(
    handle: Handle,
    m: Int32,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat32],
    x: UnsafePointer[ComplexFloat32],
    incx: Int32,
    stridex: Int64,
    y: UnsafePointer[ComplexFloat32],
    incy: Int32,
    stridey: Int64,
    _a: UnsafePointer[ComplexFloat32],
    lda: Int32,
    stride_a: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_cgeru_strided_batched",
        fn (
            Handle,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        m,
        n,
        alpha,
        x,
        incx,
        stridex,
        y,
        incy,
        stridey,
        _a,
        lda,
        stride_a,
        batch_count,
    )


fn rocblas_zhemm_batched(
    handle: Handle,
    side: Side,
    uplo: Fill,
    m: Int32,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat64],
    _a: OpaquePointer,
    lda: Int32,
    _b: OpaquePointer,
    ldb: Int32,
    beta: UnsafePointer[ComplexFloat64],
    _c: OpaquePointer,
    ldc: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_zhemm_batched",
        fn (
            Handle,
            Side,
            Fill,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat64],
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            UnsafePointer[ComplexFloat64],
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(
        handle,
        side,
        uplo,
        m,
        n,
        alpha,
        _a,
        lda,
        _b,
        ldb,
        beta,
        _c,
        ldc,
        batch_count,
    )


fn rocblas_nrm2_strided_batched_ex_64(
    handle: Handle,
    n: Int64,
    x: OpaquePointer,
    x_type: DataType,
    incx: Int64,
    stride_x: Int64,
    batch_count: Int64,
    results: OpaquePointer,
    result_type: DataType,
    execution_type: DataType,
) -> Status:
    return _get_dylib_function[
        "rocblas_nrm2_strided_batched_ex_64",
        fn (
            Handle,
            Int64,
            OpaquePointer,
            DataType,
            Int64,
            Int64,
            Int64,
            OpaquePointer,
            DataType,
            DataType,
        ) -> Status,
    ]()(
        handle,
        n,
        x,
        x_type,
        incx,
        stride_x,
        batch_count,
        results,
        result_type,
        execution_type,
    )


fn rocblas_is_managing_device_memory(handle: Handle) -> Bool:
    """\\brief
    \\details
    Returns true when device memory in handle is managed by rocBLAS
    @param[in]
    handle          rocblas handle
    ****************************************************************************.
    """
    return _get_dylib_function[
        "rocblas_is_managing_device_memory", fn (Handle) -> Bool
    ]()(handle)


fn rocblas_set_device_memory_size(handle: Handle, size: Int) -> Status:
    """\\brief
    \\details
    Changes the size of allocated device memory at runtime.

    Any previously allocated device memory managed by the handle is freed.

    If size > 0 sets the device memory size to the specified size (in bytes).
    If size == 0, frees the memory allocated so far, and lets rocBLAS manage device memory in the future, expanding it when necessary.
    Returns rocblas_status_invalid_handle if handle is nullptr; rocblas_status_invalid_pointer if size is nullptr; rocblas_status_success otherwise
    @param[in]
    handle          rocblas handle
    @param[in]
    size            size of allocated device memory
    ****************************************************************************.
    """
    return _get_dylib_function[
        "rocblas_set_device_memory_size", fn (Handle, Int) -> Status
    ]()(handle, size)


fn rocblas_cdgmm_strided_batched(
    handle: Handle,
    side: Side,
    m: Int32,
    n: Int32,
    _a: UnsafePointer[ComplexFloat32],
    lda: Int32,
    stride__a: Int64,
    x: UnsafePointer[ComplexFloat32],
    incx: Int32,
    stride_x: Int64,
    _c: UnsafePointer[ComplexFloat32],
    ldc: Int32,
    stride__c: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_cdgmm_strided_batched",
        fn (
            Handle,
            Side,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        side,
        m,
        n,
        _a,
        lda,
        stride__a,
        x,
        incx,
        stride_x,
        _c,
        ldc,
        stride__c,
        batch_count,
    )


fn rocblas_chpr(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    alpha: UnsafePointer[Float32],
    x: UnsafePointer[ComplexFloat32],
    incx: Int32,
    _ap: UnsafePointer[ComplexFloat32],
) -> Status:
    """
    \\brief <b> BLAS Level 2 API </b>.

    \\details
    hpr performs the matrix-vector operations:

        A := A + alpha*x*x**H
        where alpha is a real scalar, x is a vector, and A is an
        n by n Hermitian matrix, supplied in packed form.

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    uplo      [rocblas_fill]
            specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
            - rocblas_fill_upper: The upper triangular part of A is supplied in AP.
            - rocblas_fill_lower: The lower triangular part of A is supplied in AP.
    @param[in]
    n         [rocblas_int]
              the number of rows and columns of matrix A. Must be at least 0.
    @param[in]
    alpha
              device pointer or host pointer to scalar alpha.
    @param[in]
    x         device pointer storing vector x.
    @param[in]
    incx      [rocblas_int]
              specifies the increment for the elements of x.
    @param[in, out]
    AP        device pointer storing the packed version of the specified triangular portion of
              the Hermitian matrix A. Of at least size ((n * (n + 1)) / 2).

                    if uplo == rocblas_fill_upper:
                        The upper triangular portion of the Hermitian matrix A is supplied.
                        The matrix is compacted so that AP contains the triangular portion
                        column-by-column
                        so that:
                        AP(0) = A(0,0)
                        AP(1) = A(0,1)
                        AP(2) = A(1,1), etc.
                        Ex: (rocblas_fill_upper; n = 3)
                            (1, 0) (2, 1) (4,9)
                            (2,-1) (3, 0) (5,3) ---> [(1,0),(2,1),(3,0),(4,9),(5,3),(6,0)]
                            (4,-9) (5,-3) (6,0)

                    if uplo == rocblas_fill_lower:
                        The lower triangular portion of the Hermitian matrix A is supplied.
                        The matrix is compacted so that AP contains the triangular portion
                        column-by-column
                        so that:
                        AP(0) = A(0,0)
                        AP(1) = A(1,0)
                        AP(2) = A(2,1), etc.
                        Ex: (rocblas_fill_lower; n = 3)
                            (1, 0) (2, 1) (4,9)
                            (2,-1) (3, 0) (5,3) ---> [(1,0),(2,-1),(4,-9),(3,0),(5,-3),(6,0)]
                            (4,-9) (5,-3) (6,0)
                    Note that the imaginary part of the diagonal elements are not accessed
                    and are assumed to be 0.
    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_chpr",
        fn (
            Handle,
            Fill,
            Int32,
            UnsafePointer[Float32],
            UnsafePointer[ComplexFloat32],
            Int32,
            UnsafePointer[ComplexFloat32],
        ) -> Status,
    ]()(handle, uplo, n, alpha, x, incx, _ap)


fn rocblas_stbmv_strided_batched(
    handle: Handle,
    uplo: Fill,
    trans: Operation,
    diag: Diagonal,
    n: Int32,
    k: Int32,
    _a: UnsafePointer[Float32],
    lda: Int32,
    stride__a: Int64,
    x: UnsafePointer[Float32],
    incx: Int32,
    stride_x: Int64,
    batch_count: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 2 API </b>.

    \\details
    tbmv_strided_batched performs one of the matrix-vector operations:

        x_i := A_i*x_i      or
        x_i := A_i**T*x_i   or
        x_i := A_i**H*x_i,
        where (A_i, x_i) is the i-th instance of the batch.
        x_i is a vector and A_i is an n by n matrix, for i = 1, ..., batch_count.

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    uplo      [rocblas_fill]
            - rocblas_fill_upper: each A_i is an upper banded triangular matrix.
            - rocblas_fill_lower: each A_i is a  lower banded triangular matrix.
    @param[in]
    trans     [rocblas_operation]
              indicates whether each matrix A_i is transposed (conjugated) or not.
    @param[in]
    diag      [rocblas_diagonal]
            - rocblas_diagonal_unit: The main diagonal of each A_i is assumed to consist of only
                                     1's and is not referenced.
            - rocblas_diagonal_non_unit: No assumptions are made of each A_i's main diagonal.
    @param[in]
    n         [rocblas_int]
              the number of rows and columns of the matrix represented by each A_i.
    @param[in]
    k         [rocblas_int]

            if uplo == rocblas_fill_upper, k specifies the number of super-diagonals
            of each matrix A_i.

            if uplo == rocblas_fill_lower, k specifies the number of sub-diagonals
            of each matrix A_i.
            k must satisfy k > 0 && k < lda.
    @param[in]
    A         device array to the first matrix A_i of the batch. Stores each banded triangular matrix A_i.

            if uplo == rocblas_fill_upper:
                The matrix represented is an upper banded triangular matrix
                with the main diagonal and k super-diagonals, everything
                else can be assumed to be 0.
                The matrix is compacted so that the main diagonal resides on the k'th
                row, the first super diagonal resides on the RHS of the k-1'th row, etc,
                with the k'th diagonal on the RHS of the 0'th row.
                   Ex: (rocblas_fill_upper; n = 5; k = 2)
                      1 6 9 0 0              0 0 9 8 7
                      0 2 7 8 0              0 6 7 8 9
                      0 0 3 8 7     ---->    1 2 3 4 5
                      0 0 0 4 9              0 0 0 0 0
                      0 0 0 0 5              0 0 0 0 0

            if uplo == rocblas_fill_lower:
                The matrix represented is a lower banded triangular matrix
                with the main diagonal and k sub-diagonals, everything else can be
                assumed to be 0.
                The matrix is compacted so that the main diagonal resides on the 0'th row,
                working up to the k'th diagonal residing on the LHS of the k'th row.
                   Ex: (rocblas_fill_lower; n = 5; k = 2)
                      1 0 0 0 0              1 2 3 4 5
                      6 2 0 0 0              6 7 8 9 0
                      9 7 3 0 0     ---->    9 8 7 0 0
                      0 8 8 4 0              0 0 0 0 0
                      0 0 7 9 5              0 0 0 0 0
    @param[in]
    lda       [rocblas_int]
              specifies the leading dimension of each A_i. lda must satisfy lda > k.
    @param[in]
    stride_A  [rocblas_stride]
              stride from the start of one A_i matrix to the next A_(i + 1).
    @param[in, out]
    x         device array to the first vector x_i of the batch.
    @param[in]
    incx      [rocblas_int]
              specifies the increment for the elements of each x_i.
    @param[in]
    stride_x  [rocblas_stride]
              stride from the start of one x_i matrix to the next x_(i + 1).
    @param[in]
    batch_count [rocblas_int]
                number of instances in the batch.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_stbmv_strided_batched",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int32,
            Int32,
            UnsafePointer[Float32],
            Int32,
            Int64,
            UnsafePointer[Float32],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        uplo,
        trans,
        diag,
        n,
        k,
        _a,
        lda,
        stride__a,
        x,
        incx,
        stride_x,
        batch_count,
    )


fn rocblas_crot_strided_batched(
    handle: Handle,
    n: Int32,
    x: UnsafePointer[ComplexFloat32],
    incx: Int32,
    stride_x: Int64,
    y: UnsafePointer[ComplexFloat32],
    incy: Int32,
    stride_y: Int64,
    c: UnsafePointer[Float32],
    s: UnsafePointer[ComplexFloat32],
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_crot_strided_batched",
        fn (
            Handle,
            Int32,
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            UnsafePointer[Float32],
            UnsafePointer[ComplexFloat32],
            Int32,
        ) -> Status,
    ]()(handle, n, x, incx, stride_x, y, incy, stride_y, c, s, batch_count)


fn rocblas_ztpmv(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int32,
    _a: UnsafePointer[ComplexFloat64],
    x: UnsafePointer[ComplexFloat64],
    incx: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_ztpmv",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int32,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int32,
        ) -> Status,
    ]()(handle, uplo, trans_a, diag, n, _a, x, incx)


fn rocblas_trsm_strided_batched_ex(
    handle: Handle,
    side: Side,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    m: Int32,
    n: Int32,
    alpha: OpaquePointer,
    _a: OpaquePointer,
    lda: Int32,
    stride__a: Int64,
    _b: OpaquePointer,
    ldb: Int32,
    stride__b: Int64,
    batch_count: Int32,
    inv_a: OpaquePointer,
    inv_a_size: Int32,
    stride_inv_a: Int64,
    compute_type: DataType,
) -> Status:
    """
    \\brief <b> BLAS EX API </b>.

    \\details
    trsm_strided_batched_ex solves:

        op(A_i)*X_i = alpha*B_i or X_i*op(A_i) = alpha*B_i,

    for i = 1, ..., batch_count; and where alpha is a scalar, X and B are strided batched m by n matrices,
    A is a strided batched triangular matrix and op(A_i) is one of

        op( A_i ) = A_i   or   op( A_i ) = A_i^T   or   op( A_i ) = A_i^H.

    Each matrix X_i is overwritten on B_i.

    This function gives the user the ability to reuse each invA_i matrix between runs.
    If invA == NULL, rocblas_trsm_batched_ex will automatically calculate each invA_i on every run.

    Setting up invA:
    Each accepted invA_i matrix consists of the packed 128x128 inverses of the diagonal blocks of
    matrix A_i, followed by any smaller diagonal block that remains.
    To set up invA_i it is recommended that rocblas_trtri_batched be used with matrix A_i as the input.
    invA is a contiguous piece of memory holding each invA_i.

    Device memory of size 128 x k should be allocated for each invA_i ahead of time, where k is m when
    rocblas_side_left and is n when rocblas_side_right. The actual number of elements in each invA_i
    should be passed as invA_size.

    To begin, rocblas_trtri_batched must be called on the full 128x128-sized diagonal blocks of each
    matrix A_i. Below are the restricted parameters:
      - n = 128
      - ldinvA = 128
      - stride_invA = 128x128
      - batch_count = k / 128

    Then any remaining block may be added:
      - n = k % 128
      - invA = invA + stride_invA * previous_batch_count
      - ldinvA = 128
      - batch_count = 1

    @param[in]
    handle  [rocblas_handle]
            handle to the rocblas library context queue.

    @param[in]
    side    [rocblas_side]
            - rocblas_side_left:       op(A)*X = alpha*B
            - rocblas_side_right:      X*op(A) = alpha*B

    @param[in]
    uplo    [rocblas_fill]
            - rocblas_fill_upper:  each A_i is an upper triangular matrix.
            - rocblas_fill_lower:  each A_i is a lower triangular matrix.

    @param[in]
    transA  [rocblas_operation]
            - transB:    op(A) = A.
            - rocblas_operation_transpose:      op(A) = A^T
            - rocblas_operation_conjugate_transpose:  op(A) = A^H

    @param[in]
    diag    [rocblas_diagonal]
            - rocblas_diagonal_unit:     each A_i is assumed to be unit triangular.
            - rocblas_diagonal_non_unit:  each A_i is not assumed to be unit triangular.

    @param[in]
    m       [rocblas_int]
            m specifies the number of rows of each B_i. m >= 0.

    @param[in]
    n       [rocblas_int]
            n specifies the number of columns of each B_i. n >= 0.

    @param[in]
    alpha   [void *]
            device pointer or host pointer specifying the scalar alpha. When alpha is
            &zero then A is not referenced, and B need not be set before
            entry.

    @param[in]
    A       [void *]
            device pointer storing matrix A.
            of dimension ( lda, k ), where k is m
            when rocblas_side_left and
            is n when rocblas_side_right
            only the upper/lower triangular part is accessed.

    @param[in]
    lda     [rocblas_int]
            lda specifies the first dimension of A.

                if side = rocblas_side_left,  lda >= max( 1, m ),
                if side = rocblas_side_right, lda >= max( 1, n ).

    @param[in]
    stride_A [rocblas_stride]
            The stride between each A matrix.

    @param[in, out]
    B       [void *]
            device pointer pointing to first matrix B_i.
            each B_i is of dimension ( ldb, n ).
            Before entry, the leading m by n part of each array B_i must
            contain the right-hand side of matrix B_i, and on exit is
            overwritten by the solution matrix X_i.

    @param[in]
    ldb    [rocblas_int]
           ldb specifies the first dimension of each B_i. ldb >= max( 1, m ).

    @param[in]
    stride_B [rocblas_stride]
            The stride between each B_i matrix.

    @param[in]
    batch_count [rocblas_int]
            specifies how many batches.

    @param[in]
    invA    [void *]
            device pointer storing the inverse diagonal blocks of each A_i.
            invA points to the first invA_1.
            each invA_i is of dimension ( ld_invA, k ), where k is m
            when rocblas_side_left and
            is n when rocblas_side_right.
            ld_invA must be equal to 128.

    @param[in]
    invA_size [rocblas_int]
            invA_size specifies the number of elements of device memory in each invA_i.

    @param[in]
    stride_invA [rocblas_stride]
            The stride between each invA matrix.

    @param[in]
    compute_type [rocblas_datatype]
            specifies the datatype of computation.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_trsm_strided_batched_ex",
        fn (
            Handle,
            Side,
            Fill,
            Operation,
            Diagonal,
            Int32,
            Int32,
            OpaquePointer,
            OpaquePointer,
            Int32,
            Int64,
            OpaquePointer,
            Int32,
            Int64,
            Int32,
            OpaquePointer,
            Int32,
            Int64,
            DataType,
        ) -> Status,
    ]()(
        handle,
        side,
        uplo,
        trans_a,
        diag,
        m,
        n,
        alpha,
        _a,
        lda,
        stride__a,
        _b,
        ldb,
        stride__b,
        batch_count,
        inv_a,
        inv_a_size,
        stride_inv_a,
        compute_type,
    )


fn rocblas_ctbsv_batched_64(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int64,
    k: Int64,
    _a: OpaquePointer,
    lda: Int64,
    x: OpaquePointer,
    incx: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_ctbsv_batched_64",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int64,
            Int64,
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, uplo, trans_a, diag, n, k, _a, lda, x, incx, batch_count)


fn rocblas_dspr2_batched(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    alpha: UnsafePointer[Float64],
    x: OpaquePointer,
    incx: Int32,
    y: OpaquePointer,
    incy: Int32,
    _ap: OpaquePointer,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_dspr2_batched",
        fn (
            Handle,
            Fill,
            Int32,
            UnsafePointer[Float64],
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
        ) -> Status,
    ]()(handle, uplo, n, alpha, x, incx, y, incy, _ap, batch_count)


fn rocblas_zsymv_strided_batched_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    alpha: UnsafePointer[ComplexFloat64],
    _a: UnsafePointer[ComplexFloat64],
    lda: Int64,
    stride_a: Int64,
    x: UnsafePointer[ComplexFloat64],
    incx: Int64,
    stridex: Int64,
    beta: UnsafePointer[ComplexFloat64],
    y: UnsafePointer[ComplexFloat64],
    incy: Int64,
    stridey: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_zsymv_strided_batched_64",
        fn (
            Handle,
            Fill,
            Int64,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int64,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int64,
            Int64,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int64,
            Int64,
            Int64,
        ) -> Status,
    ]()(
        handle,
        uplo,
        n,
        alpha,
        _a,
        lda,
        stride_a,
        x,
        incx,
        stridex,
        beta,
        y,
        incy,
        stridey,
        batch_count,
    )


fn rocblas_dsymv_batched_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    alpha: UnsafePointer[Float64],
    _a: OpaquePointer,
    lda: Int64,
    x: OpaquePointer,
    incx: Int64,
    beta: UnsafePointer[Float64],
    y: OpaquePointer,
    incy: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_dsymv_batched_64",
        fn (
            Handle,
            Fill,
            Int64,
            UnsafePointer[Float64],
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            UnsafePointer[Float64],
            OpaquePointer,
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, uplo, n, alpha, _a, lda, x, incx, beta, y, incy, batch_count)


fn rocblas_isamin_strided_batched_64(
    handle: Handle,
    n: Int64,
    x: UnsafePointer[Float32],
    incx: Int64,
    stridex: Int64,
    batch_count: Int64,
    result: UnsafePointer[Int64],
) -> Status:
    return _get_dylib_function[
        "rocblas_isamin_strided_batched_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[Float32],
            Int64,
            Int64,
            Int64,
            UnsafePointer[Int64],
        ) -> Status,
    ]()(handle, n, x, incx, stridex, batch_count, result)


fn rocblas_zdotc_batched_64(
    handle: Handle,
    n: Int64,
    x: OpaquePointer,
    incx: Int64,
    y: OpaquePointer,
    incy: Int64,
    batch_count: Int64,
    result: UnsafePointer[ComplexFloat64],
) -> Status:
    return _get_dylib_function[
        "rocblas_zdotc_batched_64",
        fn (
            Handle,
            Int64,
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            Int64,
            UnsafePointer[ComplexFloat64],
        ) -> Status,
    ]()(handle, n, x, incx, y, incy, batch_count, result)


fn rocblas_ssyr2_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    alpha: UnsafePointer[Float32],
    x: UnsafePointer[Float32],
    incx: Int64,
    y: UnsafePointer[Float32],
    incy: Int64,
    _a: UnsafePointer[Float32],
    lda: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_ssyr2_64",
        fn (
            Handle,
            Fill,
            Int64,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int64,
            UnsafePointer[Float32],
            Int64,
            UnsafePointer[Float32],
            Int64,
        ) -> Status,
    ]()(handle, uplo, n, alpha, x, incx, y, incy, _a, lda)


fn rocblas_dtrsv_strided_batched(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int32,
    _a: UnsafePointer[Float64],
    lda: Int32,
    stride__a: Int64,
    x: UnsafePointer[Float64],
    incx: Int32,
    stride_x: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_dtrsv_strided_batched",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int32,
            UnsafePointer[Float64],
            Int32,
            Int64,
            UnsafePointer[Float64],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        uplo,
        trans_a,
        diag,
        n,
        _a,
        lda,
        stride__a,
        x,
        incx,
        stride_x,
        batch_count,
    )


fn rocblas_drotm_batched(
    handle: Handle,
    n: Int32,
    x: OpaquePointer,
    incx: Int32,
    y: OpaquePointer,
    incy: Int32,
    param: OpaquePointer,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_drotm_batched",
        fn (
            Handle,
            Int32,
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
        ) -> Status,
    ]()(handle, n, x, incx, y, incy, param, batch_count)


fn rocblas_sgbmv_strided_batched_64(
    handle: Handle,
    trans: Operation,
    m: Int64,
    n: Int64,
    kl: Int64,
    ku: Int64,
    alpha: UnsafePointer[Float32],
    _a: UnsafePointer[Float32],
    lda: Int64,
    stride__a: Int64,
    x: UnsafePointer[Float32],
    incx: Int64,
    stride_x: Int64,
    beta: UnsafePointer[Float32],
    y: UnsafePointer[Float32],
    incy: Int64,
    stride_y: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_sgbmv_strided_batched_64",
        fn (
            Handle,
            Operation,
            Int64,
            Int64,
            Int64,
            Int64,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int64,
            Int64,
            UnsafePointer[Float32],
            Int64,
            Int64,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int64,
            Int64,
            Int64,
        ) -> Status,
    ]()(
        handle,
        trans,
        m,
        n,
        kl,
        ku,
        alpha,
        _a,
        lda,
        stride__a,
        x,
        incx,
        stride_x,
        beta,
        y,
        incy,
        stride_y,
        batch_count,
    )


fn rocblas_hdot_batched(
    handle: Handle,
    n: Int32,
    x: OpaquePointer,
    incx: Int32,
    y: OpaquePointer,
    incy: Int32,
    batch_count: Int32,
    result: UnsafePointer[Float16],
) -> Status:
    return _get_dylib_function[
        "rocblas_hdot_batched",
        fn (
            Handle,
            Int32,
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            Int32,
            UnsafePointer[Float16],
        ) -> Status,
    ]()(handle, n, x, incx, y, incy, batch_count, result)


fn rocblas_chbmv_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    k: Int64,
    alpha: UnsafePointer[ComplexFloat32],
    _a: UnsafePointer[ComplexFloat32],
    lda: Int64,
    x: UnsafePointer[ComplexFloat32],
    incx: Int64,
    beta: UnsafePointer[ComplexFloat32],
    y: UnsafePointer[ComplexFloat32],
    incy: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_chbmv_64",
        fn (
            Handle,
            Fill,
            Int64,
            Int64,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int64,
            UnsafePointer[ComplexFloat32],
            Int64,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int64,
        ) -> Status,
    ]()(handle, uplo, n, k, alpha, _a, lda, x, incx, beta, y, incy)


fn rocblas_srotg_batched_64(
    handle: Handle,
    a: OpaquePointer,
    b: OpaquePointer,
    c: OpaquePointer,
    s: OpaquePointer,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_srotg_batched_64",
        fn (
            Handle,
            OpaquePointer,
            OpaquePointer,
            OpaquePointer,
            OpaquePointer,
            Int64,
        ) -> Status,
    ]()(handle, a, b, c, s, batch_count)


fn rocblas_stpmv_batched_64(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int64,
    _a: UnsafePointer[UnsafePointer[Float32]],
    x: UnsafePointer[UnsafePointer[Float32]],
    incx: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_stpmv_batched_64",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int64,
            UnsafePointer[UnsafePointer[Float32]],
            UnsafePointer[UnsafePointer[Float32]],
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, uplo, trans_a, diag, n, _a, x, incx, batch_count)


fn rocblas_cdotu_64(
    handle: Handle,
    n: Int64,
    x: UnsafePointer[ComplexFloat32],
    incx: Int64,
    y: UnsafePointer[ComplexFloat32],
    incy: Int64,
    result: UnsafePointer[ComplexFloat32],
) -> Status:
    return _get_dylib_function[
        "rocblas_cdotu_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int64,
            UnsafePointer[ComplexFloat32],
            Int64,
            UnsafePointer[ComplexFloat32],
        ) -> Status,
    ]()(handle, n, x, incx, y, incy, result)


fn rocblas_dspr_strided_batched(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    alpha: UnsafePointer[Float64],
    x: UnsafePointer[Float64],
    incx: Int32,
    stride_x: Int64,
    _ap: UnsafePointer[Float64],
    stride__a: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_dspr_strided_batched",
        fn (
            Handle,
            Fill,
            Int32,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int32,
            Int64,
            UnsafePointer[Float64],
            Int64,
            Int32,
        ) -> Status,
    ]()(handle, uplo, n, alpha, x, incx, stride_x, _ap, stride__a, batch_count)


fn rocblas_scnrm2_strided_batched_64(
    handle: Handle,
    n: Int64,
    x: UnsafePointer[ComplexFloat32],
    incx: Int64,
    stridex: Int64,
    batch_count: Int64,
    results: UnsafePointer[Float32],
) -> Status:
    return _get_dylib_function[
        "rocblas_scnrm2_strided_batched_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int64,
            Int64,
            Int64,
            UnsafePointer[Float32],
        ) -> Status,
    ]()(handle, n, x, incx, stridex, batch_count, results)


fn rocblas_csrot(
    handle: Handle,
    n: Int32,
    x: UnsafePointer[ComplexFloat32],
    incx: Int32,
    y: UnsafePointer[ComplexFloat32],
    incy: Int32,
    c: UnsafePointer[Float32],
    s: UnsafePointer[Float32],
) -> Status:
    return _get_dylib_function[
        "rocblas_csrot",
        fn (
            Handle,
            Int32,
            UnsafePointer[ComplexFloat32],
            Int32,
            UnsafePointer[ComplexFloat32],
            Int32,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
        ) -> Status,
    ]()(handle, n, x, incx, y, incy, c, s)


fn rocblas_dgemmt_batched(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    trans_b: Operation,
    n: Int32,
    k: Int32,
    alpha: UnsafePointer[Float64],
    _a: OpaquePointer,
    lda: Int32,
    _b: OpaquePointer,
    ldb: Int32,
    beta: UnsafePointer[Float64],
    _c: OpaquePointer,
    ldc: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_dgemmt_batched",
        fn (
            Handle,
            Fill,
            Operation,
            Operation,
            Int32,
            Int32,
            UnsafePointer[Float64],
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            UnsafePointer[Float64],
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(
        handle,
        uplo,
        trans_a,
        trans_b,
        n,
        k,
        alpha,
        _a,
        lda,
        _b,
        ldb,
        beta,
        _c,
        ldc,
        batch_count,
    )


fn rocblas_device_malloc_set_default_memory_size(size: Int) -> NoneType:
    return _get_dylib_function[
        "rocblas_device_malloc_set_default_memory_size", fn (Int) -> NoneType
    ]()(size)


fn rocblas_zswap_strided_batched(
    handle: Handle,
    n: Int32,
    x: UnsafePointer[ComplexFloat64],
    incx: Int32,
    stridex: Int64,
    y: UnsafePointer[ComplexFloat64],
    incy: Int32,
    stridey: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_zswap_strided_batched",
        fn (
            Handle,
            Int32,
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(handle, n, x, incx, stridex, y, incy, stridey, batch_count)


fn rocblas_hshgemv_batched_64(
    handle: Handle,
    trans: Operation,
    m: Int64,
    n: Int64,
    alpha: UnsafePointer[Float32],
    _a: OpaquePointer,
    lda: Int64,
    x: OpaquePointer,
    incx: Int64,
    beta: UnsafePointer[Float32],
    y: OpaquePointer,
    incy: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_hshgemv_batched_64",
        fn (
            Handle,
            Operation,
            Int64,
            Int64,
            UnsafePointer[Float32],
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            UnsafePointer[Float32],
            OpaquePointer,
            Int64,
            Int64,
        ) -> Status,
    ]()(
        handle, trans, m, n, alpha, _a, lda, x, incx, beta, y, incy, batch_count
    )


fn rocblas_ssbmv_batched_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    k: Int64,
    alpha: UnsafePointer[Float32],
    _a: OpaquePointer,
    lda: Int64,
    x: OpaquePointer,
    incx: Int64,
    beta: UnsafePointer[Float32],
    y: OpaquePointer,
    incy: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_ssbmv_batched_64",
        fn (
            Handle,
            Fill,
            Int64,
            Int64,
            UnsafePointer[Float32],
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            UnsafePointer[Float32],
            OpaquePointer,
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, uplo, n, k, alpha, _a, lda, x, incx, beta, y, incy, batch_count)


fn rocblas_ztbmv_batched_64(
    handle: Handle,
    uplo: Fill,
    trans: Operation,
    diag: Diagonal,
    n: Int64,
    k: Int64,
    _a: OpaquePointer,
    lda: Int64,
    x: OpaquePointer,
    incx: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_ztbmv_batched_64",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int64,
            Int64,
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, uplo, trans, diag, n, k, _a, lda, x, incx, batch_count)


fn rocblas_zgeru_64(
    handle: Handle,
    m: Int64,
    n: Int64,
    alpha: UnsafePointer[ComplexFloat64],
    x: UnsafePointer[ComplexFloat64],
    incx: Int64,
    y: UnsafePointer[ComplexFloat64],
    incy: Int64,
    _a: UnsafePointer[ComplexFloat64],
    lda: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_zgeru_64",
        fn (
            Handle,
            Int64,
            Int64,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int64,
            UnsafePointer[ComplexFloat64],
            Int64,
            UnsafePointer[ComplexFloat64],
            Int64,
        ) -> Status,
    ]()(handle, m, n, alpha, x, incx, y, incy, _a, lda)


fn rocblas_ctpmv_strided_batched_64(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int64,
    _a: UnsafePointer[ComplexFloat32],
    stride__a: Int64,
    x: UnsafePointer[ComplexFloat32],
    incx: Int64,
    stride_x: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_ctpmv_strided_batched_64",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int64,
            UnsafePointer[ComplexFloat32],
            Int64,
            Int64,
            Int64,
        ) -> Status,
    ]()(
        handle,
        uplo,
        trans_a,
        diag,
        n,
        _a,
        stride__a,
        x,
        incx,
        stride_x,
        batch_count,
    )


fn rocblas_caxpy(
    handle: Handle,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat32],
    x: UnsafePointer[ComplexFloat32],
    incx: Int32,
    y: UnsafePointer[ComplexFloat32],
    incy: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_caxpy",
        fn (
            Handle,
            Int32,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int32,
            UnsafePointer[ComplexFloat32],
            Int32,
        ) -> Status,
    ]()(handle, n, alpha, x, incx, y, incy)


fn rocblas_zgemv_64(
    handle: Handle,
    trans: Operation,
    m: Int64,
    n: Int64,
    alpha: UnsafePointer[ComplexFloat64],
    _a: UnsafePointer[ComplexFloat64],
    lda: Int64,
    x: UnsafePointer[ComplexFloat64],
    incx: Int64,
    beta: UnsafePointer[ComplexFloat64],
    y: UnsafePointer[ComplexFloat64],
    incy: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_zgemv_64",
        fn (
            Handle,
            Operation,
            Int64,
            Int64,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int64,
            UnsafePointer[ComplexFloat64],
            Int64,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int64,
        ) -> Status,
    ]()(handle, trans, m, n, alpha, _a, lda, x, incx, beta, y, incy)


fn rocblas_drotg_batched(
    handle: Handle,
    a: OpaquePointer,
    b: OpaquePointer,
    c: OpaquePointer,
    s: OpaquePointer,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_drotg_batched",
        fn (
            Handle,
            OpaquePointer,
            OpaquePointer,
            OpaquePointer,
            OpaquePointer,
            Int32,
        ) -> Status,
    ]()(handle, a, b, c, s, batch_count)


fn rocblas_ztrsm_batched(
    handle: Handle,
    side: Side,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    m: Int32,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat64],
    _a: OpaquePointer,
    lda: Int32,
    _b: OpaquePointer,
    ldb: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_ztrsm_batched",
        fn (
            Handle,
            Side,
            Fill,
            Operation,
            Diagonal,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat64],
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(
        handle,
        side,
        uplo,
        trans_a,
        diag,
        m,
        n,
        alpha,
        _a,
        lda,
        _b,
        ldb,
        batch_count,
    )


fn rocblas_cgemmt(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    trans_b: Operation,
    n: Int32,
    k: Int32,
    alpha: UnsafePointer[ComplexFloat32],
    _a: UnsafePointer[ComplexFloat32],
    lda: Int32,
    _b: UnsafePointer[ComplexFloat32],
    ldb: Int32,
    beta: UnsafePointer[ComplexFloat32],
    _c: UnsafePointer[ComplexFloat32],
    ldc: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_cgemmt",
        fn (
            Handle,
            Fill,
            Operation,
            Operation,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int32,
            UnsafePointer[ComplexFloat32],
            Int32,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int32,
        ) -> Status,
    ]()(
        handle,
        uplo,
        trans_a,
        trans_b,
        n,
        k,
        alpha,
        _a,
        lda,
        _b,
        ldb,
        beta,
        _c,
        ldc,
    )


fn rocblas_izamin_batched_64(
    handle: Handle,
    n: Int64,
    x: OpaquePointer,
    incx: Int64,
    batch_count: Int64,
    result: UnsafePointer[Int64],
) -> Status:
    return _get_dylib_function[
        "rocblas_izamin_batched_64",
        fn (
            Handle,
            Int64,
            OpaquePointer,
            Int64,
            Int64,
            UnsafePointer[Int64],
        ) -> Status,
    ]()(handle, n, x, incx, batch_count, result)


fn rocblas_status_to_string(status: Status) -> UnsafePointer[Int8]:
    """BLAS Auxiliary API.

    \\details
    rocblas_status_to_string

    Returns string representing rocblas_status value

    @param[in]
    status  [rocblas_status]
            rocBLAS status to convert to string
    ****************************************************************************.
    """
    return _get_dylib_function[
        "rocblas_status_to_string", fn (Status) -> UnsafePointer[Int8]
    ]()(status)


fn rocblas_saxpy(
    handle: Handle,
    n: Int32,
    alpha: UnsafePointer[Float32],
    x: UnsafePointer[Float32],
    incx: Int32,
    y: UnsafePointer[Float32],
    incy: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_saxpy",
        fn (
            Handle,
            Int32,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int32,
            UnsafePointer[Float32],
            Int32,
        ) -> Status,
    ]()(handle, n, alpha, x, incx, y, incy)


fn rocblas_cher2_batched(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat32],
    x: OpaquePointer,
    incx: Int32,
    y: OpaquePointer,
    incy: Int32,
    _a: OpaquePointer,
    lda: Int32,
    batch_count: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 2 API </b>.

    \\details
    her2_batched performs the matrix-vector operations:

        A_i := A_i + alpha*x_i*y_i**H + conj(alpha)*y_i*x_i**H
        where alpha is a complex scalar, x_i and y_i are vectors, and A_i is an
        n by n Hermitian matrix for each batch in i = [1, batch_count].

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    uplo      [rocblas_fill]
            specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
            - rocblas_fill_upper: The upper triangular part of each A_i is supplied.
            - rocblas_fill_lower: The lower triangular part of each A_i is supplied.
    @param[in]
    n         [rocblas_int]
              the number of rows and columns of each matrix A_i. Must be at least 0.
    @param[in]
    alpha
              device pointer or host pointer to scalar alpha.
    @param[in]
    x         device array of device pointers storing each vector x_i.
    @param[in]
    incx      [rocblas_int]
              specifies the increment for the elements of x.
    @param[in]
    y         device array of device pointers storing each vector y_i.
    @param[in]
    incy      [rocblas_int]
              specifies the increment for the elements of each y_i.
    @param[in, out]
    A         device array of device pointers storing the specified triangular portion of
              each Hermitian matrix A_i of size (lda, n).

                    if uplo == rocblas_fill_upper:
                        The upper triangular portion of each Hermitian matrix A_i is supplied.
                        The lower triangular portion of each A_i will not be touched.

                    if uplo == rocblas_fill_lower:
                        The lower triangular portion of each Hermitian matrix A_i is supplied.
                        The upper triangular portion of each A_i will not be touched.
                Note that the imaginary part of the diagonal elements are not accessed
                and are assumed to be 0.
    @param[in]
    lda       [rocblas_int]
              specifies the leading dimension of each A_i. Must be at least max(lda, 1).
    @param[in]
    batch_count [rocblas_int]
                number of instances in the batch.
    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_cher2_batched",
        fn (
            Handle,
            Fill,
            Int32,
            UnsafePointer[ComplexFloat32],
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(handle, uplo, n, alpha, x, incx, y, incy, _a, lda, batch_count)


fn rocblas_ztpmv_64(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int64,
    _a: UnsafePointer[ComplexFloat64],
    x: UnsafePointer[ComplexFloat64],
    incx: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_ztpmv_64",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int64,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int64,
        ) -> Status,
    ]()(handle, uplo, trans_a, diag, n, _a, x, incx)


fn rocblas_sspmv_strided_batched(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    alpha: UnsafePointer[Float32],
    _a: UnsafePointer[Float32],
    stride_a: Int64,
    x: UnsafePointer[Float32],
    incx: Int32,
    stridex: Int64,
    beta: UnsafePointer[Float32],
    y: UnsafePointer[Float32],
    incy: Int32,
    stridey: Int64,
    batch_count: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 2 API </b>.

    \\details
    spmv_strided_batched performs the matrix-vector operation:

        y_i := alpha*A_i*x_i + beta*y_i
        where (A_i, x_i, y_i) is the i-th instance of the batch.
        alpha and beta are scalars, x_i and y_i are vectors and A_i is an
        n by n symmetric matrix, for i = 1, ..., batch_count.
        A should contain an upper or lower triangular n by n packed symmetric matrix.

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    uplo      [rocblas_fill]
            specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
            - if rocblas_fill_upper, the lower part of A is not referenced
            - if rocblas_fill_lower, the upper part of A is not referenced
    @param[in]
    n         [rocblas_int]
              number of rows and columns of each matrix A_i.
    @param[in]
    alpha
              device pointer or host pointer to scalar alpha.
    @param[in]
    A         Device pointer to the first matrix A_1 on the GPU.
    @param[in]
    strideA     [rocblas_stride]
                stride from the start of one matrix (A_i) and the next one (A_i+1).
    @param[in]
    x         Device pointer to the first vector x_1 on the GPU.
    @param[in]
    incx      [rocblas_int]
              specifies the increment for the elements of each vector x_i.
    @param[in]
    stridex     [rocblas_stride]
                stride from the start of one vector (x_i) and the next one (x_i+1).
                There are no restrictions placed on stridex. However, ensure that stridex is of appropriate size.
                This typically means stridex >= n * incx. stridex should be non zero.
    @param[in]
    beta      device pointer or host pointer to scalar beta.
    @param[out]
    y         Device pointer to the first vector y_1 on the GPU.
    @param[in]
    incy      [rocblas_int]
              specifies the increment for the elements of each vector y_i.
    @param[in]
    stridey     [rocblas_stride]
                stride from the start of one vector (y_i) and the next one (y_i+1).
                There are no restrictions placed on stridey. However, ensure that stridey is of appropriate size.
                This typically means stridey >= n * incy. stridey should be non zero.
    @param[in]
    batch_count [rocblas_int]
                number of instances in the batch.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_sspmv_strided_batched",
        fn (
            Handle,
            Fill,
            Int32,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int64,
            UnsafePointer[Float32],
            Int32,
            Int64,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        uplo,
        n,
        alpha,
        _a,
        stride_a,
        x,
        incx,
        stridex,
        beta,
        y,
        incy,
        stridey,
        batch_count,
    )


fn rocblas_drot(
    handle: Handle,
    n: Int32,
    x: UnsafePointer[Float64],
    incx: Int32,
    y: UnsafePointer[Float64],
    incy: Int32,
    c: UnsafePointer[Float64],
    s: UnsafePointer[Float64],
) -> Status:
    return _get_dylib_function[
        "rocblas_drot",
        fn (
            Handle,
            Int32,
            UnsafePointer[Float64],
            Int32,
            UnsafePointer[Float64],
            Int32,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
        ) -> Status,
    ]()(handle, n, x, incx, y, incy, c, s)


fn rocblas_zsymv(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat64],
    _a: UnsafePointer[ComplexFloat64],
    lda: Int32,
    x: UnsafePointer[ComplexFloat64],
    incx: Int32,
    beta: UnsafePointer[ComplexFloat64],
    y: UnsafePointer[ComplexFloat64],
    incy: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_zsymv",
        fn (
            Handle,
            Fill,
            Int32,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int32,
            UnsafePointer[ComplexFloat64],
            Int32,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int32,
        ) -> Status,
    ]()(handle, uplo, n, alpha, _a, lda, x, incx, beta, y, incy)


fn rocblas_csscal(
    handle: Handle,
    n: Int32,
    alpha: UnsafePointer[Float32],
    x: UnsafePointer[ComplexFloat32],
    incx: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_csscal",
        fn (
            Handle,
            Int32,
            UnsafePointer[Float32],
            UnsafePointer[ComplexFloat32],
            Int32,
        ) -> Status,
    ]()(handle, n, alpha, x, incx)


fn rocblas_zrot(
    handle: Handle,
    n: Int32,
    x: UnsafePointer[ComplexFloat64],
    incx: Int32,
    y: UnsafePointer[ComplexFloat64],
    incy: Int32,
    c: UnsafePointer[Float64],
    s: UnsafePointer[ComplexFloat64],
) -> Status:
    return _get_dylib_function[
        "rocblas_zrot",
        fn (
            Handle,
            Int32,
            UnsafePointer[ComplexFloat64],
            Int32,
            UnsafePointer[ComplexFloat64],
            Int32,
            UnsafePointer[Float64],
            UnsafePointer[ComplexFloat64],
        ) -> Status,
    ]()(handle, n, x, incx, y, incy, c, s)


fn rocblas_zgemm_strided_batched(
    handle: Handle,
    trans_a: Operation,
    trans_b: Operation,
    m: Int32,
    n: Int32,
    k: Int32,
    alpha: UnsafePointer[ComplexFloat64],
    _a: UnsafePointer[ComplexFloat64],
    lda: Int32,
    stride_a: Int64,
    _b: UnsafePointer[ComplexFloat64],
    ldb: Int32,
    stride_b: Int64,
    beta: UnsafePointer[ComplexFloat64],
    _c: UnsafePointer[ComplexFloat64],
    ldc: Int32,
    stride_c: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_zgemm_strided_batched",
        fn (
            Handle,
            Operation,
            Operation,
            Int32,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        trans_a,
        trans_b,
        m,
        n,
        k,
        alpha,
        _a,
        lda,
        stride_a,
        _b,
        ldb,
        stride_b,
        beta,
        _c,
        ldc,
        stride_c,
        batch_count,
    )


fn rocblas_zdrot_strided_batched(
    handle: Handle,
    n: Int32,
    x: UnsafePointer[ComplexFloat64],
    incx: Int32,
    stride_x: Int64,
    y: UnsafePointer[ComplexFloat64],
    incy: Int32,
    stride_y: Int64,
    c: UnsafePointer[Float64],
    s: UnsafePointer[Float64],
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_zdrot_strided_batched",
        fn (
            Handle,
            Int32,
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int32,
        ) -> Status,
    ]()(handle, n, x, incx, stride_x, y, incy, stride_y, c, s, batch_count)


fn rocblas_ctrsm(
    handle: Handle,
    side: Side,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    m: Int32,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat32],
    _a: UnsafePointer[ComplexFloat32],
    lda: Int32,
    _b: UnsafePointer[ComplexFloat32],
    ldb: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_ctrsm",
        fn (
            Handle,
            Side,
            Fill,
            Operation,
            Diagonal,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int32,
            UnsafePointer[ComplexFloat32],
            Int32,
        ) -> Status,
    ]()(handle, side, uplo, trans_a, diag, m, n, alpha, _a, lda, _b, ldb)


fn rocblas_ctrsv_strided_batched_64(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int64,
    _a: UnsafePointer[ComplexFloat32],
    lda: Int64,
    stride__a: Int64,
    x: UnsafePointer[ComplexFloat32],
    incx: Int64,
    stride_x: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_ctrsv_strided_batched_64",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int64,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int64,
            Int64,
            Int64,
        ) -> Status,
    ]()(
        handle,
        uplo,
        trans_a,
        diag,
        n,
        _a,
        lda,
        stride__a,
        x,
        incx,
        stride_x,
        batch_count,
    )


fn rocblas_isamax(
    handle: Handle,
    n: Int32,
    x: UnsafePointer[Float32],
    incx: Int32,
    result: UnsafePointer[Int32],
) -> Status:
    """
    \\brief <b> BLAS Level 1 API </b>.

    \\details
    amax finds the first index of the element of maximum magnitude of a vector x.

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    n         [rocblas_int]
              the number of elements in x.
    @param[in]
    x         device pointer storing vector x.
    @param[in]
    incx      [rocblas_int]
              specifies the increment for the elements of y.
    @param[in, out]
    result
              device pointer or host pointer to store the amax index.
              return is 0.0 if n, incx<=0.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_isamax",
        fn (
            Handle, Int32, UnsafePointer[Float32], Int32, UnsafePointer[Int32]
        ) -> Status,
    ]()(handle, n, x, incx, result)


fn rocblas_ztrsv_batched_64(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int64,
    _a: OpaquePointer,
    lda: Int64,
    x: OpaquePointer,
    incx: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_ztrsv_batched_64",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int64,
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, uplo, trans_a, diag, n, _a, lda, x, incx, batch_count)


fn rocblas_ssymm(
    handle: Handle,
    side: Side,
    uplo: Fill,
    m: Int32,
    n: Int32,
    alpha: UnsafePointer[Float32],
    _a: UnsafePointer[Float32],
    lda: Int32,
    _b: UnsafePointer[Float32],
    ldb: Int32,
    beta: UnsafePointer[Float32],
    _c: UnsafePointer[Float32],
    ldc: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 3 API </b>.

    \\details
    symm performs one of the matrix-matrix operations:

        C := alpha*A*B + beta*C if side == rocblas_side_left,
        C := alpha*B*A + beta*C if side == rocblas_side_right,

        where alpha and beta are scalars, B and C are m by n matrices, and
        A is a symmetric matrix stored as either upper or lower.

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.

    @param[in]
    side  [rocblas_side]
            - rocblas_side_left:      C := alpha*A*B + beta*C
            - rocblas_side_right:     C := alpha*B*A + beta*C

    @param[in]
    uplo    [rocblas_fill]
            - rocblas_fill_upper:  A is an upper triangular matrix
            - rocblas_fill_lower:  A is a  lower triangular matrix

    @param[in]
    m       [rocblas_int]
            m specifies the number of rows of B and C. m >= 0.

    @param[in]
    n       [rocblas_int]
            n specifies the number of columns of B and C. n >= 0.

    @param[in]
    alpha
            alpha specifies the scalar alpha. When alpha is
            zero then A and B are not referenced.

    @param[in]
    A       pointer storing matrix A on the GPU.
            - A is m by m if side == rocblas_side_left
            - A is n by n if side == rocblas_side_right
            only the upper/lower triangular part is accessed.

    @param[in]
    lda     [rocblas_int]
            lda specifies the first dimension of A.

                if side = rocblas_side_left,  lda >= max( 1, m ),
                otherwise lda >= max( 1, n ).

    @param[in]
    B       pointer storing matrix B on the GPU.
            Matrix dimension is m by n

    @param[in]
    ldb     [rocblas_int]
            ldb specifies the first dimension of B. ldb >= max( 1, m ).

    @param[in]
    beta
            beta specifies the scalar beta. When beta is
            zero then C need not be set before entry.

    @param[in]
    C       pointer storing matrix C on the GPU.
            Matrix dimension is m by n

    @param[in]
    ldc    [rocblas_int]
           ldc specifies the first dimension of C. ldc >= max( 1, m ).

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_ssymm",
        fn (
            Handle,
            Side,
            Fill,
            Int32,
            Int32,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int32,
            UnsafePointer[Float32],
            Int32,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int32,
        ) -> Status,
    ]()(handle, side, uplo, m, n, alpha, _a, lda, _b, ldb, beta, _c, ldc)


fn rocblas_dspmv_batched_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    alpha: UnsafePointer[Float64],
    _a: OpaquePointer,
    x: OpaquePointer,
    incx: Int64,
    beta: UnsafePointer[Float64],
    y: OpaquePointer,
    incy: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_dspmv_batched_64",
        fn (
            Handle,
            Fill,
            Int64,
            UnsafePointer[Float64],
            OpaquePointer,
            OpaquePointer,
            Int64,
            UnsafePointer[Float64],
            OpaquePointer,
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, uplo, n, alpha, _a, x, incx, beta, y, incy, batch_count)


fn rocblas_sger(
    handle: Handle,
    m: Int32,
    n: Int32,
    alpha: UnsafePointer[Float32],
    x: UnsafePointer[Float32],
    incx: Int32,
    y: UnsafePointer[Float32],
    incy: Int32,
    _a: UnsafePointer[Float32],
    lda: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 2 API </b>.

    \\details
    ger,geru,gerc performs the matrix-vector operations:

        A := A + alpha*x*y**T , OR
        A := A + alpha*x*y**H for gerc
        where alpha is a scalar, x and y are vectors, and A is an
        m by n matrix.

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    m         [rocblas_int]
              the number of rows of the matrix A.
    @param[in]
    n         [rocblas_int]
              the number of columns of the matrix A.
    @param[in]
    alpha
              device pointer or host pointer to scalar alpha.
    @param[in]
    x         device pointer storing vector x.
    @param[in]
    incx      [rocblas_int]
              specifies the increment for the elements of x.
    @param[in]
    y         device pointer storing vector y.
    @param[in]
    incy      [rocblas_int]
              specifies the increment for the elements of y.
    @param[in, out]
    A         device pointer storing matrix A.
    @param[in]
    lda       [rocblas_int]
              specifies the leading dimension of A.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_sger",
        fn (
            Handle,
            Int32,
            Int32,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int32,
            UnsafePointer[Float32],
            Int32,
            UnsafePointer[Float32],
            Int32,
        ) -> Status,
    ]()(handle, m, n, alpha, x, incx, y, incy, _a, lda)


fn rocblas_crotg_batched(
    handle: Handle,
    a: OpaquePointer,
    b: OpaquePointer,
    c: OpaquePointer,
    s: OpaquePointer,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_crotg_batched",
        fn (
            Handle,
            OpaquePointer,
            OpaquePointer,
            OpaquePointer,
            OpaquePointer,
            Int32,
        ) -> Status,
    ]()(handle, a, b, c, s, batch_count)


fn rocblas_srotmg_strided_batched_64(
    handle: Handle,
    d1: UnsafePointer[Float32],
    stride_d1: Int64,
    d2: UnsafePointer[Float32],
    stride_d2: Int64,
    x1: UnsafePointer[Float32],
    stride_x1: Int64,
    y1: UnsafePointer[Float32],
    stride_y1: Int64,
    param: UnsafePointer[Float32],
    stride_param: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_srotmg_strided_batched_64",
        fn (
            Handle,
            UnsafePointer[Float32],
            Int64,
            UnsafePointer[Float32],
            Int64,
            UnsafePointer[Float32],
            Int64,
            UnsafePointer[Float32],
            Int64,
            UnsafePointer[Float32],
            Int64,
            Int64,
        ) -> Status,
    ]()(
        handle,
        d1,
        stride_d1,
        d2,
        stride_d2,
        x1,
        stride_x1,
        y1,
        stride_y1,
        param,
        stride_param,
        batch_count,
    )


fn rocblas_device_malloc_get(
    ptr: UnsafePointer[MallocBase],
    index: Int,
    res: UnsafePointer[OpaquePointer],
) -> Status:
    return _get_dylib_function[
        "rocblas_device_malloc_get",
        fn (
            UnsafePointer[MallocBase],
            Int,
            UnsafePointer[OpaquePointer],
        ) -> Status,
    ]()(ptr, index, res)


fn rocblas_cherk_batched(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    n: Int32,
    k: Int32,
    alpha: UnsafePointer[Float32],
    _a: OpaquePointer,
    lda: Int32,
    beta: UnsafePointer[Float32],
    _c: OpaquePointer,
    ldc: Int32,
    batch_count: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 3 API </b>.

    \\details
    herk_batched performs a batch of the matrix-matrix operations for a Hermitian rank-k update:

        C_i := alpha*op( A_i )*op( A_i )^H + beta*C_i,

        where  alpha and beta are scalars, op(A) is an n by k matrix, and
        C_i is a n x n Hermitian matrix stored as either upper or lower.

        op( A_i ) = A_i, and A_i is n by k if transA == rocblas_operation_none
        op( A_i ) = A_i^H and A_i is k by n if transA == rocblas_operation_conjugate_transpose

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.

    @param[in]
    uplo    [rocblas_fill]
            - rocblas_fill_upper:  C_i is an upper triangular matrix
            - rocblas_fill_lower:  C_i is a  lower triangular matrix

    @param[in]
    transA  [rocblas_operation]
            - rocblas_operation_conjugate_transpose: op(A) = A^H
            - rocblas_operation_none:                op(A) = A

    @param[in]
    n       [rocblas_int]
            n specifies the number of rows and columns of C_i. n >= 0.

    @param[in]
    k       [rocblas_int]
            k specifies the number of columns of op(A). k >= 0.

    @param[in]
    alpha
            alpha specifies the scalar alpha. When alpha is
            zero then A is not referenced and A need not be set before
            entry.

    @param[in]
    A       device array of device pointers storing each matrix_i A of dimension (lda, k)
            when transA is rocblas_operation_none, otherwise of dimension (lda, n).

    @param[in]
    lda     [rocblas_int]
            lda specifies the first dimension of A_i.

                if transA = rocblas_operation_none,  lda >= max( 1, n ),
                otherwise lda >= max( 1, k ).

    @param[in]
    beta
            beta specifies the scalar beta. When beta is
            zero then C need not be set before entry.

    @param[in]
    C       device array of device pointers storing each matrix C_i on the GPU.
            The imaginary component of the diagonal elements are not used but are set to zero unless quick return.
            only the upper/lower triangular part of each C_i is accessed.

    @param[in]
    ldc    [rocblas_int]
           ldc specifies the first dimension of C. ldc >= max( 1, n ).
    @param[in]
    batch_count [rocblas_int]
                number of instances in the batch.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_cherk_batched",
        fn (
            Handle,
            Fill,
            Operation,
            Int32,
            Int32,
            UnsafePointer[Float32],
            OpaquePointer,
            Int32,
            UnsafePointer[Float32],
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(handle, uplo, trans_a, n, k, alpha, _a, lda, beta, _c, ldc, batch_count)


fn rocblas_crot_batched(
    handle: Handle,
    n: Int32,
    x: OpaquePointer,
    incx: Int32,
    y: OpaquePointer,
    incy: Int32,
    c: UnsafePointer[Float32],
    s: UnsafePointer[ComplexFloat32],
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_crot_batched",
        fn (
            Handle,
            Int32,
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            UnsafePointer[Float32],
            UnsafePointer[ComplexFloat32],
            Int32,
        ) -> Status,
    ]()(handle, n, x, incx, y, incy, c, s, batch_count)


fn rocblas_zaxpy(
    handle: Handle,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat64],
    x: UnsafePointer[ComplexFloat64],
    incx: Int32,
    y: UnsafePointer[ComplexFloat64],
    incy: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_zaxpy",
        fn (
            Handle,
            Int32,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int32,
            UnsafePointer[ComplexFloat64],
            Int32,
        ) -> Status,
    ]()(handle, n, alpha, x, incx, y, incy)


fn rocblas_dnrm2_strided_batched_64(
    handle: Handle,
    n: Int64,
    x: UnsafePointer[Float64],
    incx: Int64,
    stridex: Int64,
    batch_count: Int64,
    results: UnsafePointer[Float64],
) -> Status:
    return _get_dylib_function[
        "rocblas_dnrm2_strided_batched_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[Float64],
            Int64,
            Int64,
            Int64,
            UnsafePointer[Float64],
        ) -> Status,
    ]()(handle, n, x, incx, stridex, batch_count, results)


fn rocblas_ssyr2_batched(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    alpha: UnsafePointer[Float32],
    x: OpaquePointer,
    incx: Int32,
    y: OpaquePointer,
    incy: Int32,
    _a: OpaquePointer,
    lda: Int32,
    batch_count: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 2 API </b>.

    \\details
    syr2_batched performs a batch of matrix-vector operations:

        A[i] := A[i] + alpha*x[i]*y[i]**T + alpha*y[i]*x[i]**T
        where alpha is a scalar, x[i] and y[i] are vectors, and A[i] is a
        n by n symmetric matrix, for i = 1 , ... , batch_count.

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    uplo      [rocblas_fill]
            specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
            - if rocblas_fill_upper, the lower part of A is not referenced
            - if rocblas_fill_lower, the upper part of A is not referenced
    @param[in]
    n         [rocblas_int]
              the number of rows and columns of matrix A.
    @param[in]
    alpha
              device pointer or host pointer to scalar alpha.
    @param[in]
    x         device array of device pointers storing each vector x_i.
    @param[in]
    incx      [rocblas_int]
              specifies the increment for the elements of each x_i.
    @param[in]
    y         device array of device pointers storing each vector y_i.
    @param[in]
    incy      [rocblas_int]
              specifies the increment for the elements of each y_i.
    @param[in, out]
    A         device array of device pointers storing each matrix A_i.
    @param[in]
    lda       [rocblas_int]
              specifies the leading dimension of each A_i.
    @param[in]
    batch_count [rocblas_int]
                number of instances in the batch.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_ssyr2_batched",
        fn (
            Handle,
            Fill,
            Int32,
            UnsafePointer[Float32],
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(handle, uplo, n, alpha, x, incx, y, incy, _a, lda, batch_count)


fn rocblas_nrm2_strided_batched_ex(
    handle: Handle,
    n: Int32,
    x: OpaquePointer,
    x_type: DataType,
    incx: Int32,
    stride_x: Int64,
    batch_count: Int32,
    results: OpaquePointer,
    result_type: DataType,
    execution_type: DataType,
) -> Status:
    """
    \\brief BLAS_EX API.

    \\details
    nrm2_strided_batched_ex computes the euclidean norm over a batch of real or complex vectors.

        result := sqrt( x_i'*x_i ) for real vectors x, for i = 1, ..., batch_count
        result := sqrt( x_i**H*x_i ) for complex vectors, for i = 1, ..., batch_count

    Currently supported datatypes are as follows:

    -------------------------------------
    |  x_type | result | execution_type |
    |---------|--------|----------------|
    |  bf16_r |  bf16_r|     f32_r      |
    |  f16_r  |  f16_r |     f32_r      |
    |  f32_r  |  f32_r |     f32_r      |
    |  f64_r  |  f64_r |     f64_r      |
    |  f32_c  |  f32_r |     f32_r      |
    |  f64_c  |  f64_r |     f64_r      |
    -------------------------------------

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    n         [rocblas_int]
              number of elements in each x_i.
    @param[in]
    x         device pointer to the first vector x_1.
    @param[in]
    x_type [rocblas_datatype]
           specifies the datatype of each vector x_i.
    @param[in]
    incx      [rocblas_int]
              specifies the increment for the elements of each x_i. incx must be > 0.
    @param[in]
    stride_x  [rocblas_stride]
              stride from the start of one vector (x_i) and the next one (x_i+1).
              There are no restrictions placed on stride_x. However, ensure that stride_x is of appropriate size. For a typical
              case this means stride_x >= n * incx.
    @param[in]
    batch_count [rocblas_int]
              number of instances in the batch.
    @param[out]
    results
              device pointer or host pointer to array for storing contiguous batch_count results.
              return is 0.0 for each element if n <= 0, incx<=0.
    @param[in]
    result_type [rocblas_datatype]
                specifies the datatype of the result.
    @param[in]
    execution_type [rocblas_datatype]
                  specifies the datatype of computation.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_nrm2_strided_batched_ex",
        fn (
            Handle,
            Int32,
            OpaquePointer,
            DataType,
            Int32,
            Int64,
            Int32,
            OpaquePointer,
            DataType,
            DataType,
        ) -> Status,
    ]()(
        handle,
        n,
        x,
        x_type,
        incx,
        stride_x,
        batch_count,
        results,
        result_type,
        execution_type,
    )


fn rocblas_cswap_64(
    handle: Handle,
    n: Int64,
    x: UnsafePointer[ComplexFloat32],
    incx: Int64,
    y: UnsafePointer[ComplexFloat32],
    incy: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_cswap_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int64,
            UnsafePointer[ComplexFloat32],
            Int64,
        ) -> Status,
    ]()(handle, n, x, incx, y, incy)


fn rocblas_csymv_batched(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat32],
    _a: OpaquePointer,
    lda: Int32,
    x: OpaquePointer,
    incx: Int32,
    beta: UnsafePointer[ComplexFloat32],
    y: OpaquePointer,
    incy: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_csymv_batched",
        fn (
            Handle,
            Fill,
            Int32,
            UnsafePointer[ComplexFloat32],
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            UnsafePointer[ComplexFloat32],
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(handle, uplo, n, alpha, _a, lda, x, incx, beta, y, incy, batch_count)


fn rocblas_nrm2_ex_64(
    handle: Handle,
    n: Int64,
    x: OpaquePointer,
    x_type: DataType,
    incx: Int64,
    results: OpaquePointer,
    result_type: DataType,
    execution_type: DataType,
) -> Status:
    return _get_dylib_function[
        "rocblas_nrm2_ex_64",
        fn (
            Handle,
            Int64,
            OpaquePointer,
            DataType,
            Int64,
            OpaquePointer,
            DataType,
            DataType,
        ) -> Status,
    ]()(handle, n, x, x_type, incx, results, result_type, execution_type)


fn rocblas_scal_batched_ex(
    handle: Handle,
    n: Int32,
    alpha: OpaquePointer,
    alpha_type: DataType,
    x: OpaquePointer,
    x_type: DataType,
    incx: Int32,
    batch_count: Int32,
    execution_type: DataType,
) -> Status:
    """
    \\brief <b> BLAS EX API </b>.

    \\details
    scal_batched_ex  scales each element of each vector x_i with scalar alpha.

        x_i := alpha * x_i

    Currently supported datatypes are as follows:

    ----------------------------------------
    | alpha_type | x_type | execution_type |
    |------------|--------|----------------|
    |  f32_r     | bf16_r |     f32_r      |
    |  bf16_r    | bf16_r |     f32_r      |
    |  f16_r     | f16_r  |     f16_r      |
    |  f16_r     | f16_r  |     f32_r      |
    |  f32_r     | f16_r  |     f32_r      |
    |  f32_r     | f32_r  |     f32_r      |
    |  f64_r     | f64_r  |     f64_r      |
    |  f32_c     | f32_c  |     f32_c      |
    |  f64_c     | f64_c  |     f64_c      |
    |  f32_r     | f32_c  |     f32_c      |
    |  f64_r     | f64_c  |     f64_c      |
    ----------------------------------------

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    n         [rocblas_int]
              the number of elements in x.
    @param[in]
    alpha     device pointer or host pointer for the scalar alpha.
    @param[in]
    alpha_type [rocblas_datatype]
               specifies the datatype of alpha.
    @param[in, out]
    x         device array of device pointers storing each vector x_i.
    @param[in]
    x_type [rocblas_datatype]
           specifies the datatype of each vector x_i.
    @param[in]
    incx      [rocblas_int]
              specifies the increment for the elements of each x_i.
    @param[in]
    batch_count [rocblas_int]
                number of instances in the batch.
    @param[in]
    execution_type [rocblas_datatype]
                   specifies the datatype of computation.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_scal_batched_ex",
        fn (
            Handle,
            Int32,
            OpaquePointer,
            DataType,
            OpaquePointer,
            DataType,
            Int32,
            Int32,
            DataType,
        ) -> Status,
    ]()(
        handle,
        n,
        alpha,
        alpha_type,
        x,
        x_type,
        incx,
        batch_count,
        execution_type,
    )


fn rocblas_zdotu_strided_batched_64(
    handle: Handle,
    n: Int64,
    x: UnsafePointer[ComplexFloat64],
    incx: Int64,
    stridex: Int64,
    y: UnsafePointer[ComplexFloat64],
    incy: Int64,
    stridey: Int64,
    batch_count: Int64,
    result: UnsafePointer[ComplexFloat64],
) -> Status:
    return _get_dylib_function[
        "rocblas_zdotu_strided_batched_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int64,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int64,
            Int64,
            Int64,
            UnsafePointer[ComplexFloat64],
        ) -> Status,
    ]()(handle, n, x, incx, stridex, y, incy, stridey, batch_count, result)


fn rocblas_scopy_64(
    handle: Handle,
    n: Int64,
    x: UnsafePointer[Float32],
    incx: Int64,
    y: UnsafePointer[Float32],
    incy: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_scopy_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[Float32],
            Int64,
            UnsafePointer[Float32],
            Int64,
        ) -> Status,
    ]()(handle, n, x, incx, y, incy)


fn rocblas_idamin_strided_batched_64(
    handle: Handle,
    n: Int64,
    x: UnsafePointer[Float64],
    incx: Int64,
    stridex: Int64,
    batch_count: Int64,
    result: UnsafePointer[Int64],
) -> Status:
    return _get_dylib_function[
        "rocblas_idamin_strided_batched_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[Float64],
            Int64,
            Int64,
            Int64,
            UnsafePointer[Int64],
        ) -> Status,
    ]()(handle, n, x, incx, stridex, batch_count, result)


fn rocblas_haxpy_64(
    handle: Handle,
    n: Int64,
    alpha: UnsafePointer[Float16],
    x: UnsafePointer[Float16],
    incx: Int64,
    y: UnsafePointer[Float16],
    incy: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_haxpy_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[Float16],
            UnsafePointer[Float16],
            Int64,
            UnsafePointer[Float16],
            Int64,
        ) -> Status,
    ]()(handle, n, alpha, x, incx, y, incy)


fn rocblas_nrm2_ex(
    handle: Handle,
    n: Int32,
    x: OpaquePointer,
    x_type: DataType,
    incx: Int32,
    results: OpaquePointer,
    result_type: DataType,
    execution_type: DataType,
) -> Status:
    """
    \\brief BLAS_EX API.

    \\details
    nrm2_ex computes the euclidean norm of a real or complex vector.

              result := sqrt( x'*x ) for real vectors
              result := sqrt( x**H*x ) for complex vectors

    Currently supported datatypes are as follows:

    -------------------------------------
    |  x_type | result | execution_type |
    |---------|--------|----------------|
    |  bf16_r |  bf16_r|     f32_r      |
    |  f16_r  |  f16_r |     f32_r      |
    |  f32_r  |  f32_r |     f32_r      |
    |  f64_r  |  f64_r |     f64_r      |
    |  f32_c  |  f32_r |     f32_r      |
    |  f64_c  |  f64_r |     f64_r      |
    -------------------------------------

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    n         [rocblas_int]
              the number of elements in x.
    @param[in]
    x         device pointer storing vector x.
    @param[in]
    x_type [rocblas_datatype]
           specifies the datatype of the vector x.
    @param[in]
    incx      [rocblas_int]
              specifies the increment for the elements of y.
    @param[in, out]
    results
              device pointer or host pointer to store the nrm2 product.
              return is 0.0 if n, incx<=0.
    @param[in]
    result_type [rocblas_datatype]
                specifies the datatype of the result.
    @param[in]
    execution_type [rocblas_datatype]
                  specifies the datatype of computation.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_nrm2_ex",
        fn (
            Handle,
            Int32,
            OpaquePointer,
            DataType,
            Int32,
            OpaquePointer,
            DataType,
            DataType,
        ) -> Status,
    ]()(handle, n, x, x_type, incx, results, result_type, execution_type)


fn rocblas_ztrmm_batched(
    handle: Handle,
    side: Side,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    m: Int32,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat64],
    _a: OpaquePointer,
    lda: Int32,
    _b: OpaquePointer,
    ldb: Int32,
    _c: OpaquePointer,
    ldc: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_ztrmm_batched",
        fn (
            Handle,
            Side,
            Fill,
            Operation,
            Diagonal,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat64],
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(
        handle,
        side,
        uplo,
        trans_a,
        diag,
        m,
        n,
        alpha,
        _a,
        lda,
        _b,
        ldb,
        _c,
        ldc,
        batch_count,
    )


fn rocblas_sspr_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    alpha: UnsafePointer[Float32],
    x: UnsafePointer[Float32],
    incx: Int64,
    _ap: UnsafePointer[Float32],
) -> Status:
    return _get_dylib_function[
        "rocblas_sspr_64",
        fn (
            Handle,
            Fill,
            Int64,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int64,
            UnsafePointer[Float32],
        ) -> Status,
    ]()(handle, uplo, n, alpha, x, incx, _ap)


fn rocblas_zhpr_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    alpha: UnsafePointer[Float64],
    x: UnsafePointer[ComplexFloat64],
    incx: Int64,
    _ap: UnsafePointer[ComplexFloat64],
) -> Status:
    return _get_dylib_function[
        "rocblas_zhpr_64",
        fn (
            Handle,
            Fill,
            Int64,
            UnsafePointer[Float64],
            UnsafePointer[ComplexFloat64],
            Int64,
            UnsafePointer[ComplexFloat64],
        ) -> Status,
    ]()(handle, uplo, n, alpha, x, incx, _ap)


fn rocblas_dsymv_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    alpha: UnsafePointer[Float64],
    _a: UnsafePointer[Float64],
    lda: Int64,
    x: UnsafePointer[Float64],
    incx: Int64,
    beta: UnsafePointer[Float64],
    y: UnsafePointer[Float64],
    incy: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_dsymv_64",
        fn (
            Handle,
            Fill,
            Int64,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int64,
            UnsafePointer[Float64],
            Int64,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int64,
        ) -> Status,
    ]()(handle, uplo, n, alpha, _a, lda, x, incx, beta, y, incy)


fn rocblas_cgeam_batched(
    handle: Handle,
    trans_a: Operation,
    trans_b: Operation,
    m: Int32,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat32],
    _a: OpaquePointer,
    lda: Int32,
    beta: UnsafePointer[ComplexFloat32],
    _b: OpaquePointer,
    ldb: Int32,
    _c: OpaquePointer,
    ldc: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_cgeam_batched",
        fn (
            Handle,
            Operation,
            Operation,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat32],
            OpaquePointer,
            Int32,
            UnsafePointer[ComplexFloat32],
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(
        handle,
        trans_a,
        trans_b,
        m,
        n,
        alpha,
        _a,
        lda,
        beta,
        _b,
        ldb,
        _c,
        ldc,
        batch_count,
    )


fn rocblas_sspr2(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    alpha: UnsafePointer[Float32],
    x: UnsafePointer[Float32],
    incx: Int32,
    y: UnsafePointer[Float32],
    incy: Int32,
    _ap: UnsafePointer[Float32],
) -> Status:
    """
    \\brief <b> BLAS Level 2 API </b>.

    \\details
    spr2 performs the matrix-vector operation:

        A := A + alpha*x*y**T + alpha*y*x**T
        where alpha is a scalar, x and y are vectors, and A is an
        n by n symmetric matrix, supplied in packed form.

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    uplo      [rocblas_fill]
            specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
            - rocblas_fill_upper: The upper triangular part of A is supplied in AP.
            - rocblas_fill_lower: The lower triangular part of A is supplied in AP.
    @param[in]
    n         [rocblas_int]
            the number of rows and columns of matrix A. Must be at least 0.
    @param[in]
    alpha
              device pointer or host pointer to scalar alpha.
    @param[in]
    x         device pointer storing vector x.
    @param[in]
    incx      [rocblas_int]
              specifies the increment for the elements of x.
    @param[in]
    y         device pointer storing vector y.
    @param[in]
    incy      [rocblas_int]
              specifies the increment for the elements of y.
    @param[in, out]
    AP        device pointer storing the packed version of the specified triangular portion of
              the symmetric matrix A. Of at least size ((n * (n + 1)) / 2).

                    if uplo == rocblas_fill_upper:
                        The upper triangular portion of the symmetric matrix A is supplied.
                        The matrix is compacted so that AP contains the triangular portion
                        column-by-column
                        so that:
                        AP(0) = A(0,0)
                        AP(1) = A(0,1)
                        AP(2) = A(1,1), etc.
                            Ex: (rocblas_fill_upper; n = 4)
                                1 2 4 7
                                2 3 5 8   -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
                                4 5 6 9
                                7 8 9 0

                    if uplo == rocblas_fill_lower:
                        The lower triangular portion of the symmetric matrix A is supplied.
                        The matrix is compacted so that AP contains the triangular portion
                        column-by-column
                        so that:
                        AP(0) = A(0,0)
                        AP(1) = A(1,0)
                        AP(n) = A(2,1), etc.
                            Ex: (rocblas_fill_lower; n = 4)
                                1 2 3 4
                                2 5 6 7    -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
                                3 6 8 9
                                4 7 9 0
    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_sspr2",
        fn (
            Handle,
            Fill,
            Int32,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int32,
            UnsafePointer[Float32],
            Int32,
            UnsafePointer[Float32],
        ) -> Status,
    ]()(handle, uplo, n, alpha, x, incx, y, incy, _ap)


fn rocblas_zsyr2_batched_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    alpha: UnsafePointer[ComplexFloat64],
    x: OpaquePointer,
    incx: Int64,
    y: OpaquePointer,
    incy: Int64,
    _a: OpaquePointer,
    lda: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_zsyr2_batched_64",
        fn (
            Handle,
            Fill,
            Int64,
            UnsafePointer[ComplexFloat64],
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, uplo, n, alpha, x, incx, y, incy, _a, lda, batch_count)


fn rocblas_ctrtri_batched(
    handle: Handle,
    uplo: Fill,
    diag: Diagonal,
    n: Int32,
    _a: OpaquePointer,
    lda: Int32,
    inv_a: OpaquePointer,
    ldinv_a: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_ctrtri_batched",
        fn (
            Handle,
            Fill,
            Diagonal,
            Int32,
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(handle, uplo, diag, n, _a, lda, inv_a, ldinv_a, batch_count)


fn rocblas_cher_batched_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    alpha: UnsafePointer[Float32],
    x: OpaquePointer,
    incx: Int64,
    _a: OpaquePointer,
    lda: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_cher_batched_64",
        fn (
            Handle,
            Fill,
            Int64,
            UnsafePointer[Float32],
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, uplo, n, alpha, x, incx, _a, lda, batch_count)


fn rocblas_get_device_memory_size(
    handle: Handle, size: UnsafePointer[Int]
) -> Status:
    """\\brief
    \\details
    Gets the current device memory size for the handle.
    Returns rocblas_status_invalid_handle if handle is nullptr; rocblas_status_invalid_pointer if size is nullptr; rocblas_status_success otherwise
    @param[in]
    handle          rocblas handle
    @param[out]
    size            current device memory size for the handle
    ****************************************************************************.
    """
    return _get_dylib_function[
        "rocblas_get_device_memory_size",
        fn (Handle, UnsafePointer[Int]) -> Status,
    ]()(handle, size)


fn rocblas_dger_batched_64(
    handle: Handle,
    m: Int64,
    n: Int64,
    alpha: UnsafePointer[Float64],
    x: OpaquePointer,
    incx: Int64,
    y: OpaquePointer,
    incy: Int64,
    _a: OpaquePointer,
    lda: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_dger_batched_64",
        fn (
            Handle,
            Int64,
            Int64,
            UnsafePointer[Float64],
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, m, n, alpha, x, incx, y, incy, _a, lda, batch_count)


fn rocblas_zhpr2_strided_batched(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat64],
    x: UnsafePointer[ComplexFloat64],
    incx: Int32,
    stride_x: Int64,
    y: UnsafePointer[ComplexFloat64],
    incy: Int32,
    stride_y: Int64,
    _ap: UnsafePointer[ComplexFloat64],
    stride__a: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_zhpr2_strided_batched",
        fn (
            Handle,
            Fill,
            Int32,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        uplo,
        n,
        alpha,
        x,
        incx,
        stride_x,
        y,
        incy,
        stride_y,
        _ap,
        stride__a,
        batch_count,
    )


fn rocblas_zspr_batched(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat64],
    x: OpaquePointer,
    incx: Int32,
    _ap: OpaquePointer,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_zspr_batched",
        fn (
            Handle,
            Fill,
            Int32,
            UnsafePointer[ComplexFloat64],
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
        ) -> Status,
    ]()(handle, uplo, n, alpha, x, incx, _ap, batch_count)


fn rocblas_csymv(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat32],
    _a: UnsafePointer[ComplexFloat32],
    lda: Int32,
    x: UnsafePointer[ComplexFloat32],
    incx: Int32,
    beta: UnsafePointer[ComplexFloat32],
    y: UnsafePointer[ComplexFloat32],
    incy: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_csymv",
        fn (
            Handle,
            Fill,
            Int32,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int32,
            UnsafePointer[ComplexFloat32],
            Int32,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int32,
        ) -> Status,
    ]()(handle, uplo, n, alpha, _a, lda, x, incx, beta, y, incy)


fn rocblas_dscal_batched(
    handle: Handle,
    n: Int32,
    alpha: UnsafePointer[Float64],
    x: OpaquePointer,
    incx: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_dscal_batched",
        fn (
            Handle,
            Int32,
            UnsafePointer[Float64],
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(handle, n, alpha, x, incx, batch_count)


fn rocblas_cgemv_strided_batched_64(
    handle: Handle,
    trans_a: Operation,
    m: Int64,
    n: Int64,
    alpha: UnsafePointer[ComplexFloat32],
    _a: UnsafePointer[ComplexFloat32],
    lda: Int64,
    stride_a: Int64,
    x: UnsafePointer[ComplexFloat32],
    incx: Int64,
    stridex: Int64,
    beta: UnsafePointer[ComplexFloat32],
    y: UnsafePointer[ComplexFloat32],
    incy: Int64,
    stridey: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_cgemv_strided_batched_64",
        fn (
            Handle,
            Operation,
            Int64,
            Int64,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int64,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int64,
            Int64,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int64,
            Int64,
            Int64,
        ) -> Status,
    ]()(
        handle,
        trans_a,
        m,
        n,
        alpha,
        _a,
        lda,
        stride_a,
        x,
        incx,
        stridex,
        beta,
        y,
        incy,
        stridey,
        batch_count,
    )


fn rocblas_stbsv_64(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int64,
    k: Int64,
    _a: UnsafePointer[Float32],
    lda: Int64,
    x: UnsafePointer[Float32],
    incx: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_stbsv_64",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int64,
            Int64,
            UnsafePointer[Float32],
            Int64,
            UnsafePointer[Float32],
            Int64,
        ) -> Status,
    ]()(handle, uplo, trans_a, diag, n, k, _a, lda, x, incx)


fn rocblas_zhemm_strided_batched(
    handle: Handle,
    side: Side,
    uplo: Fill,
    m: Int32,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat64],
    _a: UnsafePointer[ComplexFloat64],
    lda: Int32,
    stride__a: Int64,
    _b: UnsafePointer[ComplexFloat64],
    ldb: Int32,
    stride__b: Int64,
    beta: UnsafePointer[ComplexFloat64],
    _c: UnsafePointer[ComplexFloat64],
    ldc: Int32,
    stride__c: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_zhemm_strided_batched",
        fn (
            Handle,
            Side,
            Fill,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        side,
        uplo,
        m,
        n,
        alpha,
        _a,
        lda,
        stride__a,
        _b,
        ldb,
        stride__b,
        beta,
        _c,
        ldc,
        stride__c,
        batch_count,
    )


fn rocblas_dnrm2_batched_64(
    handle: Handle,
    n: Int64,
    x: OpaquePointer,
    incx: Int64,
    batch_count: Int64,
    results: UnsafePointer[Float64],
) -> Status:
    return _get_dylib_function[
        "rocblas_dnrm2_batched_64",
        fn (
            Handle,
            Int64,
            OpaquePointer,
            Int64,
            Int64,
            UnsafePointer[Float64],
        ) -> Status,
    ]()(handle, n, x, incx, batch_count, results)


fn rocblas_zgeru(
    handle: Handle,
    m: Int32,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat64],
    x: UnsafePointer[ComplexFloat64],
    incx: Int32,
    y: UnsafePointer[ComplexFloat64],
    incy: Int32,
    _a: UnsafePointer[ComplexFloat64],
    lda: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_zgeru",
        fn (
            Handle,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int32,
            UnsafePointer[ComplexFloat64],
            Int32,
            UnsafePointer[ComplexFloat64],
            Int32,
        ) -> Status,
    ]()(handle, m, n, alpha, x, incx, y, incy, _a, lda)


fn rocblas_zcopy(
    handle: Handle,
    n: Int32,
    x: UnsafePointer[ComplexFloat64],
    incx: Int32,
    y: UnsafePointer[ComplexFloat64],
    incy: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_zcopy",
        fn (
            Handle,
            Int32,
            UnsafePointer[ComplexFloat64],
            Int32,
            UnsafePointer[ComplexFloat64],
            Int32,
        ) -> Status,
    ]()(handle, n, x, incx, y, incy)


fn rocblas_ssyrkx(
    handle: Handle,
    uplo: Fill,
    trans: Operation,
    n: Int32,
    k: Int32,
    alpha: UnsafePointer[Float32],
    _a: UnsafePointer[Float32],
    lda: Int32,
    _b: UnsafePointer[Float32],
    ldb: Int32,
    beta: UnsafePointer[Float32],
    _c: UnsafePointer[Float32],
    ldc: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 3 API </b>.

    \\details
    syrkx performs one of the matrix-matrix operations for a symmetric rank-k update:

        C := alpha*op( A )*op( B )^T + beta*C,

        where  alpha and beta are scalars, op(A) and op(B) are n by k matrix, and
        C is a symmetric n x n matrix stored as either upper or lower.

    This routine should only be used when the caller can guarantee that the result of op( A )*op( B )^T will be symmetric.

        op( A ) = A, op( B ) = B, and A and B are n by k if trans == rocblas_operation_none
        op( A ) = A^T, op( B ) = B^T,  and A and B are k by n if trans == rocblas_operation_transpose
        or for ssyrkx and dsyrkx when trans == rocblas_operation_conjugate_transpose

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.

    @param[in]
    uplo    [rocblas_fill]
            - rocblas_fill_upper:  C is an upper triangular matrix
            - rocblas_fill_lower:  C is a  lower triangular matrix

    @param[in]
    trans  [rocblas_operation]
            - rocblas_operation_transpose:           op( A ) = A^T, op( B ) = B^T
            - rocblas_operation_none:                op( A ) = A, op( B ) = B
            - rocblas_operation_conjugate_transpose: op( A ) = A^T, op( B ) = B^T

            rocblas_operation_conjugate_transpose is not supported for complex types in csyrkx and zsyrkx.

    @param[in]
    n       [rocblas_int]
            n specifies the number of rows and columns of C. n >= 0.

    @param[in]
    k       [rocblas_int]
            k specifies the number of columns of op(A) and op(B). k >= 0.

    @param[in]
    alpha
            alpha specifies the scalar alpha. When alpha is
            zero then A is not referenced and A need not be set before
            entry.

    @param[in]
    A       pointer storing matrix A on the GPU.
            Matrix dimension is ( lda, k ) when if trans = rocblas_operation_none, otherwise (lda, n)

    @param[in]
    lda     [rocblas_int]
            lda specifies the first dimension of A.

                if trans = rocblas_operation_none,  lda >= max( 1, n ),
                otherwise lda >= max( 1, k ).

    @param[in]
    B       pointer storing matrix B on the GPU.
            Matrix dimension is ( ldb, k ) when if trans = rocblas_operation_none, otherwise (ldb, n)

    @param[in]
    ldb     [rocblas_int]
            ldb specifies the first dimension of B.

                if trans = rocblas_operation_none,  ldb >= max( 1, n ),
                otherwise ldb >= max( 1, k ).

    @param[in]
    beta
            beta specifies the scalar beta. When beta is
            zero then C need not be set before entry.

    @param[in]
    C       pointer storing matrix C on the GPU.
            only the upper/lower triangular part is accessed.

    @param[in]
    ldc    [rocblas_int]
           ldc specifies the first dimension of C. ldc >= max( 1, n ).

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_ssyrkx",
        fn (
            Handle,
            Fill,
            Operation,
            Int32,
            Int32,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int32,
            UnsafePointer[Float32],
            Int32,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int32,
        ) -> Status,
    ]()(handle, uplo, trans, n, k, alpha, _a, lda, _b, ldb, beta, _c, ldc)


fn rocblas_zdotu_batched(
    handle: Handle,
    n: Int32,
    x: OpaquePointer,
    incx: Int32,
    y: OpaquePointer,
    incy: Int32,
    batch_count: Int32,
    result: UnsafePointer[ComplexFloat64],
) -> Status:
    return _get_dylib_function[
        "rocblas_zdotu_batched",
        fn (
            Handle,
            Int32,
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat64],
        ) -> Status,
    ]()(handle, n, x, incx, y, incy, batch_count, result)


fn rocblas_ctpsv_strided_batched(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int32,
    _ap: UnsafePointer[ComplexFloat32],
    stride__a: Int64,
    x: UnsafePointer[ComplexFloat32],
    incx: Int32,
    stride_x: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_ctpsv_strided_batched",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int32,
            UnsafePointer[ComplexFloat32],
            Int64,
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        uplo,
        trans_a,
        diag,
        n,
        _ap,
        stride__a,
        x,
        incx,
        stride_x,
        batch_count,
    )


fn rocblas_zher_strided_batched(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    alpha: UnsafePointer[Float64],
    x: UnsafePointer[ComplexFloat64],
    incx: Int32,
    stride_x: Int64,
    _a: UnsafePointer[ComplexFloat64],
    lda: Int32,
    stride__a: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_zher_strided_batched",
        fn (
            Handle,
            Fill,
            Int32,
            UnsafePointer[Float64],
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        uplo,
        n,
        alpha,
        x,
        incx,
        stride_x,
        _a,
        lda,
        stride__a,
        batch_count,
    )


fn rocblas_srotm_batched_64(
    handle: Handle,
    n: Int64,
    x: OpaquePointer,
    incx: Int64,
    y: OpaquePointer,
    incy: Int64,
    param: OpaquePointer,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_srotm_batched_64",
        fn (
            Handle,
            Int64,
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
        ) -> Status,
    ]()(handle, n, x, incx, y, incy, param, batch_count)


fn rocblas_tssgemv_strided_batched(
    handle: Handle,
    trans_a: Operation,
    m: Int32,
    n: Int32,
    alpha: UnsafePointer[Float32],
    _a: UnsafePointer[BFloat16],
    lda: Int32,
    stride_a: Int64,
    x: UnsafePointer[BFloat16],
    incx: Int32,
    stridex: Int64,
    beta: UnsafePointer[Float32],
    y: UnsafePointer[Float32],
    incy: Int32,
    stridey: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_tssgemv_strided_batched",
        fn (
            Handle,
            Operation,
            Int32,
            Int32,
            UnsafePointer[Float32],
            UnsafePointer[BFloat16],
            Int32,
            Int64,
            UnsafePointer[BFloat16],
            Int32,
            Int64,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        trans_a,
        m,
        n,
        alpha,
        _a,
        lda,
        stride_a,
        x,
        incx,
        stridex,
        beta,
        y,
        incy,
        stridey,
        batch_count,
    )


fn rocblas_isamax_strided_batched_64(
    handle: Handle,
    n: Int64,
    x: UnsafePointer[Float32],
    incx: Int64,
    stridex: Int64,
    batch_count: Int64,
    result: UnsafePointer[Int64],
) -> Status:
    return _get_dylib_function[
        "rocblas_isamax_strided_batched_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[Float32],
            Int64,
            Int64,
            Int64,
            UnsafePointer[Int64],
        ) -> Status,
    ]()(handle, n, x, incx, stridex, batch_count, result)


fn rocblas_drotg_strided_batched_64(
    handle: Handle,
    a: UnsafePointer[Float64],
    stride_a: Int64,
    b: UnsafePointer[Float64],
    stride_b: Int64,
    c: UnsafePointer[Float64],
    stride_c: Int64,
    s: UnsafePointer[Float64],
    stride_s: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_drotg_strided_batched_64",
        fn (
            Handle,
            UnsafePointer[Float64],
            Int64,
            UnsafePointer[Float64],
            Int64,
            UnsafePointer[Float64],
            Int64,
            UnsafePointer[Float64],
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, a, stride_a, b, stride_b, c, stride_c, s, stride_s, batch_count)


fn rocblas_scnrm2_batched_64(
    handle: Handle,
    n: Int64,
    x: OpaquePointer,
    incx: Int64,
    batch_count: Int64,
    results: UnsafePointer[Float32],
) -> Status:
    return _get_dylib_function[
        "rocblas_scnrm2_batched_64",
        fn (
            Handle,
            Int64,
            OpaquePointer,
            Int64,
            Int64,
            UnsafePointer[Float32],
        ) -> Status,
    ]()(handle, n, x, incx, batch_count, results)


fn rocblas_zdrot_strided_batched_64(
    handle: Handle,
    n: Int64,
    x: UnsafePointer[ComplexFloat64],
    incx: Int64,
    stride_x: Int64,
    y: UnsafePointer[ComplexFloat64],
    incy: Int64,
    stride_y: Int64,
    c: UnsafePointer[Float64],
    s: UnsafePointer[Float64],
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_zdrot_strided_batched_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int64,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int64,
            Int64,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int64,
        ) -> Status,
    ]()(handle, n, x, incx, stride_x, y, incy, stride_y, c, s, batch_count)


fn rocblas_ctbmv_batched(
    handle: Handle,
    uplo: Fill,
    trans: Operation,
    diag: Diagonal,
    n: Int32,
    k: Int32,
    _a: OpaquePointer,
    lda: Int32,
    x: OpaquePointer,
    incx: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_ctbmv_batched",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int32,
            Int32,
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(handle, uplo, trans, diag, n, k, _a, lda, x, incx, batch_count)


fn rocblas_bfdot_strided_batched(
    handle: Handle,
    n: Int32,
    x: UnsafePointer[BFloat16],
    incx: Int32,
    stridex: Int64,
    y: UnsafePointer[BFloat16],
    incy: Int32,
    stridey: Int64,
    batch_count: Int32,
    result: UnsafePointer[BFloat16],
) -> Status:
    return _get_dylib_function[
        "rocblas_bfdot_strided_batched",
        fn (
            Handle,
            Int32,
            UnsafePointer[BFloat16],
            Int32,
            Int64,
            UnsafePointer[BFloat16],
            Int32,
            Int64,
            Int32,
            UnsafePointer[BFloat16],
        ) -> Status,
    ]()(handle, n, x, incx, stridex, y, incy, stridey, batch_count, result)


fn rocblas_zgemv_batched(
    handle: Handle,
    trans: Operation,
    m: Int32,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat64],
    _a: OpaquePointer,
    lda: Int32,
    x: OpaquePointer,
    incx: Int32,
    beta: UnsafePointer[ComplexFloat64],
    y: OpaquePointer,
    incy: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_zgemv_batched",
        fn (
            Handle,
            Operation,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat64],
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            UnsafePointer[ComplexFloat64],
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(
        handle, trans, m, n, alpha, _a, lda, x, incx, beta, y, incy, batch_count
    )


fn rocblas_stpmv_64(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int64,
    _a: UnsafePointer[Float32],
    x: UnsafePointer[Float32],
    incx: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_stpmv_64",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int64,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int64,
        ) -> Status,
    ]()(handle, uplo, trans_a, diag, n, _a, x, incx)


fn rocblas_srotg_batched(
    handle: Handle,
    a: OpaquePointer,
    b: OpaquePointer,
    c: OpaquePointer,
    s: OpaquePointer,
    batch_count: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 1 API </b>.

    \\details
    rotg_batched creates the Givens rotation matrix for the batched vectors (a_i b_i), for i = 1, ..., batch_count.
    a, b, c, and s are host pointers to an array of device pointers on the device, where each device pointer points
    to a scalar value of a_i, b_i, c_i, or s_i.

    @param[in]
    handle  [rocblas_handle]
            handle to the rocblas library context queue.
    @param[in, out]
    a       a, overwritten with r.
    @param[in, out]
    b       b overwritten with z.
    @param[out]
    c       cosine element of Givens rotation for the batch.
    @param[out]
    s       sine element of Givens rotation for the batch.
    @param[in]
    batch_count [rocblas_int]
                number of batches (length of arrays a, b, c, and s).

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_srotg_batched",
        fn (
            Handle,
            OpaquePointer,
            OpaquePointer,
            OpaquePointer,
            OpaquePointer,
            Int32,
        ) -> Status,
    ]()(handle, a, b, c, s, batch_count)


fn rocblas_dznrm2(
    handle: Handle,
    n: Int32,
    x: UnsafePointer[ComplexFloat64],
    incx: Int32,
    result: UnsafePointer[Float64],
) -> Status:
    return _get_dylib_function[
        "rocblas_dznrm2",
        fn (
            Handle,
            Int32,
            UnsafePointer[ComplexFloat64],
            Int32,
            UnsafePointer[Float64],
        ) -> Status,
    ]()(handle, n, x, incx, result)


fn rocblas_ctbmv_strided_batched_64(
    handle: Handle,
    uplo: Fill,
    trans: Operation,
    diag: Diagonal,
    n: Int64,
    k: Int64,
    _a: UnsafePointer[ComplexFloat32],
    lda: Int64,
    stride__a: Int64,
    x: UnsafePointer[ComplexFloat32],
    incx: Int64,
    stride_x: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_ctbmv_strided_batched_64",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int64,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int64,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int64,
            Int64,
            Int64,
        ) -> Status,
    ]()(
        handle,
        uplo,
        trans,
        diag,
        n,
        k,
        _a,
        lda,
        stride__a,
        x,
        incx,
        stride_x,
        batch_count,
    )


fn rocblas_ztbsv_strided_batched(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int32,
    k: Int32,
    _a: UnsafePointer[ComplexFloat64],
    lda: Int32,
    stride__a: Int64,
    x: UnsafePointer[ComplexFloat64],
    incx: Int32,
    stride_x: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_ztbsv_strided_batched",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        uplo,
        trans_a,
        diag,
        n,
        k,
        _a,
        lda,
        stride__a,
        x,
        incx,
        stride_x,
        batch_count,
    )


fn rocblas_zhpmv_batched(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat64],
    _ap: OpaquePointer,
    x: OpaquePointer,
    incx: Int32,
    beta: UnsafePointer[ComplexFloat64],
    y: OpaquePointer,
    incy: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_zhpmv_batched",
        fn (
            Handle,
            Fill,
            Int32,
            UnsafePointer[ComplexFloat64],
            OpaquePointer,
            OpaquePointer,
            Int32,
            UnsafePointer[ComplexFloat64],
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(handle, uplo, n, alpha, _ap, x, incx, beta, y, incy, batch_count)


fn rocblas_dtrmv_batched(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int32,
    _a: UnsafePointer[UnsafePointer[Float64]],
    lda: Int32,
    x: UnsafePointer[UnsafePointer[Float64]],
    incx: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_dtrmv_batched",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int32,
            UnsafePointer[UnsafePointer[Float64]],
            Int32,
            UnsafePointer[UnsafePointer[Float64]],
            Int32,
            Int32,
        ) -> Status,
    ]()(handle, uplo, trans_a, diag, n, _a, lda, x, incx, batch_count)


fn rocblas_dtpsv_strided_batched(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int32,
    _ap: UnsafePointer[Float64],
    stride__a: Int64,
    x: UnsafePointer[Float64],
    incx: Int32,
    stride_x: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_dtpsv_strided_batched",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int32,
            UnsafePointer[Float64],
            Int64,
            UnsafePointer[Float64],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        uplo,
        trans_a,
        diag,
        n,
        _ap,
        stride__a,
        x,
        incx,
        stride_x,
        batch_count,
    )


fn rocblas_zsymv_strided_batched(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat64],
    _a: UnsafePointer[ComplexFloat64],
    lda: Int32,
    stride_a: Int64,
    x: UnsafePointer[ComplexFloat64],
    incx: Int32,
    stridex: Int64,
    beta: UnsafePointer[ComplexFloat64],
    y: UnsafePointer[ComplexFloat64],
    incy: Int32,
    stridey: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_zsymv_strided_batched",
        fn (
            Handle,
            Fill,
            Int32,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat64],
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        uplo,
        n,
        alpha,
        _a,
        lda,
        stride_a,
        x,
        incx,
        stridex,
        beta,
        y,
        incy,
        stridey,
        batch_count,
    )


fn rocblas_strsv_batched_64(
    handle: Handle,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    n: Int64,
    _a: OpaquePointer,
    lda: Int64,
    x: OpaquePointer,
    incx: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_strsv_batched_64",
        fn (
            Handle,
            Fill,
            Operation,
            Diagonal,
            Int64,
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, uplo, trans_a, diag, n, _a, lda, x, incx, batch_count)


fn rocblas_dsyrkx_strided_batched(
    handle: Handle,
    uplo: Fill,
    trans: Operation,
    n: Int32,
    k: Int32,
    alpha: UnsafePointer[Float64],
    _a: UnsafePointer[Float64],
    lda: Int32,
    stride__a: Int64,
    _b: UnsafePointer[Float64],
    ldb: Int32,
    stride__b: Int64,
    beta: UnsafePointer[Float64],
    _c: UnsafePointer[Float64],
    ldc: Int32,
    stride__c: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_dsyrkx_strided_batched",
        fn (
            Handle,
            Fill,
            Operation,
            Int32,
            Int32,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int32,
            Int64,
            UnsafePointer[Float64],
            Int32,
            Int64,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        uplo,
        trans,
        n,
        k,
        alpha,
        _a,
        lda,
        stride__a,
        _b,
        ldb,
        stride__b,
        beta,
        _c,
        ldc,
        stride__c,
        batch_count,
    )


fn rocblas_haxpy_strided_batched_64(
    handle: Handle,
    n: Int64,
    alpha: UnsafePointer[Float16],
    x: UnsafePointer[Float16],
    incx: Int64,
    stridex: Int64,
    y: UnsafePointer[Float16],
    incy: Int64,
    stridey: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_haxpy_strided_batched_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[Float16],
            UnsafePointer[Float16],
            Int64,
            Int64,
            UnsafePointer[Float16],
            Int64,
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, n, alpha, x, incx, stridex, y, incy, stridey, batch_count)


fn rocblas_zrotg_strided_batched(
    handle: Handle,
    a: UnsafePointer[ComplexFloat64],
    stride_a: Int64,
    b: UnsafePointer[ComplexFloat64],
    stride_b: Int64,
    c: UnsafePointer[Float64],
    stride_c: Int64,
    s: UnsafePointer[ComplexFloat64],
    stride_s: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_zrotg_strided_batched",
        fn (
            Handle,
            UnsafePointer[ComplexFloat64],
            Int64,
            UnsafePointer[ComplexFloat64],
            Int64,
            UnsafePointer[Float64],
            Int64,
            UnsafePointer[ComplexFloat64],
            Int64,
            Int32,
        ) -> Status,
    ]()(handle, a, stride_a, b, stride_b, c, stride_c, s, stride_s, batch_count)


fn rocblas_srot_batched_64(
    handle: Handle,
    n: Int64,
    x: OpaquePointer,
    incx: Int64,
    y: OpaquePointer,
    incy: Int64,
    c: UnsafePointer[Float32],
    s: UnsafePointer[Float32],
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_srot_batched_64",
        fn (
            Handle,
            Int64,
            OpaquePointer,
            Int64,
            OpaquePointer,
            Int64,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int64,
        ) -> Status,
    ]()(handle, n, x, incx, y, incy, c, s, batch_count)


fn rocblas_is_device_memory_size_query(handle: Handle) -> Bool:
    return _get_dylib_function[
        "rocblas_is_device_memory_size_query", fn (Handle) -> Bool
    ]()(handle)


fn rocblas_sgemm_strided_batched(
    handle: Handle,
    trans_a: Operation,
    trans_b: Operation,
    m: Int32,
    n: Int32,
    k: Int32,
    alpha: UnsafePointer[Float32],
    _a: UnsafePointer[Float32],
    lda: Int32,
    stride_a: Int64,
    _b: UnsafePointer[Float32],
    ldb: Int32,
    stride_b: Int64,
    beta: UnsafePointer[Float32],
    _c: UnsafePointer[Float32],
    ldc: Int32,
    stride_c: Int64,
    batch_count: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 3 API </b>.

    \\details
    gemm_strided_batched performs one of the strided batched matrix-matrix operations:

        C_i = alpha*op( A_i )*op( B_i ) + beta*C_i, for i = 1, ..., batch_count,

        where op( X ) is one of

        op( X ) = X      or
        op( X ) = X**T   or
        op( X ) = X**H,

        alpha and beta are scalars, and A, B and C are strided batched matrices, with
        op( A ) an m by k by batch_count strided_batched matrix,
        op( B ) an k by n by batch_count strided_batched matrix and
        C an m by n by batch_count strided_batched matrix.

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    transA    [rocblas_operation]
              specifies the form of op( A ).
    @param[in]
    transB    [rocblas_operation]
              specifies the form of op( B ).
    @param[in]
    m         [rocblas_int]
              matrix dimension m.
    @param[in]
    n         [rocblas_int]
              matrix dimension n.
    @param[in]
    k         [rocblas_int]
              matrix dimension k.
    @param[in]
    alpha     device pointer or host pointer specifying the scalar alpha.
    @param[in]
    A         device pointer pointing to the first matrix A_1.
    @param[in]
    lda       [rocblas_int]
              specifies the leading dimension of each A_i.
    @param[in]
    stride_a  [rocblas_stride]
              stride from the start of one A_i matrix to the next A_(i + 1).
    @param[in]
    B         device pointer pointing to the first matrix B_1.
    @param[in]
    ldb       [rocblas_int]
              specifies the leading dimension of each B_i.
    @param[in]
    stride_b  [rocblas_stride]
              stride from the start of one B_i matrix to the next B_(i + 1).
    @param[in]
    beta      device pointer or host pointer specifying the scalar beta.
    @param[in, out]
    C         device pointer pointing to the first matrix C_1.
    @param[in]
    ldc       [rocblas_int]
              specifies the leading dimension of each C_i.
    @param[in]
    stride_c  [rocblas_stride]
              stride from the start of one C_i matrix to the next C_(i + 1).
    @param[in]
    batch_count
              [rocblas_int]
              number of gemm operations in the batch.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_sgemm_strided_batched",
        fn (
            Handle,
            Operation,
            Operation,
            Int32,
            Int32,
            Int32,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int32,
            Int64,
            UnsafePointer[Float32],
            Int32,
            Int64,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        trans_a,
        trans_b,
        m,
        n,
        k,
        alpha,
        _a,
        lda,
        stride_a,
        _b,
        ldb,
        stride_b,
        beta,
        _c,
        ldc,
        stride_c,
        batch_count,
    )


fn rocblas_saxpy_strided_batched(
    handle: Handle,
    n: Int32,
    alpha: UnsafePointer[Float32],
    x: UnsafePointer[Float32],
    incx: Int32,
    stridex: Int64,
    y: UnsafePointer[Float32],
    incy: Int32,
    stridey: Int64,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_saxpy_strided_batched",
        fn (
            Handle,
            Int32,
            UnsafePointer[Float32],
            UnsafePointer[Float32],
            Int32,
            Int64,
            UnsafePointer[Float32],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(handle, n, alpha, x, incx, stridex, y, incy, stridey, batch_count)


fn rocblas_chbmv_strided_batched(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    k: Int32,
    alpha: UnsafePointer[ComplexFloat32],
    _a: UnsafePointer[ComplexFloat32],
    lda: Int32,
    stride__a: Int64,
    x: UnsafePointer[ComplexFloat32],
    incx: Int32,
    stride_x: Int64,
    beta: UnsafePointer[ComplexFloat32],
    y: UnsafePointer[ComplexFloat32],
    incy: Int32,
    stride_y: Int64,
    batch_count: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 2 API </b>.

    \\details
    hbmv_strided_batched performs one of the matrix-vector operations:

        y_i := alpha*A_i*x_i + beta*y_i
        where alpha and beta are scalars, x_i and y_i are n element vectors and A_i is an
        n by n Hermitian band matrix with k super-diagonals, for each batch in i = [1, batch_count].

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    uplo      [rocblas_fill]
            - rocblas_fill_upper: The upper triangular part of each A_i is being supplied.
            - rocblas_fill_lower: The lower triangular part of each A_i is being supplied.
    @param[in]
    n         [rocblas_int]
              the order of each matrix A_i.
    @param[in]
    k         [rocblas_int]
              the number of super-diagonals of each matrix A_i. Must be >= 0.
    @param[in]
    alpha     device pointer or host pointer to scalar alpha.
    @param[in]
    A         device array pointing to the first matrix A_1. Each A_i is of dimension (lda, n).

            if uplo == rocblas_fill_upper:
                The leading (k + 1) by n part of each A_i must contain the upper
                triangular band part of the Hermitian matrix, with the leading
                diagonal in row (k + 1), the first super-diagonal on the RHS
                of row k, etc.
                The top left k by x triangle of each A_i will not be referenced.
                    Ex (upper, lda = n = 4, k = 1):
                    A                             Represented matrix
                    (0,0) (5,9) (6,8) (7,7)       (1, 0) (5, 9) (0, 0) (0, 0)
                    (1,0) (2,0) (3,0) (4,0)       (5,-9) (2, 0) (6, 8) (0, 0)
                    (0,0) (0,0) (0,0) (0,0)       (0, 0) (6,-8) (3, 0) (7, 7)
                    (0,0) (0,0) (0,0) (0,0)       (0, 0) (0, 0) (7,-7) (4, 0)

            if uplo == rocblas_fill_lower:
                The leading (k + 1) by n part of each A_i must contain the lower
                triangular band part of the Hermitian matrix, with the leading
                diagonal in row (1), the first sub-diagonal on the LHS of
                row 2, etc.
                The bottom right k by k triangle of each A_i will not be referenced.
                    Ex (lower, lda = 2, n = 4, k = 1):
                    A                               Represented matrix
                    (1,0) (2,0) (3,0) (4,0)         (1, 0) (5,-9) (0, 0) (0, 0)
                    (5,9) (6,8) (7,7) (0,0)         (5, 9) (2, 0) (6,-8) (0, 0)
                                                    (0, 0) (6, 8) (3, 0) (7,-7)
                                                    (0, 0) (0, 0) (7, 7) (4, 0)

              As a Hermitian matrix, the imaginary part of the main diagonal
              of each A_i will not be referenced and is assumed to be == 0.
    @param[in]
    lda       [rocblas_int]
              specifies the leading dimension of each A_i. must be >= max(1, n).
    @param[in]
    stride_A  [rocblas_stride]
              stride from the start of one matrix (A_i) and the next one (A_i+1).
    @param[in]
    x         device array pointing to the first vector y_1.
    @param[in]
    incx      [rocblas_int]
              specifies the increment for the elements of each x_i.
    @param[in]
    stride_x  [rocblas_stride]
              stride from the start of one vector (x_i) and the next one (x_i+1).
    @param[in]
    beta      device pointer or host pointer to scalar beta.
    @param[in, out]
    y         device array pointing to the first vector y_1.
    @param[in]
    incy      [rocblas_int]
              specifies the increment for the elements of y.
    @param[in]
    stride_y  [rocblas_stride]
              stride from the start of one vector (y_i) and the next one (y_i+1).
    @param[in]
    batch_count [rocblas_int]
                number of instances in the batch.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_chbmv_strided_batched",
        fn (
            Handle,
            Fill,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat32],
            UnsafePointer[ComplexFloat32],
            Int32,
            Int64,
            Int32,
        ) -> Status,
    ]()(
        handle,
        uplo,
        n,
        k,
        alpha,
        _a,
        lda,
        stride__a,
        x,
        incx,
        stride_x,
        beta,
        y,
        incy,
        stride_y,
        batch_count,
    )


fn rocblas_dspr_strided_batched_64(
    handle: Handle,
    uplo: Fill,
    n: Int64,
    alpha: UnsafePointer[Float64],
    x: UnsafePointer[Float64],
    incx: Int64,
    stride_x: Int64,
    _ap: UnsafePointer[Float64],
    stride__a: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_dspr_strided_batched_64",
        fn (
            Handle,
            Fill,
            Int64,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int64,
            Int64,
            UnsafePointer[Float64],
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, uplo, n, alpha, x, incx, stride_x, _ap, stride__a, batch_count)


fn rocblas_scasum(
    handle: Handle,
    n: Int32,
    x: UnsafePointer[ComplexFloat32],
    incx: Int32,
    result: UnsafePointer[Float32],
) -> Status:
    return _get_dylib_function[
        "rocblas_scasum",
        fn (
            Handle,
            Int32,
            UnsafePointer[ComplexFloat32],
            Int32,
            UnsafePointer[Float32],
        ) -> Status,
    ]()(handle, n, x, incx, result)


fn rocblas_ssbmv_batched(
    handle: Handle,
    uplo: Fill,
    n: Int32,
    k: Int32,
    alpha: UnsafePointer[Float32],
    _a: OpaquePointer,
    lda: Int32,
    x: OpaquePointer,
    incx: Int32,
    beta: UnsafePointer[Float32],
    y: OpaquePointer,
    incy: Int32,
    batch_count: Int32,
) -> Status:
    """
    \\brief <b> BLAS Level 2 API </b>.

    \\details
    sbmv_batched performs the matrix-vector operation:

        y_i := alpha*A_i*x_i + beta*y_i
        where (A_i, x_i, y_i) is the i-th instance of the batch.
        alpha and beta are scalars, x_i and y_i are vectors and A_i is an
        n by n symmetric banded matrix, for i = 1, ..., batch_count.
        A should contain an upper or lower triangular n by n symmetric banded matrix.

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    uplo      [rocblas_fill]
            specifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'
            - if rocblas_fill_upper, the lower part of A is not referenced
            - if rocblas_fill_lower, the upper part of A is not referenced
    @param[in]
    n         [rocblas_int]
              number of rows and columns of each matrix A_i.
    @param[in]
    k         [rocblas_int]
              specifies the number of sub- and super-diagonals.
    @param[in]
    alpha
              device pointer or host pointer to scalar alpha.
    @param[in]
    A         device array of device pointers storing each matrix A_i.
    @param[in]
    lda       [rocblas_int]
              specifies the leading dimension of each matrix A_i.
    @param[in]
    x         device array of device pointers storing each vector x_i.
    @param[in]
    incx      [rocblas_int]
              specifies the increment for the elements of each vector x_i.
    @param[in]
    beta      device pointer or host pointer to scalar beta.
    @param[out]
    y         device array of device pointers storing each vector y_i.
    @param[in]
    incy      [rocblas_int]
              specifies the increment for the elements of each vector y_i.
    @param[in]
    batch_count [rocblas_int]
                number of instances in the batch.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_ssbmv_batched",
        fn (
            Handle,
            Fill,
            Int32,
            Int32,
            UnsafePointer[Float32],
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            UnsafePointer[Float32],
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(handle, uplo, n, k, alpha, _a, lda, x, incx, beta, y, incy, batch_count)


fn rocblas_bfdot_strided_batched_64(
    handle: Handle,
    n: Int64,
    x: UnsafePointer[BFloat16],
    incx: Int64,
    stridex: Int64,
    y: UnsafePointer[BFloat16],
    incy: Int64,
    stridey: Int64,
    batch_count: Int64,
    result: UnsafePointer[BFloat16],
) -> Status:
    return _get_dylib_function[
        "rocblas_bfdot_strided_batched_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[BFloat16],
            Int64,
            Int64,
            UnsafePointer[BFloat16],
            Int64,
            Int64,
            Int64,
            UnsafePointer[BFloat16],
        ) -> Status,
    ]()(handle, n, x, incx, stridex, y, incy, stridey, batch_count, result)


fn rocblas_zdotu_strided_batched(
    handle: Handle,
    n: Int32,
    x: UnsafePointer[ComplexFloat64],
    incx: Int32,
    stridex: Int64,
    y: UnsafePointer[ComplexFloat64],
    incy: Int32,
    stridey: Int64,
    batch_count: Int32,
    result: UnsafePointer[ComplexFloat64],
) -> Status:
    return _get_dylib_function[
        "rocblas_zdotu_strided_batched",
        fn (
            Handle,
            Int32,
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            UnsafePointer[ComplexFloat64],
            Int32,
            Int64,
            Int32,
            UnsafePointer[ComplexFloat64],
        ) -> Status,
    ]()(handle, n, x, incx, stridex, y, incy, stridey, batch_count, result)


fn rocblas_ctrmm_batched(
    handle: Handle,
    side: Side,
    uplo: Fill,
    trans_a: Operation,
    diag: Diagonal,
    m: Int32,
    n: Int32,
    alpha: UnsafePointer[ComplexFloat32],
    _a: OpaquePointer,
    lda: Int32,
    _b: OpaquePointer,
    ldb: Int32,
    _c: OpaquePointer,
    ldc: Int32,
    batch_count: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_ctrmm_batched",
        fn (
            Handle,
            Side,
            Fill,
            Operation,
            Diagonal,
            Int32,
            Int32,
            UnsafePointer[ComplexFloat32],
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            OpaquePointer,
            Int32,
            Int32,
        ) -> Status,
    ]()(
        handle,
        side,
        uplo,
        trans_a,
        diag,
        m,
        n,
        alpha,
        _a,
        lda,
        _b,
        ldb,
        _c,
        ldc,
        batch_count,
    )


fn rocblas_scal_batched_ex_64(
    handle: Handle,
    n: Int64,
    alpha: OpaquePointer,
    alpha_type: DataType,
    x: OpaquePointer,
    x_type: DataType,
    incx: Int64,
    batch_count: Int64,
    execution_type: DataType,
) -> Status:
    return _get_dylib_function[
        "rocblas_scal_batched_ex_64",
        fn (
            Handle,
            Int64,
            OpaquePointer,
            DataType,
            OpaquePointer,
            DataType,
            Int64,
            Int64,
            DataType,
        ) -> Status,
    ]()(
        handle,
        n,
        alpha,
        alpha_type,
        x,
        x_type,
        incx,
        batch_count,
        execution_type,
    )


fn rocblas_dsymm(
    handle: Handle,
    side: Side,
    uplo: Fill,
    m: Int32,
    n: Int32,
    alpha: UnsafePointer[Float64],
    _a: UnsafePointer[Float64],
    lda: Int32,
    _b: UnsafePointer[Float64],
    ldb: Int32,
    beta: UnsafePointer[Float64],
    _c: UnsafePointer[Float64],
    ldc: Int32,
) -> Status:
    return _get_dylib_function[
        "rocblas_dsymm",
        fn (
            Handle,
            Side,
            Fill,
            Int32,
            Int32,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int32,
            UnsafePointer[Float64],
            Int32,
            UnsafePointer[Float64],
            UnsafePointer[Float64],
            Int32,
        ) -> Status,
    ]()(handle, side, uplo, m, n, alpha, _a, lda, _b, ldb, beta, _c, ldc)


fn rocblas_cscal_batched_64(
    handle: Handle,
    n: Int64,
    alpha: UnsafePointer[ComplexFloat32],
    x: OpaquePointer,
    incx: Int64,
    batch_count: Int64,
) -> Status:
    return _get_dylib_function[
        "rocblas_cscal_batched_64",
        fn (
            Handle,
            Int64,
            UnsafePointer[ComplexFloat32],
            OpaquePointer,
            Int64,
            Int64,
        ) -> Status,
    ]()(handle, n, alpha, x, incx, batch_count)


fn rocblas_gemm_ex(
    handle: Handle,
    trans_a: Operation,
    trans_b: Operation,
    m: Int32,
    n: Int32,
    k: Int32,
    alpha: OpaquePointer,
    a: OpaquePointer,
    a_type: DataType,
    lda: Int32,
    b: OpaquePointer,
    b_type: DataType,
    ldb: Int32,
    beta: OpaquePointer,
    c: OpaquePointer,
    c_type: DataType,
    ldc: Int32,
    d: OpaquePointer,
    d_type: DataType,
    ldd: Int32,
    compute_type: DataType,
    algo: Algorithm,
    solution_index: Int32,
    flags: UInt32,
) -> Status:
    """
    \\brief <b> BLAS EX API </b>.

    \\details
    gemm_ex performs one of the matrix-matrix operations:

        D = alpha*op( A )*op( B ) + beta*C,

    where op( X ) is one of

        op( X ) = X      or
        op( X ) = X**T   or
        op( X ) = X**H,

    alpha and beta are scalars, and A, B, C, and D are matrices, with
    op( A ) an m by k matrix, op( B ) a k by n matrix and C and D are m by n matrices.
    C and D may point to the same matrix if their parameters are identical.

    Supported types are as follows:
        - rocblas_datatype_f64_r = a_type = b_type = c_type = d_type = compute_type
        - rocblas_datatype_f32_r = a_type = b_type = c_type = d_type = compute_type
        - rocblas_datatype_f16_r = a_type = b_type = c_type = d_type = compute_type
        - rocblas_datatype_f16_r = a_type = b_type = c_type = d_type; rocblas_datatype_f32_r =
    compute_type
        - rocblas_datatype_f16_r = a_type = b_type; rocblas_datatype_f32_r = c_type = d_type =
    compute_type
        - rocblas_datatype_bf16_r = a_type = b_type = c_type = d_type; rocblas_datatype_f32_r =
    compute_type
        - rocblas_datatype_bf16_r = a_type = b_type; rocblas_datatype_f32_r = c_type = d_type =
    compute_type
        - rocblas_datatype_i8_r = a_type = b_type; rocblas_datatype_i32_r = c_type = d_type =
    compute_type
        - rocblas_datatype_f32_c  = a_type = b_type = c_type = d_type = compute_type
        - rocblas_datatype_f64_c  = a_type = b_type = c_type = d_type = compute_type

    Although not widespread, some gemm kernels used by gemm_ex may use atomic operations.
    See Atomic Operations in the API Reference Guide for more information.

    @param[in]
    handle    [rocblas_handle]
              handle to the rocblas library context queue.
    @param[in]
    transA    [rocblas_operation]
              specifies the form of op( A ).
    @param[in]
    transB    [rocblas_operation]
              specifies the form of op( B ).
    @param[in]
    m         [rocblas_int]
              matrix dimension m.
    @param[in]
    n         [rocblas_int]
              matrix dimension n.
    @param[in]
    k         [rocblas_int]
              matrix dimension k.
    @param[in]
    alpha     [const void *]
              device pointer or host pointer specifying the scalar alpha. Same datatype as compute_type.
    @param[in]
    a         [void *]
              device pointer storing matrix A.
    @param[in]
    a_type    [rocblas_datatype]
              specifies the datatype of matrix A.
    @param[in]
    lda       [rocblas_int]
              specifies the leading dimension of A.
    @param[in]
    b         [void *]
              device pointer storing matrix B.
    @param[in]
    b_type    [rocblas_datatype]
              specifies the datatype of matrix B.
    @param[in]
    ldb       [rocblas_int]
              specifies the leading dimension of B.
    @param[in]
    beta      [const void *]
              device pointer or host pointer specifying the scalar beta. Same datatype as compute_type.
    @param[in]
    c         [void *]
              device pointer storing matrix C.
    @param[in]
    c_type    [rocblas_datatype]
              specifies the datatype of matrix C.
    @param[in]
    ldc       [rocblas_int]
              specifies the leading dimension of C.
    @param[out]
    d         [void *]
              device pointer storing matrix D.
              If d and c pointers are to the same matrix then d_type must equal c_type and ldd must equal ldc
              or the respective invalid status will be returned.
    @param[in]
    d_type    [rocblas_datatype]
              specifies the datatype of matrix D.
    @param[in]
    ldd       [rocblas_int]
              specifies the leading dimension of D.
    @param[in]
    compute_type
              [rocblas_datatype]
              specifies the datatype of computation.
    @param[in]
    algo      [rocblas_gemm_algo]
              enumerant specifying the algorithm type.
    @param[in]
    solution_index
              [int32_t]
              if algo is Algorithmsolution_index, this controls which solution is used.
              When algo is not Algorithmsolution_index, or if solution_index <= 0, the default solution is used.
              This parameter was unused in previous releases and instead always used the default solution
    @param[in]
    flags     [uint32_t]
              optional gemm flags.

    ******************************************************************."""
    return _get_dylib_function[
        "rocblas_gemm_ex",
        fn (
            Handle,
            Operation,
            Operation,
            Int32,
            Int32,
            Int32,
            OpaquePointer,
            OpaquePointer,
            DataType,
            Int32,
            OpaquePointer,
            DataType,
            Int32,
            OpaquePointer,
            OpaquePointer,
            DataType,
            Int32,
            OpaquePointer,
            DataType,
            Int32,
            DataType,
            Algorithm,
            Int32,
            UInt32,
        ) -> Status,
    ]()(
        handle,
        trans_a,
        trans_b,
        m,
        n,
        k,
        alpha,
        a,
        a_type,
        lda,
        b,
        b_type,
        ldb,
        beta,
        c,
        c_type,
        ldc,
        d,
        d_type,
        ldd,
        compute_type,
        algo,
        solution_index,
        flags,
    )


fn rocblas_set_stream(handle: Handle, stream: hipStream_t) -> Status:
    return _get_dylib_function[
        "rocblas_set_stream", fn (Handle, hipStream_t) -> Status
    ]()(handle, stream)
