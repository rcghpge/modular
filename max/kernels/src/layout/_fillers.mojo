# ===----------------------------------------------------------------------=== #
# Copyright (c) 2025, Modular Inc. All rights reserved.
#
# Licensed under the Apache License v2.0 with LLVM Exceptions:
# https://llvm.org/LICENSE.txt
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ===----------------------------------------------------------------------=== #

"""Tensor filling utilities for `LayoutTensor` objects.

This module provides functions for efficiently filling tensors with various patterns
of values, including sequences and random distributions.

The module includes:
- Sequential value generation (`arange`)
- Random value generation (`random`)
"""

from random import random_float64
from sys import is_nvidia_gpu

from utils.numerics import max_finite

# A batch size for filler functions loop bounds.
alias BATCH_SIZE = 2048


fn _filler_impl[
    dtype: DType,
    layout: Layout, //,
    filler: fn (i: Int) capturing [_] -> Scalar[dtype],
    use_runtime_layout: Bool = (
        not layout.all_dims_known() or layout.size() > BATCH_SIZE
    ),
](tensor: LayoutTensor[mut=True, dtype, layout, **_]):
    """Fills a tensor with values generated by a filler function.

    This function iterates through the elements of the tensor and
    assigns values based on the provided filler function. It handles
    both compile-time and runtime layouts.

    Parameters:
        dtype: The data type of the tensor elements.
        layout: The layout of the tensor.
        filler: A function that takes an index and returns a scalar value.
        use_runtime_layout: Whether to use the runtime layout for filling.
            This parameter is defaulted to `True` if the layout is not
            statically known. If loop bounds are too large, it's better to
            use the runtime layout to avoid long compilation time.

    Args:
        tensor: The tensor to fill.

    Performance:

        - For compile-time known layouts, the function uses parameter-time
          loop unrolling for optimal performance.
        - For runtime layouts, the function uses dynamic iteration.
        - Type casting is performed to ensure type compatibility.
    """

    @parameter
    if not use_runtime_layout:
        alias num_elements = tensor.layout.size() * tensor.element_size

        @parameter
        for i in range(num_elements):
            var val = filler(i)
            tensor.ptr[i] = val.cast[tensor.dtype]()
    else:
        var num_elements = tensor.runtime_layout.size() * tensor.element_size
        for i in range(num_elements):
            var val = filler(i)
            tensor.ptr[i] = val.cast[tensor.dtype]()


fn arange[
    dtype: DType,
    layout: Layout,
    /,
    *,
    use_runtime_layout: Bool = (
        not layout.all_dims_known() or layout.size() > BATCH_SIZE
    ),
](
    tensor: LayoutTensor[mut=True, dtype, layout, **_],
    start: Scalar[tensor.dtype] = 0,
    step: Scalar[tensor.dtype] = 1,
    end: Scalar[tensor.dtype] = max_finite[tensor.dtype](),
):
    """Fills a tensor with a sequence of values.

    This function generates a sequence of values within the specified range
    [start, end) with a given step, similar to `numpy.arange`, and fills
    the tensor with this sequence.

    Parameters:
        dtype: The data type of the tensor elements.
        layout: The layout of the tensor.
        use_runtime_layout: Whether to use the runtime layout for filling.
            This parameter is defaulted to `True` if the layout is not
            statically known. If loop bounds are too large, it's better to
            use the runtime layout to avoid long compilation time.

    Args:
        tensor: The tensor to fill.
        start: The starting value of the sequence.
        step: The step size between consecutive values.
        end: The ending value of the sequence (exclusive).

    Example:

        ```mojo
        from layout import Layout, LayoutTensor
        from layout._fillers import arange

        var storage = InlineArray[Scalar[DType.float32], 16](uninitialized=True)
        var tensor = LayoutTensor[DType.float32, Layout(4, 4)](storage)
        arange(tensor, 0, 0.5, 10)  # Fills with [0, 0.5, 1, 1.5, ...]
        ```
    """

    @parameter
    fn filler(i: Int) -> Scalar[tensor.dtype]:
        return (i * step + start) % end

    # Use layout info for 2D tensors
    @parameter
    if len(tensor.layout) != 2:
        _filler_impl[filler, use_runtime_layout](tensor)
    else:
        for m in range(tensor.runtime_layout.shape[0].value[0]):
            for n in range(tensor.runtime_layout.shape[1].value[0]):
                tensor[m, n] = (
                    (m * tensor.runtime_layout.shape[1].value[0] + n) * step
                    + start
                ) % end


fn random[
    dtype: DType,
    layout: Layout,
    /,
    *,
    use_runtime_layout: Bool = (
        not layout.all_dims_known() or layout.size() > BATCH_SIZE
    ),
](
    tensor: LayoutTensor[mut=True, dtype, layout, **_],
    min: Scalar[tensor.dtype] = 0,
    max: Scalar[tensor.dtype] = 1,
):
    """Fills a tensor with random values.

    This function generates uniformly distributed random numbers within the
    specified range [min, max) and fills the tensor with these values.

    Parameters:
        dtype: The data type of the tensor elements.
        layout: The layout of the tensor.
        use_runtime_layout: Whether to use the runtime layout for filling.
            This parameter is defaulted to `True` if the layout is not
            statically known. If loop bounds are too large, it's better to
            use the runtime layout to avoid long compilation time.

    Args:
        tensor: The tensor to fill.
        min: The minimum value (inclusive).
        max: The maximum value (exclusive).

    Constraint:
        Not available on NVIDIA GPUs due to platform limitations.

    Example:

        ```mojo
        from layout import Layout, LayoutTensor
        from layout._fillers import random

        var storage = InlineArray[Scalar[DType.float32], 16](uninitialized=True)
        var tensor = LayoutTensor[DType.float32, Layout(4, 4)](storage)
        random(tensor, -1.0, 1.0)  # Fills with random values between -1 and 1
        ```
        .
    """
    constrained[not is_nvidia_gpu(), "Cannot run random on the gpu"]()

    @parameter
    fn filler(i: Int) -> Scalar[tensor.dtype]:
        return random_float64(
            min.cast[DType.float64](), max.cast[DType.float64]()
        ).cast[tensor.dtype]()

    _filler_impl[filler, use_runtime_layout](tensor)
