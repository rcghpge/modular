# ===----------------------------------------------------------------------=== #
# Copyright (c) 2025, Modular Inc. All rights reserved.
#
# Licensed under the Apache License v2.0 with LLVM Exceptions:
# https://llvm.org/LICENSE.txt
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ===----------------------------------------------------------------------=== #
# GENERATED FILE, DO NOT EDIT MANUALLY!
# ===----------------------------------------------------------------------=== #

import enum
from collections.abc import Iterator, Sequence
from typing import Generic, TypeVar

import max._mlir.ir
from max.mlir import Context, Location
from max.mlir import Value as MlirValue

from . import (
    dialects as dialects,
)
from . import (
    driver as driver,
)
from . import (
    dtype as dtype,
)
from . import (
    engine as engine,
)
from . import (
    graph as graph,
)
from . import (
    nixl as nixl,
)
from . import (
    profiler as profiler,
)
from . import (
    safetensors as safetensors,
)

class Attribute:
    @staticmethod
    def _from_cmlir(arg: max._mlir.ir.Attribute, /) -> Attribute: ...
    def __eq__(self, arg: object, /) -> bool: ...
    def __hash__(self) -> int: ...
    @property
    def asm(self) -> str: ...
    def __repr__(self) -> str: ...
    @property
    def _CAPIPtr(self) -> object: ...

class NamedAttribute(tuple[str, Attribute]):
    def __init__(self, arg0: str, arg1: Attribute, /) -> None: ...
    @property
    def name(self): ...
    @property
    def value(self) -> Attribute: ...
    def __eq__(self, arg: object, /) -> bool: ...
    def __repr__(self) -> str: ...
    def __iter__(self) -> Iterator[str | Attribute]: ...

class TypeID:
    pass

class Type:
    @staticmethod
    def _from_cmlir(arg: max._mlir.ir.Type, /) -> Type: ...
    def __eq__(self, arg: object, /) -> bool: ...
    def __hash__(self) -> int: ...
    @property
    def asm(self) -> str: ...
    def __repr__(self) -> str: ...
    @property
    def _CAPIPtr(self) -> object: ...

T = TypeVar("T", bound=Type)

class Value(Generic[T]):
    @staticmethod
    def _from_cmlir(value: MlirValue, /) -> Value[Type]: ...
    def __eq__(self, arg: object, /) -> bool: ...
    def __hash__(self) -> int: ...
    @property
    def type(self) -> T: ...
    @property
    def owner(self) -> Block | Operation: ...
    @property
    def num_uses(self) -> int: ...
    @property
    def _CAPIPtr(self) -> object: ...

class OpOperand:
    @property
    def value(self) -> Value[Type]: ...
    @value.setter
    def value(self, value: Value[Type], /): ...

class InsertPoint:
    pass

class Block:
    @staticmethod
    def _from_cmlir(arg: max._mlir.ir.Block, /) -> Block: ...
    @property
    def arguments(self) -> Sequence[Value]: ...
    @property
    def parent_op(self) -> object: ...
    def add_argument(self, arg0: Type, arg1: Location, /) -> Value: ...
    def erase_argument(self, arg: int, /) -> None: ...
    @property
    def end(self) -> InsertPoint: ...

class DiscardableAttributes:
    def __getitem__(self, arg: str, /) -> Attribute: ...
    def __setitem__(self, arg0: str, arg1: Attribute, /) -> None: ...
    def __delitem__(self, arg: str, /) -> Attribute: ...
    def __contains__(self, arg: str, /) -> bool: ...
    def __len__(self) -> int: ...
    def __bool__(self) -> bool: ...
    def keys(self) -> Iterator[str]: ...
    def items(self) -> Iterator[NamedAttribute]: ...
    def values(self) -> Iterator[Attribute]: ...
    def __iter__(self) -> Iterator[str]: ...
    def __repr__(self) -> str: ...

class Operation:
    @staticmethod
    def _from_cmlir(arg: object, /) -> Operation: ...
    def __eq__(self, arg: object, /) -> bool: ...
    @property
    def context(self) -> Context: ...
    @property
    def results(self) -> Sequence[Value[Type]]: ...
    @property
    def regions(self) -> Sequence[Region]: ...
    @property
    def parent_op(self) -> object: ...
    def verify(self, verify_recursively: bool = True) -> None: ...
    def move_after(self, arg: Operation, /) -> None: ...
    @property
    def discardable_attributes(self) -> DiscardableAttributes: ...
    @property
    def asm(self) -> str: ...
    def __repr__(self) -> str: ...
    @property
    def _CAPIPtr(self) -> object: ...

class OpBuilder:
    def __init__(self, arg: InsertPoint, /) -> None: ...

class Region:
    @property
    def front(self) -> Block: ...
    @property
    def back(self) -> Block: ...

class LocationAttr:
    pass

class _BitVector:
    pass

class _TargetTriple:
    pass

class _RelocationModel(enum.Enum):  # type: ignore
    pass

class _MemoryEffect:
    pass

class SequenceView:
    def __len__(self) -> int: ...
    def __getitem__(self, arg: int, /) -> object: ...
    def __repr__(self) -> str: ...

class Pass:
    @property
    def name(self) -> str: ...
    @property
    def op_name(self) -> str | None: ...
    def __repr__(self) -> str: ...

class OpPassManager:
    pass

def lower(arg0: dialects.builtin.ModuleOp, arg1: Sequence[Pass], /) -> bool: ...

__version__: str
