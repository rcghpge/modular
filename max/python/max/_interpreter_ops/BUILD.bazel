load("//bazel:api.bzl", "modular_py_library", "mojo_library", "mojo_shared_library", "requirement")

package(default_visibility = ["//max:consumers"])

mojo_library(
    name = "op_utils",
    srcs = glob(["op_utils/*.mojo"]),
    deps = [
        "@mojo//:std",
    ],
)

[
    mojo_shared_library(
        name = name,
        srcs = [name + ".mojo"],
        shared_lib_name = name + ".so",
        deps = [
            ":op_utils",
            "//max:MOGGKernelAPI",
            "@mojo//:python",
        ],
    )
    for name in [
        "data_movement_ops",
        "elementwise_binary_ops",
        "elementwise_cast_ops",
        "elementwise_comparison_ops",
        "elementwise_unary_ops",
        "layer_norm_ops",
        "matmul_ops",
        "misc_ops",
        "reduce_ops",
        "softmax_ops",
    ]
]

_SHARED_LIBS = [
    ":data_movement_ops",
    ":elementwise_binary_ops",
    ":elementwise_cast_ops",
    ":elementwise_comparison_ops",
    ":elementwise_unary_ops",
    ":layer_norm_ops",
    ":matmul_ops",
    ":misc_ops",
    ":reduce_ops",
    ":softmax_ops",
]

# Wrap .mojo sources in a filegroup for macOS runtime compilation.
# On macOS (cross-compiled from Linux CI), the mojo_shared_library targets
# crash with SIGILL, so we fall back to runtime compilation via mojo.importer.
# Using a filegroup avoids the duplicate-srcs lint (find_duplicate_srcs.py
# ignores filegroup targets).
filegroup(
    name = "_mojo_srcs",
    srcs = glob(["**/*.mojo"]),
)

modular_py_library(
    name = "_interpreter_ops",
    srcs = glob(["**/*.py"]),
    data = select({
        "@platforms//os:macos": [
            ":_mojo_srcs",
            "//max:MOGGKernelAPI",
            "@mojo//:std",
        ],
        "//conditions:default": _SHARED_LIBS,
    }),
    deps = [
        "//max/python/max:_core",
        "//max/python/max/driver",
        "//max/python/max/dtype",
        "//max/python/max/graph",
        "@mojo//:python",
        requirement("numpy"),
    ],
)
