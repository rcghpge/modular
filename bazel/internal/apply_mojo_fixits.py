# ===----------------------------------------------------------------------=== #
# Copyright (c) 2026, Modular Inc. All rights reserved.
#
# Licensed under the Apache License v2.0 with LLVM Exceptions:
# https://llvm.org/LICENSE.txt
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ===----------------------------------------------------------------------=== #

import contextlib
import os
import subprocess
import sys
import tempfile
from collections.abc import Generator
from pathlib import Path

import yaml
from python.runfiles import runfiles

_R = runfiles.Create()


def _find_fixes() -> Generator[Path, None, None]:
    testlogs = Path(".") / "bazel-bin"
    for root, _, files in os.walk(testlogs):
        for file in files:
            if file.endswith(".mojo_fixits.yaml"):
                yield Path(root) / file


# before: /dev/shm/.../linux-sandbox/9572/execroot/_main/bazel-out/aarch64-dbg/bin/path/to/file.mojo
# after: path/to/file.mojo
def _rewrite_path(path: str) -> str:
    new_path = Path(".")
    for part in reversed(Path(path).parts):
        if part == "_main":
            break
        new_path = part / new_path

    # before: /buildbuddy/remotebuilds/d68d6e19-3a7a-4d60-98ed-f4b700f48dc9/max/examples/custom_ops/benchmarks.mojo
    # after: max/examples/custom_ops/benchmarks.mojo
    if len(new_path.parts) > 1 and new_path.parts[1] == "buildbuddy":
        new_path = Path(*new_path.parts[4:])

    return new_path.as_posix()


@contextlib.contextmanager
def _rewrite_replacements(file: Path):  # noqa: ANN202
    with open(file) as f:
        contents = yaml.safe_load(f)

    # This file is always generated by can be empty, skip those
    replacements = contents["Replacements"]
    if not replacements:
        os.remove(file)
        yield (None, None)
        return

    source_file = None
    for replacement in replacements:
        source_file = _rewrite_path(replacement["FilePath"])
        replacement["FilePath"] = source_file

    assert source_file is not None

    with tempfile.TemporaryDirectory() as directory:
        path = os.path.join(directory, "replacements.yaml")
        with open(path, "w") as tmp_file:
            yaml.dump(contents, tmp_file)
        assert os.path.exists(source_file), (
            f"error: {source_file}: doesn't exist"
        )
        yield (source_file, directory)

    os.remove(file)


def _apply_fixes(tool: str, directory: str) -> bool:
    try:
        subprocess.check_call(
            [
                tool,
                "--ignore-insert-conflict",
                directory,
            ]
        )
        return True
    except subprocess.CalledProcessError:
        print(
            "warning: clang-apply-replacements failed, maybe they've already been applied to this file?",
            file=sys.stderr,
        )
        return False


def _build_mojo_targets(build_args: list[str]) -> bool:
    try:
        result = subprocess.run(
            [
                "./bazelw",
                "build",
                "--@rules_mojo//:experimental_export_fixits",
                "--output_groups=+mojo_fixits",
                "--build_tag_filters=mojo-fixits",
                "//...",
            ]
            + build_args
        )
        return result.returncode == 0
    except KeyboardInterrupt:
        sys.exit(1)


def _main(bazel_build_args: list[str]) -> None:
    assert _R
    tool = _R.Rlocation(os.environ["TOOL_RLOCATION"])
    assert tool and os.path.exists(tool), f"error: {tool}: doesn't exist"

    while True:
        # Cleanup stale fixit files
        for file in _find_fixes():
            os.remove(file)

        success = _build_mojo_targets(bazel_build_args)

        applied_any_fixes = False
        for file in _find_fixes():
            with _rewrite_replacements(file) as (source_file, directory):
                if not source_file or not directory:
                    continue
                print("Applying fixes to:", source_file, file=sys.stderr)
                applied_any_fixes = (
                    _apply_fixes(tool, directory) or applied_any_fixes
                )

        if not applied_any_fixes:
            print("No more fixes to apply. Exiting.", file=sys.stderr)
            if not success:
                print(
                    "warning: the last build failed, after fixing the build failures there might be more fixits to apply.",
                    file=sys.stderr,
                )
            break


if __name__ == "__main__":
    os.chdir(os.environ["BUILD_WORKSPACE_DIRECTORY"])
    _main(sys.argv[1:])
